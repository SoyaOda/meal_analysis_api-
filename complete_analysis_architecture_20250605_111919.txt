================================================================================
MEAL ANALYSIS API - å®Œå…¨åˆ†æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ§‹é€ ã¨ãƒ•ã‚¡ã‚¤ãƒ«åˆ†æ
================================================================================
ç”Ÿæˆæ—¥æ™‚: 2025-06-05 11:19:19
åˆ†æå¯¾è±¡: /api/v1/meal-analyses/complete ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè¡Œæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹å…¨ãƒ•ã‚¡ã‚¤ãƒ«
================================================================================

ğŸ“Š COMPLETE ANALYSIS ARCHITECTURE OVERVIEW
----------------------------------------

ğŸ”„ COMPLETE EXECUTION FLOW (4-Phase Integrated Pipeline):
Phase 1: ç”»åƒ â†’ Gemini AI â†’ æ–™ç†ãƒ»é£Ÿæè­˜åˆ¥ (è‹±èªå)
USDA Query: å…¨é£Ÿæ â†’ USDA ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç…§åˆ â†’ FDC ID å–å¾—  
Phase 2: Phase1çµæœ + USDAå€™è£œ + ç”»åƒ â†’ Gemini AI â†’ è¨ˆç®—æˆ¦ç•¥æ±ºå®šãƒ»æ „é¤Šç²¾ç·»åŒ–
Nutrition Calculation: å®Ÿé‡é‡ Ã— USDAæ „é¤Šãƒ‡ãƒ¼ã‚¿ â†’ æœ€çµ‚æ „é¤Šä¾¡è¨ˆç®—ãƒ»é›†è¨ˆ

ğŸ—ï¸ INTEGRATED LAYER STRUCTURE:
â”œâ”€â”€ FastAPI Application Layer
â”‚   â””â”€â”€ main.py (Server, routing, CORS, error handling)
â”œâ”€â”€ Complete Analysis API Layer  
â”‚   â””â”€â”€ meal_analyses_complete.py (Unified endpoint for all phases)
â”œâ”€â”€ Service Layer
â”‚   â”œâ”€â”€ gemini_service.py (Vertex AI Geminié€£æº - Phase1&2)
â”‚   â”œâ”€â”€ usda_service.py (USDA FoodData Central APIé€£æº)
â”‚   â””â”€â”€ nutrition_calculation_service.py (Nutrition computation engine)
â”œâ”€â”€ Prompt Management Layer
â”‚   â”œâ”€â”€ prompt_loader.py (Template loading & management)
â”‚   â””â”€â”€ prompt templates (Phase1&2 system/user prompts)
â””â”€â”€ Configuration Layer
    â””â”€â”€ config.py (Environment variables, settings)

ğŸ”§ COMPLETE ANALYSIS TECHNICAL FEATURES:
- ğŸ”— Unified API Endpoint (/complete): All phases in single request
- ğŸ§  AI-Driven Strategy Selection: dish_level vs ingredient_level
- ğŸ“Š 3-Tier Nutrition Aggregation: ingredient â†’ dish â†’ meal  
- ğŸ’¾ Automatic Result Saving: JSON files with analysis_id
- ğŸ” 100% USDA Integration: Real nutrition data retrieval
- âš¡ Async Processing: Non-blocking operations throughout
- ğŸ›¡ï¸ Comprehensive Error Handling: Per-phase error isolation
- ğŸ“ˆ Real-time Logging: Detailed execution tracking

ğŸ¯ KEY IMPROVEMENTS OVER PHASE-BY-PHASE APPROACH:
- Single API call instead of multiple requests
- Automatic data flow between phases  
- Integrated error handling across all phases
- Built-in result persistence and retrieval
- Optimized resource usage with service caching

================================================================================

ğŸ“ FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
============================================================

ğŸ“„ FILE: app/main.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 4,212 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 11:09:24
å­˜åœ¨: âœ…

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine, meal_analyses_complete
from .core.config import get_settings

# ãƒ­ã‚®ãƒ³ã‚°ã®è¨­å®š
logging.basicConfig(
    level=logging.DEBUG,  # ä¸€æ™‚çš„ã«DEBUGãƒ¬ãƒ™ãƒ«ã«å¤‰æ›´
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)

# è¨­å®šã®å–å¾—
settings = get_settings()

# FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä½œæˆ
app = FastAPI(
    title="é£Ÿäº‹åˆ†æAPI (Meal Analysis API)",
    description="é£Ÿäº‹ã®ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æã—ã€æ–™ç†ã¨ææ–™ã‚’ç‰¹å®šã™ã‚‹APIã€‚USDAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã®é€£æºã«ã‚ˆã‚Šæ „é¤Šä¾¡è¨ˆç®—ã®ç²¾åº¦ã‚’å‘ä¸Šã€‚",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORSãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®è¨­å®šï¼ˆé–‹ç™ºç’°å¢ƒç”¨ï¼‰
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # æœ¬ç•ªç’°å¢ƒã§ã¯é©åˆ‡ã«åˆ¶é™ã™ã‚‹
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
@app.get("/")
async def root():
    """APIã®ãƒ«ãƒ¼ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""
    return {
        "message": "é£Ÿäº‹åˆ†æAPI (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
@app.get("/health")
async def health_check():
    """APIã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 APIãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API ãƒ•ã‚§ãƒ¼ã‚º2ãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²ï¼ˆ/refineã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼‰
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 APIå®Œå…¨åˆ†æãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²ï¼ˆå…¨ãƒ•ã‚§ãƒ¼ã‚ºçµ±åˆï¼‰
app.include_router(
    meal_analyses_complete.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Complete Meal Analysis"]
)

# ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
@app.on_event("startup")
async def startup_event():
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã®å‡¦ç†"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
@app.on_event("shutdown")
async def shutdown_event():
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†"""
    logger.info("Meal Analysis API shutting down...")

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "å†…éƒ¨ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
            }
        }
    ) 

# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œéƒ¨åˆ†
if __name__ == "__main__":
    import uvicorn
    import os
    
    # ç’°å¢ƒå¤‰æ•°ã®è¨­å®šï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    os.environ.setdefault("USDA_API_KEY", "vSWtKJ3jYD0Cn9LRyVJUFkuyCt9p8rEtVXz74PZg")
    os.environ.setdefault("GOOGLE_APPLICATION_CREDENTIALS", "/Users/odasoya/meal_analysis_api /service-account-key.json")
    os.environ.setdefault("GEMINI_PROJECT_ID", "recording-diet-ai-3e7cf")
    os.environ.setdefault("GEMINI_LOCATION", "us-central1")
    os.environ.setdefault("GEMINI_MODEL_NAME", "gemini-2.5-flash-preview-05-20")
    
    # ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="debug"
    ) 
```

============================================================

ğŸ“ å®Œå…¨åˆ†æAPI ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå±¤
============================================================

ğŸ“„ FILE: app/api/v1/endpoints/meal_analyses_complete.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 18,773 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 11:00:23
å­˜åœ¨: âœ…

CONTENT:
```
from fastapi import APIRouter, UploadFile, File, HTTPException, Depends
from fastapi.responses import JSONResponse
import json
import logging
from typing import Optional
from datetime import datetime
import os
import uuid
from pathlib import Path

from app.services.gemini_service import GeminiMealAnalyzer
from app.services.usda_service import USDAService
from app.services.nutrition_calculation_service import NutritionCalculationService
from app.core.config import get_settings

# ãƒ­ã‚®ãƒ³ã‚°ã®è¨­å®š
logger = logging.getLogger(__name__)

# ãƒ«ãƒ¼ã‚¿ãƒ¼ã®ä½œæˆ
router = APIRouter()

# è¨­å®šã®å–å¾—
settings = get_settings()

# çµæœä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆ
RESULTS_DIR = Path("analysis_results")
RESULTS_DIR.mkdir(exist_ok=True)

# ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
_gemini_analyzer = None
_usda_service = None
_nutrition_service = None

async def get_gemini_service():
    """GeminiMealAnalyzerã®ä¾å­˜æ€§æ³¨å…¥"""
    global _gemini_analyzer
    if _gemini_analyzer is None:
        settings = get_settings()
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer

async def get_usda_service():
    """USDAServiceã®ä¾å­˜æ€§æ³¨å…¥"""
    global _usda_service
    if _usda_service is None:
        _usda_service = USDAService()
    return _usda_service

async def get_nutrition_service():
    """NutritionCalculationServiceã®ä¾å­˜æ€§æ³¨å…¥"""
    global _nutrition_service
    if _nutrition_service is None:
        _nutrition_service = NutritionCalculationService()
    return _nutrition_service

def save_analysis_result(result_data: dict, analysis_id: str) -> str:
    """åˆ†æçµæœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"meal_analysis_{analysis_id}_{timestamp}.json"
        filepath = RESULTS_DIR / filename
        
        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
        result_data["metadata"] = {
            "analysis_id": analysis_id,
            "timestamp": datetime.now().isoformat(),
            "processing_pipeline": ["phase1", "usda_query", "phase2", "nutrition_calculation"]
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(result_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"Analysis result saved to: {filepath}")
        return str(filepath)
    except Exception as e:
        logger.error(f"Failed to save analysis result: {e}")
        raise HTTPException(status_code=500, detail="Failed to save analysis result")

@router.post("/complete")
async def complete_meal_analysis(
    image: UploadFile = File(...),
    save_results: bool = True,
    gemini_service: GeminiMealAnalyzer = Depends(get_gemini_service),
    usda_service: USDAService = Depends(get_usda_service),
    nutrition_service: NutritionCalculationService = Depends(get_nutrition_service)
):
    """
    å®Œå…¨ãªé£Ÿäº‹åˆ†æã‚’å®Ÿè¡Œï¼ˆå…¨ãƒ•ã‚§ãƒ¼ã‚ºçµ±åˆï¼‰
    
    - Phase 1: Gemini AIã«ã‚ˆã‚‹ç”»åƒåˆ†æ
    - USDA Query: é£Ÿæã®USDAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç…§åˆ
    - Phase 2: è¨ˆç®—æˆ¦ç•¥æ±ºå®šã¨æ „é¤Šä¾¡ç²¾ç·»åŒ–
    - Nutrition Calculation: æœ€çµ‚æ „é¤Šä¾¡è¨ˆç®—
    
    Args:
        image: åˆ†æå¯¾è±¡ã®é£Ÿäº‹ç”»åƒ
        save_results: çµæœã‚’ä¿å­˜ã™ã‚‹ã‹ã©ã†ã‹ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: True)
    
    Returns:
        å®Œå…¨ãªåˆ†æçµæœã¨æ „é¤Šä¾¡è¨ˆç®—
    """
    
    analysis_id = str(uuid.uuid4())[:8]  # çŸ­ç¸®ç‰ˆID
    
    try:
        # ç”»åƒã®æ¤œè¨¼
        if not image.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ç”»åƒã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        
        # ç”»åƒãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
        image_data = await image.read()
        logger.info(f"[{analysis_id}] Starting complete meal analysis pipeline")
        
        # === Phase 1: åˆæœŸç”»åƒåˆ†æ ===
        logger.info(f"[{analysis_id}] Phase 1: Initial image analysis")
        phase1_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_data,
            image_mime_type=image.content_type,
            optional_text=None
        )
        
        if not phase1_result or "dishes" not in phase1_result:
            raise HTTPException(status_code=422, detail="Phase 1: ç”»åƒã‹ã‚‰æ–™ç†ã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
        
        logger.info(f"[{analysis_id}] Phase 1 completed - Detected {len(phase1_result['dishes'])} dishes")
        
        # === USDA Query Phase: é£Ÿæã®USDAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç…§åˆ ===
        logger.info(f"[{analysis_id}] USDA Query Phase: Database matching")
        
        # å…¨é£Ÿæã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
        all_ingredients = []
        for dish in phase1_result["dishes"]:
            for ingredient in dish.get("ingredients", []):
                all_ingredients.append(ingredient["ingredient_name"])
        
        # USDAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã®ç…§åˆ
        usda_matches = {}
        for ingredient_name in all_ingredients:
            try:
                usda_results = await usda_service.search_foods(ingredient_name)
                if usda_results and len(usda_results) > 0:
                    # USDASearchResultItemã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è¾æ›¸ã«å¤‰æ›
                    best_match = usda_results[0]
                    usda_matches[ingredient_name] = {
                        "fdcId": best_match.fdc_id,
                        "description": best_match.description,
                        "dataType": best_match.data_type,
                        "score": best_match.score
                    }
                    logger.debug(f"[{analysis_id}] USDA match for '{ingredient_name}': FDC ID {best_match.fdc_id}")
                else:
                    logger.warning(f"[{analysis_id}] No USDA match for: {ingredient_name}")
            except Exception as e:
                logger.error(f"[{analysis_id}] USDA search error for '{ingredient_name}': {e}")
        
        logger.info(f"[{analysis_id}] USDA Query completed - {len(usda_matches)}/{len(all_ingredients)} ingredients matched")
        
        # === Phase 2: è¨ˆç®—æˆ¦ç•¥æ±ºå®šã¨æ „é¤Šä¾¡ç²¾ç·»åŒ– ===
        logger.info(f"[{analysis_id}] Phase 2: Strategy determination and nutritional refinement")
        
        # Phase 2ã§Gemini AIã«è¨ˆç®—æˆ¦ç•¥ã‚’æ±ºå®šã•ã›ã‚‹
        phase2_result = await gemini_service.analyze_image_with_usda_context(
            image_bytes=image_data,
            image_mime_type=image.content_type,
            usda_candidates_text=json.dumps(usda_matches),
            initial_ai_output_text=json.dumps(phase1_result)
        )
        
        if not phase2_result or "dishes" not in phase2_result:
            raise HTTPException(status_code=422, detail="Phase 2: æ „é¤Šä¾¡ã®ç²¾ç·»åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
        
        logger.info(f"[{analysis_id}] Phase 2 completed - Strategy determined and nutrition refined")
        
        # === Nutrition Calculation Phase: æœ€çµ‚æ „é¤Šä¾¡è¨ˆç®— ===
        logger.info(f"[{analysis_id}] Nutrition Calculation Phase: Final nutrition computation")
        
        # Phase 2ã®çµæœã‚’ãƒ™ãƒ¼ã‚¹ã«æ „é¤Šè¨ˆç®—ã‚’å®Ÿè¡Œ
        final_result = phase2_result.copy()
        
        # å„æ–™ç†ã®æ „é¤Šä¾¡ã‚’è¨ˆç®—
        for dish in final_result.get("dishes", []):
            calculation_strategy = dish.get("calculation_strategy", "ingredient_level")
            
            if calculation_strategy == "ingredient_level":
                # é£Ÿæãƒ¬ãƒ™ãƒ«ã®è¨ˆç®—
                total_calories = 0.0
                total_protein = 0.0
                total_carbs = 0.0
                total_fat = 0.0
                
                for ingredient in dish.get("ingredients", []):
                    fdc_id = ingredient.get("fdc_id")
                    weight_g = 0.0
                    
                    # Phase 1ã‹ã‚‰é‡é‡ã‚’å–å¾—
                    for phase1_dish in phase1_result.get("dishes", []):
                        if phase1_dish["dish_name"] == dish["dish_name"]:
                            for phase1_ingredient in phase1_dish.get("ingredients", []):
                                if phase1_ingredient["ingredient_name"] == ingredient["ingredient_name"]:
                                    weight_g = phase1_ingredient["weight_g"]
                                    break
                            break
                    
                    ingredient["weight_g"] = weight_g
                    
                    # USDAã‹ã‚‰æ „é¤Šãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                    if fdc_id:
                        try:
                            nutrition_data = await usda_service.get_food_details_for_nutrition(fdc_id)
                            if nutrition_data:
                                ingredient["key_nutrients_per_100g"] = nutrition_data
                                
                                # å®Ÿéš›ã®æ „é¤Šä¾¡ã‚’è¨ˆç®— (é‡é‡ * 100gã‚ãŸã‚Šæ „é¤Šä¾¡ / 100)
                                multiplier = weight_g / 100.0
                                actual_calories = (nutrition_data.get("calories_kcal", 0) or 0) * multiplier
                                actual_protein = (nutrition_data.get("protein_g", 0) or 0) * multiplier
                                actual_carbs = (nutrition_data.get("carbohydrates_g", 0) or 0) * multiplier
                                actual_fat = (nutrition_data.get("fat_g", 0) or 0) * multiplier
                                
                                ingredient["actual_nutrients"] = {
                                    "calories_kcal": round(actual_calories, 2),
                                    "protein_g": round(actual_protein, 2),
                                    "carbohydrates_g": round(actual_carbs, 2),
                                    "fat_g": round(actual_fat, 2)
                                }
                                
                                # æ–™ç†å…¨ä½“ã®æ „é¤Šä¾¡ã«åŠ ç®—
                                total_calories += actual_calories
                                total_protein += actual_protein
                                total_carbs += actual_carbs
                                total_fat += actual_fat
                                
                                logger.debug(f"[{analysis_id}] Calculated nutrition for {ingredient['ingredient_name']}: {actual_calories:.2f} kcal")
                            else:
                                logger.warning(f"[{analysis_id}] No nutrition data for FDC ID {fdc_id}")
                                ingredient["key_nutrients_per_100g"] = None
                                ingredient["actual_nutrients"] = None
                        except Exception as e:
                            logger.error(f"[{analysis_id}] Error getting nutrition data for FDC ID {fdc_id}: {e}")
                            ingredient["key_nutrients_per_100g"] = None
                            ingredient["actual_nutrients"] = None
                    else:
                        ingredient["key_nutrients_per_100g"] = None
                        ingredient["actual_nutrients"] = None
                
                # æ–™ç†å…¨ä½“ã®æ „é¤Šä¾¡ã‚’è¨­å®š
                dish["dish_total_actual_nutrients"] = {
                    "calories_kcal": round(total_calories, 2),
                    "protein_g": round(total_protein, 2),
                    "carbohydrates_g": round(total_carbs, 2),
                    "fat_g": round(total_fat, 2)
                }
                
            elif calculation_strategy == "dish_level":
                # æ–™ç†ãƒ¬ãƒ™ãƒ«ã®è¨ˆç®—
                dish_fdc_id = dish.get("fdc_id")
                dish_weight = sum(
                    next((phase1_ingredient["weight_g"] for phase1_dish in phase1_result.get("dishes", [])
                          if phase1_dish["dish_name"] == dish["dish_name"]
                          for phase1_ingredient in phase1_dish.get("ingredients", [])), 0)
                    for _ in [None]  # å˜ä¸€ã®åˆè¨ˆé‡é‡è¨ˆç®—
                )
                
                if dish_fdc_id and dish_weight > 0:
                    try:
                        nutrition_data = await usda_service.get_food_details_for_nutrition(dish_fdc_id)
                        if nutrition_data:
                            dish["key_nutrients_per_100g"] = nutrition_data
                            
                            # æ–™ç†å…¨ä½“ã®æ „é¤Šä¾¡ã‚’è¨ˆç®—
                            multiplier = dish_weight / 100.0
                            dish["dish_total_actual_nutrients"] = {
                                "calories_kcal": round((nutrition_data.get("calories_kcal", 0) or 0) * multiplier, 2),
                                "protein_g": round((nutrition_data.get("protein_g", 0) or 0) * multiplier, 2),
                                "carbohydrates_g": round((nutrition_data.get("carbohydrates_g", 0) or 0) * multiplier, 2),
                                "fat_g": round((nutrition_data.get("fat_g", 0) or 0) * multiplier, 2)
                            }
                        else:
                            dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
                    except Exception as e:
                        logger.error(f"[{analysis_id}] Error getting dish nutrition data for FDC ID {dish_fdc_id}: {e}")
                        dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
                else:
                    dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
        
        # é£Ÿäº‹å…¨ä½“ã®æ „é¤Šä¾¡ã‚’è¨ˆç®—
        meal_total_calories = 0.0
        meal_total_protein = 0.0
        meal_total_carbs = 0.0
        meal_total_fat = 0.0
        
        for dish in final_result.get("dishes", []):
            dish_nutrients = dish.get("dish_total_actual_nutrients", {})
            meal_total_calories += dish_nutrients.get("calories_kcal", 0)
            meal_total_protein += dish_nutrients.get("protein_g", 0)
            meal_total_carbs += dish_nutrients.get("carbohydrates_g", 0)
            meal_total_fat += dish_nutrients.get("fat_g", 0)
        
        final_result["total_meal_nutrients"] = {
            "calories_kcal": round(meal_total_calories, 2),
            "protein_g": round(meal_total_protein, 2),
            "carbohydrates_g": round(meal_total_carbs, 2),
            "fat_g": round(meal_total_fat, 2)
        }
        
        logger.info(f"[{analysis_id}] Nutrition Calculation completed - Total calories: {meal_total_calories:.2f} kcal")
        

        
        # === çµæœã®çµ±åˆã¨ä¿å­˜ ===
        complete_result = {
            "analysis_id": analysis_id,
            "phase1_result": phase1_result,
            "usda_matches_count": len(usda_matches),
            "usda_matches": usda_matches,
            "phase2_result": phase2_result,
            "final_nutrition_result": final_result,
            "processing_summary": {
                "total_dishes": len(final_result.get("dishes", [])),
                "total_ingredients": sum(len(dish.get("ingredients", [])) for dish in final_result.get("dishes", [])),
                "usda_match_rate": f"{len(usda_matches)}/{len(all_ingredients)} ({len(usda_matches)/len(all_ingredients)*100:.1f}%)" if all_ingredients else "0/0 (0%)",
                "total_calories": final_result.get("total_meal_nutrients", {}).get("calories_kcal", 0),
                "pipeline_status": "completed"
            }
        }
        
        # çµæœã®ä¿å­˜
        saved_file = None
        if save_results:
            saved_file = save_analysis_result(complete_result, analysis_id)
            complete_result["saved_to"] = saved_file
        
        logger.info(f"[{analysis_id}] Complete analysis pipeline finished successfully")
        
        return JSONResponse(
            status_code=200,
            content=complete_result
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[{analysis_id}] Complete analysis failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Complete analysis failed: {str(e)}"
        )

@router.get("/results")
async def list_saved_results():
    """ä¿å­˜ã•ã‚ŒãŸåˆ†æçµæœã®ä¸€è¦§ã‚’å–å¾—"""
    try:
        results = []
        for file_path in RESULTS_DIR.glob("meal_analysis_*.json"):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    results.append({
                        "filename": file_path.name,
                        "analysis_id": data.get("analysis_id"),
                        "timestamp": data.get("metadata", {}).get("timestamp"),
                        "summary": data.get("processing_summary", {}),
                        "file_path": str(file_path)
                    })
            except Exception as e:
                logger.error(f"Error reading result file {file_path}: {e}")
                continue
        
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
        results.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        
        return {
            "total_results": len(results),
            "results": results
        }
    except Exception as e:
        logger.error(f"Failed to list saved results: {e}")
        raise HTTPException(status_code=500, detail="Failed to list saved results")

@router.get("/results/{analysis_id}")
async def get_saved_result(analysis_id: str):
    """ç‰¹å®šã®åˆ†æçµæœã‚’å–å¾—"""
    try:
        # analysis_idã«ä¸€è‡´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢
        matching_files = list(RESULTS_DIR.glob(f"meal_analysis_{analysis_id}_*.json"))
        
        if not matching_files:
            raise HTTPException(status_code=404, detail=f"Analysis ID '{analysis_id}' not found")
        
        # æœ€æ–°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ï¼ˆè¤‡æ•°ã‚ã‚‹å ´åˆï¼‰
        latest_file = max(matching_files, key=lambda p: p.stat().st_mtime)
        
        with open(latest_file, 'r', encoding='utf-8') as f:
            result_data = json.load(f)
        
        return result_data
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get saved result for ID {analysis_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to get saved result") 
```

============================================================

ğŸ“ ã‚µãƒ¼ãƒ“ã‚¹å±¤
============================================================

ğŸ“„ FILE: app/services/gemini_service.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 9,130 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

from ..api.v1.schemas.meal import REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Geminiã®æ§‹é€ åŒ–å‡ºåŠ›ã®ãŸã‚ã®JSONã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆã€‚",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§°ã€‚"},
                    "type": {"type": "string", "description": "æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: ä¸»èœ, å‰¯èœ, ã‚¹ãƒ¼ãƒ—, ãƒ‡ã‚¶ãƒ¼ãƒˆï¼‰ã€‚"},
                    "quantity_on_plate": {"type": "string", "description": "çš¿ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹æ–™ç†ã®ãŠãŠã‚ˆãã®é‡ã‚„å€‹æ•°ï¼ˆä¾‹: '1æ¯', '2åˆ‡ã‚Œ', 'ç´„200g'ï¼‰ã€‚"},
                    "ingredients": {
                        "type": "array",
                        "description": "ã“ã®æ–™ç†ã«å«ã¾ã‚Œã‚‹ã¨æ¨å®šã•ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆã€‚",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ææ–™ã®åç§°ã€‚"},
                                "weight_g": {"type": "number", "description": "ãã®ææ–™ã®æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰ã€‚"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AIçµŒç”±ã§Geminiã‚’ä½¿ç”¨ã—ã¦é£Ÿäº‹ç”»åƒã‚’åˆ†æã™ã‚‹ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-1.5-flash"):
        """
        åˆæœŸåŒ–
        
        Args:
            project_id: GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆID
            location: Vertex AIã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¾‹: us-central1ï¼‰
            model_name: ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«å
        """
        # Vertex AIã®åˆæœŸåŒ–
        vertexai.init(project=project_id, location=location)
        
        # ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
        self.model = GenerativeModel(model_name=model_name)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã®åˆæœŸåŒ–
        self.prompt_loader = PromptLoader()
        
        # generation_configã‚’ä½œæˆ
        self.generation_config = GenerationConfig(
            temperature=0.2,
            top_p=0.9,
            top_k=20,
            max_output_tokens=8192,
            response_mime_type="application/json",
            response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
        )
        
        # ã‚»ãƒ¼ãƒ•ãƒ†ã‚£è¨­å®š
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }
    
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æã—ã¦é£Ÿäº‹æƒ…å ±ã‚’æŠ½å‡º
        
        Args:
            image_bytes: ç”»åƒã®ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿
            image_mime_type: ç”»åƒã®MIMEã‚¿ã‚¤ãƒ—
            optional_text: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆèª¬æ˜
            
        Returns:
            åˆ†æçµæœã®è¾æ›¸
            
        Raises:
            RuntimeError: Gemini APIã‚¨ãƒ©ãƒ¼æ™‚
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒªã‚¹ãƒˆã‚’ä½œæˆ
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # Gemini APIã‚’å‘¼ã³å‡ºã—ï¼ˆéåŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ï¼‰
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        USDAã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ç”¨ã—ã¦ç”»åƒã‚’å†åˆ†æï¼ˆãƒ•ã‚§ãƒ¼ã‚º2ï¼‰
        
        Args:
            image_bytes: ç”»åƒã®ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿
            image_mime_type: ç”»åƒã®MIMEã‚¿ã‚¤ãƒ—
            usda_candidates_text: USDAå€™è£œæƒ…å ±ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆ
            initial_ai_output_text: ãƒ•ã‚§ãƒ¼ã‚º1ã®AIå‡ºåŠ›ï¼ˆJSONæ–‡å­—åˆ—ï¼‰
            
        Returns:
            ç²¾ç·»åŒ–ã•ã‚ŒãŸåˆ†æçµæœã®è¾æ›¸
            
        Raises:
            RuntimeError: Gemini APIã‚¨ãƒ©ãƒ¼æ™‚
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                usda_candidates=usda_candidates_text,
                initial_ai_output=initial_ai_output_text
            )
            
            # å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒªã‚¹ãƒˆã‚’ä½œæˆ
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # ãƒ•ã‚§ãƒ¼ã‚º2ç”¨ã®Generation Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIã‚’å‘¼ã³å‡ºã—
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")
            
            # JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
            result = json.loads(response.text)
            
            logger.info(f"Gemini phase 2 analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in phase 2: {e}. Raw response: {getattr(response, 'text', 'N/A')}")
            raise RuntimeError(f"Error processing response from Gemini (Phase 2): {e}") from e
        except Exception as e:
            import traceback
            logger.error(f"Vertex AI/Gemini API error in phase 2: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e 
```

============================================================

ğŸ“„ FILE: app/services/usda_service.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 16,154 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings

logger = logging.getLogger(__name__)


class USDANutrient:
    """USDAæ „é¤Šç´ æƒ…å ±ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self, name: str, amount: float, unit_name: str, 
                 nutrient_id: Optional[int] = None, 
                 nutrient_number: Optional[str] = None):
        self.name = name
        self.amount = amount
        self.unit_name = unit_name
        self.nutrient_id = nutrient_id
        self.nutrient_number = nutrient_number


class USDASearchResultItem:
    """USDAæ¤œç´¢çµæœã‚¢ã‚¤ãƒ†ãƒ ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self, fdc_id: int, description: str, 
                 data_type: Optional[str] = None,
                 brand_owner: Optional[str] = None,
                 ingredients_text: Optional[str] = None,
                 food_nutrients: List[USDANutrient] = None,
                 score: Optional[float] = None):
        self.fdc_id = fdc_id
        self.description = description
        self.data_type = data_type
        self.brand_owner = brand_owner
        self.ingredients_text = ingredients_text
        self.food_nutrients = food_nutrients or []
        self.score = score


class USDAService:
    """USDA FoodData Central APIã¨ã®é€šä¿¡ã‚’ç®¡ç†ã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClientã®è¨­å®š
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central APIã§é£Ÿå“ã‚’æ¤œç´¢
        
        Args:
            query: æ¤œç´¢ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—
            data_types: ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆï¼ˆä¾‹: ["Foundation", "SR Legacy", "Branded"]ï¼‰
            page_size: 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®çµæœæ•°
            page_number: å–å¾—ã™ã‚‹ãƒšãƒ¼ã‚¸ç•ªå·
            sort_by: ã‚½ãƒ¼ãƒˆã‚­ãƒ¼
            sort_order: ã‚½ãƒ¼ãƒˆé †ï¼ˆ"asc" ã¾ãŸã¯ "desc"ï¼‰
            
        Returns:
            USDASearchResultItemã®ãƒªã‚¹ãƒˆ
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™
            params["dataType"] = ",".join(data_types)
        
        try:
            logger.info(f"USDA API search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆæƒ…å ±ã®ãƒ­ã‚°
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrientsãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ä¸»è¦æ „é¤Šç´ ã‚’æŠ½å‡º
        
        Args:
            food_nutrients: USDA APIã‹ã‚‰è¿”ã•ã‚Œã‚‹æ „é¤Šç´ ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
            
        Returns:
            USDANutrientã®ãƒªã‚¹ãƒˆ
        """
        nutrients_extracted = []
        
        for nutrient_entry in food_nutrients:
            # æ „é¤Šç´ æƒ…å ±ã®æŠ½å‡ºï¼ˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã‚ˆã£ã¦ç•°ãªã‚‹ï¼‰
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # Branded Foodsã®abridgedãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¸ã®å¯¾å¿œ
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                nutrient_id = nutrient_entry.get("nutrientId")
                name = nutrient_entry.get("nutrientName")
                number = nutrient_entry.get("nutrientNumber")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")  # Branded abridgedã§ã¯"value"
            else:
                # SR Legacy, Foundation, ã¾ãŸã¯ full Branded
                nutrient_id = nutrient_detail.get("id")
                name = nutrient_detail.get("name")
                number = nutrient_detail.get("number")
                unit_name = nutrient_detail.get("unitName")
            
            # ä¸»è¦æ „é¤Šç´ ã®ã¿ã‚’æŠ½å‡º
            if number and str(number) in self.key_nutrient_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        
        return nutrients_extracted
    
    async def get_food_details(
        self, 
        fdc_id: int, 
        format: str = "full",
        target_nutrient_numbers: Optional[List[str]] = None
    ) -> Optional[USDASearchResultItem]:
        """
        ç‰¹å®šã®FDC IDã®é£Ÿå“è©³ç´°æƒ…å ±ã‚’å–å¾—
        
        Args:
            fdc_id: é£Ÿå“ã®FDC ID
            format: ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ï¼ˆ"abridged" ã¾ãŸã¯ "full"ï¼‰
            target_nutrient_numbers: å–å¾—ã™ã‚‹æ „é¤Šç´ ç•ªå·ã®ãƒªã‚¹ãƒˆ
            
        Returns:
            USDASearchResultItem ã¾ãŸã¯ None
        """
        params = {
            "api_key": self.api_key,
            "format": format
        }
        
        if target_nutrient_numbers:
            params["nutrients"] = ",".join(target_nutrient_numbers)
        
        try:
            logger.info(f"USDA API get food details: fdc_id={fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            response.raise_for_status()
            
            food_data = response.json()
            nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted
            )
            
        except Exception as e:
            logger.error(f"Error fetching food details for FDC ID {fdc_id}: {str(e)}")
            return None

    async def get_food_details_for_nutrition(self, fdc_id: int) -> Optional[Dict[str, float]]:
        """
        æ „é¤Šè¨ˆç®—ç”¨ã®é£Ÿå“è©³ç´°æƒ…å ±ã‚’å–å¾—ï¼ˆä»•æ§˜æ›¸æº–æ‹ ï¼‰
        
        å…¥åŠ›: FDC ID
        å‡¦ç†: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèªå¾Œã€å¿…è¦ãªã‚‰USDA APIã‹ã‚‰é£Ÿå“è©³ç´°ã‚’å–å¾—ã—ã€ä¸»è¦æ „é¤Šç´ ï¼ˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§å®šç¾©ã•ã‚ŒãŸIDï¼‰ã‚’100gã‚ãŸã‚Šã§æŠ½å‡ºãƒ»ãƒ‘ãƒ¼ã‚¹ã€‚çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ã€‚
        å‡ºåŠ›: 100gã‚ãŸã‚Šã®ä¸»è¦æ „é¤Šç´ è¾æ›¸ã€ã¾ãŸã¯ Noneã€‚
        
        Args:
            fdc_id: é£Ÿå“ã®FDC ID
            
        Returns:
            Optional[Dict[str, float]]: 100gã‚ãŸã‚Šã®ä¸»è¦æ „é¤Šç´ è¾æ›¸ã€ã¾ãŸã¯ None
        """
        if not fdc_id:
            logger.warning("Invalid FDC ID provided")
            return None
        
        try:
            # TODO: å°†æ¥çš„ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã‚’å®Ÿè£…ï¼ˆRedisç­‰ï¼‰
            # ç¾çŠ¶ã¯ç›´æ¥APIã‹ã‚‰å–å¾—
            
            logger.info(f"USDA API get food details for nutrition: fdc_id={fdc_id}")
            
            params = {
                "api_key": self.api_key,
                "format": "full",  # è©³ç´°ãªæ „é¤Šæƒ…å ±ãŒå¿…è¦
                "nutrients": ",".join(self.key_nutrient_numbers)  # ä¸»è¦æ „é¤Šç´ ã®ã¿ã‚’å–å¾—
            }
            
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            # ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆæƒ…å ±ã®ãƒ­ã‚°
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data_raw = response.json()
            
            # ä¸»è¦æ „é¤Šç´ ã‚’æŠ½å‡ºãƒ»ãƒ‘ãƒ¼ã‚¹
            key_nutrients = self._parse_nutrients_for_calculation(food_data_raw)
            
            if key_nutrients:
                logger.info(f"Successfully extracted {len(key_nutrients)} key nutrients for FDC ID {fdc_id}")
                # TODO: å°†æ¥çš„ã«ã“ã“ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
                return key_nutrients
            else:
                logger.warning(f"No key nutrients found for FDC ID {fdc_id}")
                return None
                
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error for FDC ID {fdc_id}: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found")
                return None
            elif e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded for FDC ID {fdc_id}") from e
            raise RuntimeError(f"USDA API error for FDC ID {fdc_id}: {e.response.status_code}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}")
            raise RuntimeError(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error getting food details for nutrition (FDC ID {fdc_id}): {str(e)}")
            return None

    def _parse_nutrients_for_calculation(self, food_data_raw: dict) -> Dict[str, float]:
        """
        USDA APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ „é¤Šè¨ˆç®—ç”¨ã®ä¸»è¦æ „é¤Šç´ ã‚’æŠ½å‡ºï¼ˆå†…éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
        
        Args:
            food_data_raw: USDA APIã‹ã‚‰ã®ç”Ÿã®é£Ÿå“ãƒ‡ãƒ¼ã‚¿
            
        Returns:
            Dict[str, float]: ä¸»è¦æ „é¤Šç´ è¾æ›¸ï¼ˆã‚­ãƒ¼ã¯æ¨™æº–åŒ–ã•ã‚ŒãŸåå‰ï¼‰
        """
        key_nutrients = {}
        
        try:
            food_nutrients = food_data_raw.get("foodNutrients", [])
            
            for nutrient_entry in food_nutrients:
                # æ „é¤Šç´ æƒ…å ±ã®æŠ½å‡ºï¼ˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«ã‚ˆã£ã¦ç•°ãªã‚‹ï¼‰
                nutrient_detail = nutrient_entry.get("nutrient", {})
                amount = nutrient_entry.get("amount")
                
                # Branded Foodsã®abridgedãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¸ã®å¯¾å¿œ
                if not nutrient_detail and "nutrientId" in nutrient_entry:
                    number = nutrient_entry.get("nutrientNumber")
                    amount = nutrient_entry.get("value")  # Branded abridgedã§ã¯"value"
                else:
                    # SR Legacy, Foundation, ã¾ãŸã¯ full Branded
                    number = nutrient_detail.get("number")
                
                # ä¸»è¦æ „é¤Šç´ ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ „é¤Šç´ ç•ªå·ã‹ã‚‰æ¨™æº–åŒ–ã•ã‚ŒãŸã‚­ãƒ¼åã¸ï¼‰
                if number and str(number) in self.key_nutrient_numbers and amount is not None:
                    if str(number) == "208":  # Energy (calories)
                        key_nutrients["calories_kcal"] = float(amount)
                    elif str(number) == "203":  # Protein
                        key_nutrients["protein_g"] = float(amount)
                    elif str(number) == "204":  # Total lipid (fat)
                        key_nutrients["fat_g"] = float(amount)
                    elif str(number) == "205":  # Carbohydrate, by difference
                        key_nutrients["carbohydrates_g"] = float(amount)
                    elif str(number) == "291":  # Fiber, total dietary (optional)
                        key_nutrients["fiber_g"] = float(amount)
                    elif str(number) == "269":  # Sugars, total (optional)
                        key_nutrients["sugars_g"] = float(amount)
                    elif str(number) == "307":  # Sodium (optional)
                        key_nutrients["sodium_mg"] = float(amount)
            
            # å¿…é ˆæ „é¤Šç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯0.0ã¨ã—ã¦è¨­å®š
            essential_nutrients = ["calories_kcal", "protein_g", "fat_g", "carbohydrates_g"]
            for nutrient in essential_nutrients:
                if nutrient not in key_nutrients:
                    key_nutrients[nutrient] = 0.0
                    logger.debug(f"Missing essential nutrient {nutrient}, set to 0.0")
            
            logger.debug(f"Parsed key nutrients: {key_nutrients}")
            return key_nutrients
            
        except Exception as e:
            logger.error(f"Error parsing nutrients for calculation: {str(e)}")
            return {}
    
    async def close_client(self):
        """HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚º"""
        await self.client.aclose()


# FastAPIã®ä¾å­˜æ€§æ³¨å…¥ç”¨é–¢æ•°
async def get_usda_service():
    """
    USDAServiceã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æä¾›ã™ã‚‹ä¾å­˜æ€§æ³¨å…¥é–¢æ•°
    """
    service = USDAService()
    try:
        yield service
    finally:
        await service.close_client() 
```

============================================================

ğŸ“„ FILE: app/services/nutrition_calculation_service.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 6,979 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
"""
æ „é¤Šç´ è¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹

ã“ã®ã‚µãƒ¼ãƒ“ã‚¹ã¯ç´”ç²‹ãªè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚’æä¾›ã—ã¾ã™ï¼š
1. 100gã‚ãŸã‚Šã®æ „é¤Šç´ ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å®Ÿéš›ã®æ „é¤Šç´ ã‚’è¨ˆç®—
2. é£Ÿæãƒªã‚¹ãƒˆã‹ã‚‰æ–™ç†å…¨ä½“ã®æ „é¤Šç´ ã‚’é›†è¨ˆ
3. æ–™ç†ãƒªã‚¹ãƒˆã‹ã‚‰é£Ÿäº‹å…¨ä½“ã®æ „é¤Šç´ ã‚’é›†è¨ˆ
"""

import logging
from typing import List, Optional, Dict
from ..api.v1.schemas.meal import CalculatedNutrients, RefinedIngredient, RefinedDish

logger = logging.getLogger(__name__)


class NutritionCalculationService:
    """æ „é¤Šç´ è¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def calculate_actual_nutrients(
        key_nutrients_per_100g: Dict[str, float], 
        estimated_weight_g: float
    ) -> CalculatedNutrients:
        """
        100gã‚ãŸã‚Šã®ä¸»è¦æ „é¤Šç´ ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å®Ÿéš›ã®æ „é¤Šç´ é‡ã‚’è¨ˆç®—
        
        Args:
            key_nutrients_per_100g: 100gã‚ãŸã‚Šã®ä¸»è¦æ „é¤Šç´ ãƒ‡ãƒ¼ã‚¿
            estimated_weight_g: æ¨å®šã‚°ãƒ©ãƒ æ•°
            
        Returns:
            CalculatedNutrients: è¨ˆç®—æ¸ˆã¿æ „é¤Šç´ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        if not key_nutrients_per_100g or estimated_weight_g <= 0:
            logger.warning(f"Invalid input: key_nutrients_per_100g={key_nutrients_per_100g}, estimated_weight_g={estimated_weight_g}")
            return CalculatedNutrients()  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼ˆå…¨ã¦0.0ï¼‰ã‚’è¿”ã™
        
        try:
            # è¨ˆç®—å¼: (Nutrient_Value_per_100g / 100) Ã— estimated_weight_g
            multiplier = estimated_weight_g / 100.0
            
            # å„æ „é¤Šç´ ã‚’è¨ˆç®—ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„/Noneã®å ´åˆã¯0.0ã¨ã—ã¦æ‰±ã†ï¼‰
            calories_kcal = round((key_nutrients_per_100g.get('calories_kcal', 0.0) or 0.0) * multiplier, 2)
            protein_g = round((key_nutrients_per_100g.get('protein_g', 0.0) or 0.0) * multiplier, 2)
            carbohydrates_g = round((key_nutrients_per_100g.get('carbohydrates_g', 0.0) or 0.0) * multiplier, 2)
            fat_g = round((key_nutrients_per_100g.get('fat_g', 0.0) or 0.0) * multiplier, 2)
            
            result = CalculatedNutrients(
                calories_kcal=calories_kcal,
                protein_g=protein_g,
                carbohydrates_g=carbohydrates_g,
                fat_g=fat_g
            )
            
            logger.debug(f"Calculated nutrients for {estimated_weight_g}g: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error calculating actual nutrients: {e}")
            return CalculatedNutrients()  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
    
    @staticmethod
    def aggregate_nutrients_for_dish_from_ingredients(
        ingredients: List[RefinedIngredient]
    ) -> CalculatedNutrients:
        """
        ææ–™ãƒªã‚¹ãƒˆã‹ã‚‰æ–™ç†å…¨ä½“ã®æ „é¤Šç´ ã‚’é›†è¨ˆ
        
        Args:
            ingredients: RefinedIngredientã®ãƒªã‚¹ãƒˆï¼ˆå„è¦ç´ ã¯è¨ˆç®—æ¸ˆã¿ã®actual_nutrientsã‚’æŒã¤ï¼‰
            
        Returns:
            CalculatedNutrients: æ–™ç†ã®é›†è¨ˆæ „é¤Šç´ 
        """
        if not ingredients:
            logger.warning("No ingredients provided for aggregation")
            return CalculatedNutrients()
        
        try:
            total_calories = 0.0
            total_protein = 0.0
            total_carbohydrates = 0.0
            total_fat = 0.0
            
            calculated_count = 0
            
            for ingredient in ingredients:
                if ingredient.actual_nutrients:
                    total_calories += ingredient.actual_nutrients.calories_kcal
                    total_protein += ingredient.actual_nutrients.protein_g
                    total_carbohydrates += ingredient.actual_nutrients.carbohydrates_g
                    total_fat += ingredient.actual_nutrients.fat_g
                    calculated_count += 1
                else:
                    logger.warning(f"Ingredient '{ingredient.ingredient_name}' has no actual_nutrients")
            
            # å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã«ä¸¸ã‚ã‚‹
            result = CalculatedNutrients(
                calories_kcal=round(total_calories, 2),
                protein_g=round(total_protein, 2),
                carbohydrates_g=round(total_carbohydrates, 2),
                fat_g=round(total_fat, 2)
            )
            
            logger.info(f"Aggregated nutrients from {calculated_count}/{len(ingredients)} ingredients: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error aggregating nutrients for dish: {e}")
            return CalculatedNutrients()
    
    @staticmethod
    def aggregate_nutrients_for_meal(
        dishes: List[RefinedDish]
    ) -> CalculatedNutrients:
        """
        æ–™ç†ãƒªã‚¹ãƒˆã‹ã‚‰é£Ÿäº‹å…¨ä½“ã®æ „é¤Šç´ ã‚’é›†è¨ˆ
        
        Args:
            dishes: RefinedDishã®ãƒªã‚¹ãƒˆï¼ˆå„è¦ç´ ã¯è¨ˆç®—æ¸ˆã¿ã®dish_total_actual_nutrientsã‚’æŒã¤ï¼‰
            
        Returns:
            CalculatedNutrients: é£Ÿäº‹å…¨ä½“ã®ç·æ „é¤Šç´ 
        """
        if not dishes:
            logger.warning("No dishes provided for meal aggregation")
            return CalculatedNutrients()
        
        try:
            total_calories = 0.0
            total_protein = 0.0
            total_carbohydrates = 0.0
            total_fat = 0.0
            
            calculated_count = 0
            
            for dish in dishes:
                if dish.dish_total_actual_nutrients:
                    total_calories += dish.dish_total_actual_nutrients.calories_kcal
                    total_protein += dish.dish_total_actual_nutrients.protein_g
                    total_carbohydrates += dish.dish_total_actual_nutrients.carbohydrates_g
                    total_fat += dish.dish_total_actual_nutrients.fat_g
                    calculated_count += 1
                else:
                    logger.warning(f"Dish '{dish.dish_name}' has no dish_total_actual_nutrients")
            
            # å°æ•°ç‚¹ä»¥ä¸‹2æ¡ã«ä¸¸ã‚ã‚‹
            result = CalculatedNutrients(
                calories_kcal=round(total_calories, 2),
                protein_g=round(total_protein, 2),
                carbohydrates_g=round(total_carbohydrates, 2),
                fat_g=round(total_fat, 2)
            )
            
            logger.info(f"Aggregated meal nutrients from {calculated_count}/{len(dishes)} dishes: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error aggregating nutrients for meal: {e}")
            return CalculatedNutrients()


# ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ã™ã‚‹ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°
def get_nutrition_calculation_service() -> NutritionCalculationService:
    """
    æ „é¤Šè¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
    
    Returns:
        NutritionCalculationService: æ „é¤Šè¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    """
    return NutritionCalculationService() 
```

============================================================

ğŸ“ è¨­å®šç®¡ç†
============================================================

ğŸ“„ FILE: app/core/config.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 2,180 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    APIè¨­å®šã‚¯ãƒ©ã‚¹
    ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šå€¤ã‚’èª­ã¿è¾¼ã‚€
    """
    # Vertex AIè¨­å®š
    GEMINI_PROJECT_ID: str  # GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDï¼ˆå¿…é ˆï¼‰
    GEMINI_LOCATION: str = "us-central1"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA APIè¨­å®š
    USDA_API_KEY: str  # USDA FoodData Central APIã‚­ãƒ¼ï¼ˆå¿…é ˆï¼‰
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # APIã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç§’æ•°
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1å›ã®æ¤œç´¢ã§å–å¾—ã™ã‚‹æœ€å¤§å€™è£œæ•°
    # ä¸»è¦æ „é¤Šç´ ç•ªå·ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã¨ã—ã¦ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã‚€ï¼‰
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """ä¸»è¦æ „é¤Šç´ ç•ªå·ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®š
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redisã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã®URL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDAãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹æœŸé–“ï¼ˆ1æ™‚é–“ï¼‰
    
    # APIè¨­å®š
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # ã‚µãƒ¼ãƒãƒ¼è¨­å®š
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # APIãƒãƒ¼ã‚¸ãƒ§ãƒ³
    API_VERSION: str = "v1"
    
    # Google Cloudèªè¨¼è¨­å®š
    # GOOGLE_APPLICATION_CREDENTIALSã¯é€šå¸¸ç’°å¢ƒå¤‰æ•°ã§è¨­å®šã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä¸è¦
    # gcloud auth application-default login ã§ã‚‚å¯
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    è¨­å®šã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ï¼‰
    """
    return Settings() 
```

============================================================

ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†
============================================================

ğŸ“„ FILE: app/prompts/__init__.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 114 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:07:57
å­˜åœ¨: âœ…

CONTENT:
```
"""
ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

ğŸ“„ FILE: app/prompts/prompt_loader.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 4,237 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
"""
ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ç®¡ç†ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        åˆæœŸåŒ–
        
        Args:
            prompts_dir: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
                        Noneã®å ´åˆã¯ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ç”¨
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        
        Args:
            filename: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å
            
        Returns:
            ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å†…å®¹
            
        Raises:
            FileNotFoundError: ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
            IOError: ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """ãƒ•ã‚§ãƒ¼ã‚º1ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        ãƒ•ã‚§ãƒ¼ã‚º1ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
        
        Args:
            optional_text: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """ãƒ•ã‚§ãƒ¼ã‚º2ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        usda_candidates: str, 
        initial_ai_output: Optional[str] = None
    ) -> str:
        """
        ãƒ•ã‚§ãƒ¼ã‚º2ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
        
        Args:
            usda_candidates: USDAå€™è£œæƒ…å ±
            initial_ai_output: ãƒ•ã‚§ãƒ¼ã‚º1ã®AIå‡ºåŠ›
            
        Returns:
            ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        if initial_ai_output:
            initial_ai_output_section = f"Initial AI analysis results:\n{initial_ai_output}\n\n"
        else:
            initial_ai_output_section = ""
        
        return template.format(
            initial_ai_output_section=initial_ai_output_section,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†èª­ã¿è¾¼ã¿ã‚’ä¿ƒã™"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
============================================================

ğŸ“„ FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 974 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
You are an experienced culinary analyst. Your task is to analyze meal images and provide a detailed breakdown of dishes and their ingredients in JSON format.

IMPORTANT: You MUST provide ALL responses in English only. This includes dish names, ingredient names, types, and any other text fields.

Please note the following:
1. Carefully observe the image including the plate and make detailed estimates based on surrounding context.
2. Identify all dishes present in the image, determine their types, the quantity of each dish on the plate, and the ingredients contained with their respective amounts.
3. There may be multiple dishes in a single image, so provide information about each dish and its ingredients separately.
4. Your output will be used for nutritional calculations, so ensure your estimates are as accurate as possible.
5. Strictly follow the provided JSON schema in your response.
6. ALL text must be in English (dish names, ingredient names, types, etc.). 
```

============================================================

ğŸ“„ FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 86 bytes
æœ€çµ‚æ›´æ–°: 2025-06-01 16:12:20
å­˜åœ¨: âœ…

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

ğŸ“„ FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 4,338 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
You are an expert food item identifier, data matcher, and nutritional analysis strategist. Your task is to refine an initial meal analysis by:
1.  Determining the best `calculation_strategy` ("dish_level" or "ingredient_level") for each identified dish/food item.
2.  Matching the dish/food item (if "dish_level") OR its constituent ingredients (if "ingredient_level") to the most appropriate USDA FoodData Central (FDC) entries based on provided candidate information.
3.  Providing the official USDA `usda_source_description` for all matched FDC IDs.

IMPORTANT:
1.  You MUST provide ALL responses in English only.
2.  Your primary goal is to output the `calculation_strategy` for each dish, and then the relevant `fdc_id`(s) and `usda_source_description`(s) according to that strategy.
3.  You DO NOT need to calculate or return any nutritional values (calories, protein, etc.). This will be handled by a separate system.
4.  The `weight_g` for each ingredient is already determined in a previous phase and should NOT be modified or output by you.
5.  Strictly follow the provided JSON schema for your response (see REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA).

Your tasks for EACH dish/food item identified in the initial analysis:

TASK 1: Determine `calculation_strategy`.
   - If the dish/food item is a single, simple item (e.g., "Apple", "Banana", "Chicken Breast Fillet") AND a good, specific FDC ID candidate exists for it:
     Choose `calculation_strategy: "dish_level"`.
   - If the dish is a complex, mixed dish (e.g., "Homemade Vegetable Stir-fry", "Mixed Salad with various toppings", "Beef Stew"):
     Choose `calculation_strategy: "ingredient_level"`. You will then need to identify FDC IDs for its constituent ingredients.
   - If the dish is a somewhat standardized prepared dish (e.g., "Pepperoni Pizza", "Cheeseburger") AND a representative FDC ID candidate exists for the *entire dish*:
     Choose `calculation_strategy: "dish_level"`.
   - If a standardized dish does NOT have a good representative FDC ID for the entire dish, OR if breaking it down into its main ingredients would be more accurate:
     Choose `calculation_strategy: "ingredient_level"`.
   - Provide a brief rationale for your choice of strategy if it's not obvious (though this rationale is not part of the JSON output).

TASK 2: Output FDC ID(s) and Description(s) based on the chosen `calculation_strategy`.

   IF `calculation_strategy` is "dish_level":
     a. From the USDA candidates for the *dish/food item itself*, select the single most appropriate FDC ID.
     b. Set this as the `fdc_id` for the dish in your JSON output.
     c. Set the corresponding `usda_source_description` for the dish.
     d. The `ingredients` array for this dish in your JSON output should still list the ingredients identified in Phase 1 (or refined by you if necessary for clarity), but these ingredients will NOT have their own `fdc_id` or `usda_source_description` set by you in this "dish_level" scenario (set them to `null` or omit). Their primary purpose here is descriptive.

   IF `calculation_strategy` is "ingredient_level":
     a. Set the `fdc_id` and `usda_source_description` for the *dish itself* to `null` in your JSON output.
     b. For EACH `ingredient` within that dish (from the initial analysis, possibly refined by you):
        i. From the USDA candidates provided for *that specific ingredient*, select the single most appropriate FDC ID.
        ii. Set this as the `fdc_id` for that ingredient in your JSON output.
        iii. Set the corresponding `usda_source_description` for that ingredient.
        iv. If no suitable FDC ID is found for an ingredient, set its `fdc_id` and `usda_source_description` to `null`.

General Guidelines for FDC ID Selection (for dish or ingredient):
- Consider typical uses of ingredients and the most plausible match to the image context (if discernible) and initial `ingredient_name`.
- Prioritize FDC ID candidates in this order if relevant and good matches exist: 'Foundation Foods', 'SR Legacy', 'FNDDS' (Survey), then 'Branded Foods'.
- You may slightly refine `dish_name` or `ingredient_name` if the USDA description offers a more precise or common English term for the same food item, ensuring it still accurately represents the food.

Output the final analysis in the specified JSON format. 
```

============================================================

ğŸ“„ FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 689 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:30:58
å­˜åœ¨: âœ…

CONTENT:
```
{initial_ai_output_section}
Above is the initial AI analysis of the meal.

USDA food database candidate information for the items in the initial analysis and potentially for the overall dishes:
{usda_candidates}

Based on all this information (initial analysis, USDA candidates, and implicitly the image context from the initial analysis), please refine the analysis. For each dish/food item:
1. Determine its `calculation_strategy` ('dish_level' or 'ingredient_level').
2. Provide the `fdc_id` and `usda_source_description` according to that strategy, as detailed in the system instructions.
Remember to follow the JSON schema strictly. Do not calculate or return any nutritional values. 
```

============================================================

ğŸ“ ãƒ†ã‚¹ãƒˆãƒ»å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«
============================================================

ğŸ“„ FILE: test_complete_analysis.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 6,035 bytes
æœ€çµ‚æ›´æ–°: 2025-06-05 10:49:36
å­˜åœ¨: âœ…

CONTENT:
```
import requests
import json
import asyncio
from pathlib import Path

# APIè¨­å®š
BASE_URL = "http://localhost:8000/api/v1"

# ãƒ†ã‚¹ãƒˆç”»åƒã®ãƒ‘ã‚¹
image_path = "test_images/food3.jpg"

def test_complete_analysis():
    """å®Œå…¨åˆ†æã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ†ã‚¹ãƒˆ"""
    
    print("=== Complete Meal Analysis Test ===")
    print(f"Using image: {image_path}")
    
    try:
        # å®Œå…¨åˆ†æã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã—
        with open(image_path, "rb") as f:
            files = {"image": ("food3.jpg", f, "image/jpeg")}
            data = {"save_results": True}  # çµæœã‚’ä¿å­˜
            
            print("Starting complete analysis pipeline...")
            response = requests.post(f"{BASE_URL}/meal-analyses/complete", files=files, data=data)
        
        print(f"Status Code: {response.status_code}")
        
        if response.status_code == 200:
            result = response.json()
            print("âœ… Complete analysis successful!")
            
            # åˆ†æID
            analysis_id = result.get("analysis_id")
            print(f"Analysis ID: {analysis_id}")
            
            # å‡¦ç†ã‚µãƒãƒªãƒ¼
            summary = result.get("processing_summary", {})
            print(f"\nğŸ“Š Processing Summary:")
            print(f"- Total dishes: {summary.get('total_dishes')}")
            print(f"- Total ingredients: {summary.get('total_ingredients')}")
            print(f"- USDA match rate: {summary.get('usda_match_rate')}")
            print(f"- Total calories: {summary.get('total_calories')} kcal")
            print(f"- Pipeline status: {summary.get('pipeline_status')}")
            
            # ä¿å­˜å…ˆ
            saved_to = result.get("saved_to")
            if saved_to:
                print(f"- Results saved to: {saved_to}")
            
            # æœ€çµ‚æ „é¤Šä¾¡çµæœ
            final_nutrition = result.get("final_nutrition_result", {})
            total_nutrients = final_nutrition.get("total_meal_nutrients", {})
            
            print(f"\nğŸ½ Final Meal Nutrition:")
            print(f"- Calories: {total_nutrients.get('calories_kcal', 0):.2f} kcal")
            print(f"- Protein: {total_nutrients.get('protein_g', 0):.2f} g")
            print(f"- Carbohydrates: {total_nutrients.get('carbohydrates_g', 0):.2f} g")
            print(f"- Fat: {total_nutrients.get('fat_g', 0):.2f} g")
            
            # å„ãƒ•ã‚§ãƒ¼ã‚ºã®çµæœæ•°
            phase1_dishes = len(result.get("phase1_result", {}).get("dishes", []))
            phase2_dishes = len(result.get("phase2_result", {}).get("dishes", []))
            final_dishes = len(final_nutrition.get("dishes", []))
            
            print(f"\nğŸ“ˆ Pipeline Progress:")
            print(f"- Phase 1 dishes: {phase1_dishes}")
            print(f"- Phase 2 dishes: {phase2_dishes}")
            print(f"- Final dishes: {final_dishes}")
            print(f"- USDA matches: {result.get('usda_matches_count', 0)}")
            
            return True, analysis_id
            
        else:
            print("âŒ Complete analysis failed!")
            print(f"Error: {response.text}")
            return False, None
            
    except Exception as e:
        print(f"âŒ Error during complete analysis: {e}")
        return False, None

def test_list_results():
    """ä¿å­˜ã•ã‚ŒãŸçµæœã®ä¸€è¦§ã‚’å–å¾—"""
    
    print("\n=== List Saved Results ===")
    
    try:
        response = requests.get(f"{BASE_URL}/meal-analyses/results")
        
        if response.status_code == 200:
            results = response.json()
            total = results.get("total_results", 0)
            print(f"ğŸ“ Total saved results: {total}")
            
            if total > 0:
                print("\nRecent results:")
                for i, result in enumerate(results.get("results", [])[:5]):  # æœ€æ–°5ä»¶
                    print(f"{i+1}. {result.get('filename')}")
                    print(f"   ID: {result.get('analysis_id')}")
                    print(f"   Time: {result.get('timestamp')}")
                    summary = result.get('summary', {})
                    print(f"   Calories: {summary.get('total_calories', 0)} kcal")
                    print()
            
        else:
            print(f"âŒ Failed to list results: {response.status_code}")
            
    except Exception as e:
        print(f"âŒ Error listing results: {e}")

def test_get_specific_result(analysis_id):
    """ç‰¹å®šã®åˆ†æçµæœã‚’å–å¾—"""
    
    if not analysis_id:
        return
        
    print(f"\n=== Get Specific Result: {analysis_id} ===")
    
    try:
        response = requests.get(f"{BASE_URL}/meal-analyses/results/{analysis_id}")
        
        if response.status_code == 200:
            result = response.json()
            print(f"âœ… Retrieved result for analysis ID: {analysis_id}")
            
            # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
            metadata = result.get("metadata", {})
            print(f"Timestamp: {metadata.get('timestamp')}")
            print(f"Pipeline: {metadata.get('processing_pipeline')}")
            
            # å‡¦ç†ã‚µãƒãƒªãƒ¼
            summary = result.get("processing_summary", {})
            print(f"Status: {summary.get('pipeline_status')}")
            print(f"Total calories: {summary.get('total_calories')} kcal")
            
        else:
            print(f"âŒ Failed to get result: {response.status_code}")
            
    except Exception as e:
        print(f"âŒ Error getting specific result: {e}")

if __name__ == "__main__":
    print("Testing Complete Meal Analysis Pipeline")
    print("=" * 50)
    
    # å®Œå…¨åˆ†æã®ãƒ†ã‚¹ãƒˆ
    success, analysis_id = test_complete_analysis()
    
    if success:
        # çµæœä¸€è¦§ã®ãƒ†ã‚¹ãƒˆ
        test_list_results()
        
        # ç‰¹å®šçµæœå–å¾—ã®ãƒ†ã‚¹ãƒˆ
        test_get_specific_result(analysis_id)
        
        print("\nğŸ‰ All tests completed!")
    else:
        print("\nğŸ’¥ Complete analysis test failed!") 
```

============================================================

ğŸ¯ COMPLETE ANALYSIS SUMMARY
----------------------------------------
ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: 13
å­˜åœ¨ãƒ•ã‚¡ã‚¤ãƒ«æ•°: 13
åˆ†æå®Œäº†æ™‚åˆ»: 2025-06-05 11:19:19

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€/api/v1/meal-analyses/complete ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
å®Ÿè¡Œæ™‚ã«é–¢ã‚ã‚‹å®Œå…¨åˆ†æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å…¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®
å®Œå…¨ãªå†…å®¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

ğŸ”¥ COMPLETE ANALYSIS FEATURES:
- Phase 1: Gemini AI image analysis
- USDA Query: Database ingredient matching  
- Phase 2: Strategy determination & refinement
- Nutrition Calculation: Weight-based macro computation
- Result Management: Automatic save/retrieve functionality
