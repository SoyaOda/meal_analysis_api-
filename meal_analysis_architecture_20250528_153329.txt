================================================================================
MEAL ANALYSIS API - „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÊßãÈÄ†„Å®„Éï„Ç°„Ç§„É´ÂàÜÊûê
================================================================================
ÁîüÊàêÊó•ÊôÇ: 2025-05-28 15:33:29
ÂàÜÊûêÂØæË±°: test_english_phase2.py ÂÆüË°åÊôÇ„Å´Âëº„Å≥Âá∫„Åï„Çå„ÇãÂÖ®„Éï„Ç°„Ç§„É´
================================================================================

üìä ARCHITECTURE OVERVIEW
----------------------------------------

üîÑ EXECUTION FLOW (2-Phase Approach):
Phase 1: ÁîªÂÉè ‚Üí Gemini AI ‚Üí ÊñôÁêÜ„ÉªÈ£üÊùêË≠òÂà• (Ëã±Ë™ûÂêç)
Phase 2: Phase1ÁµêÊûú + ÁîªÂÉè ‚Üí USDAÊ§úÁ¥¢ ‚Üí GeminiÂÜçÂàÜÊûê ‚Üí Ê†ÑÈ§äÊàêÂàÜÁ≤æÁ∑ªÂåñ

üèóÔ∏è LAYER STRUCTURE:
‚îú‚îÄ‚îÄ APIÂ±§ (FastAPI)
‚îÇ   ‚îú‚îÄ‚îÄ meal_analyses.py (Phase 1 endpoint)
‚îÇ   ‚îî‚îÄ‚îÄ meal_analyses_refine.py (Phase 2 endpoint)
‚îú‚îÄ‚îÄ „Çµ„Éº„Éì„ÇπÂ±§
‚îÇ   ‚îú‚îÄ‚îÄ gemini_service.py (Vertex AI GeminiÈÄ£Êê∫)
‚îÇ   ‚îî‚îÄ‚îÄ usda_service.py (USDA FoodData Central APIÈÄ£Êê∫)
‚îú‚îÄ‚îÄ „Éá„Éº„Çø„É¢„Éá„É´Â±§
‚îÇ   ‚îî‚îÄ‚îÄ meal.py (Pydantic schemas)
‚îú‚îÄ‚îÄ „Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜÂ±§
‚îÇ   ‚îú‚îÄ‚îÄ prompt_loader.py (Template management)
‚îÇ   ‚îî‚îÄ‚îÄ prompt templates (*.txt)
‚îî‚îÄ‚îÄ Ë®≠ÂÆöÂ±§
    ‚îî‚îÄ‚îÄ config.py (Environment configuration)

üîß TECHNICAL FEATURES:
- ÈùûÂêåÊúüÂá¶ÁêÜ (async/await)
- ÊßãÈÄ†ÂåñJSONÂá∫Âäõ (Gemini response_schema)
- USDAÊ†ÑÈ§ä„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫
- „Ç≠„É£„ÉÉ„Ç∑„É•Ê©üËÉΩ
- ÂåÖÊã¨ÁöÑ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

================================================================================

üìÅ „É°„Ç§„É≥„ÉÜ„Çπ„Éà„Éï„Ç°„Ç§„É´
============================================================

üìÑ FILE: test_english_phase2.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 2808 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 11:54:35
Â≠òÂú®: ‚úÖ

CONTENT:
```
import requests
import json
import asyncio
import httpx

# APIË®≠ÂÆö
BASE_URL = "http://localhost:8000/api/v1"

# „ÉÜ„Çπ„ÉàÁîªÂÉè„ÅÆ„Éë„ÇπÔºàËã±Ë™û„ÅÆÈ£üÊùêÂêç„ÇíÂê´„ÇÄÁîªÂÉè„Çí‰ΩøÁî®Ôºâ
image_path = "test_images/food3.jpg"

async def run_phase1_and_phase2():
    """„Éï„Çß„Éº„Ç∫1‚Üí„Éï„Çß„Éº„Ç∫2„ÅÆÊµÅ„Çå„Çí„ÉÜ„Çπ„Éà"""
    
    print("=== Phase 1: Initial Analysis ===")
    
    # „Éï„Çß„Éº„Ç∫1: ÁîªÂÉèÂàÜÊûê
    with open(image_path, "rb") as f:
        files = {"image": ("food3.jpg", f, "image/jpeg")}
        response = requests.post(f"{BASE_URL}/meal-analyses", files=files)
    
    if response.status_code != 200:
        print(f"Phase 1 failed: {response.status_code}")
        print(response.text)
        return
    
    phase1_result = response.json()
    print("Phase 1 successful!")
    print(json.dumps(phase1_result, indent=2))
    
    # È£üÊùêÂêç„ÇíË°®Á§∫ÔºàËã±Ë™û„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÅØ„ÅöÔºâ
    print("\nDetected ingredients:")
    for dish in phase1_result.get("dishes", []):
        print(f"  Dish: {dish['dish_name']}")
        for ingredient in dish.get("ingredients", []):
            print(f"    - {ingredient['ingredient_name']}: {ingredient['weight_g']}g")
    
    print("\n=== Phase 2: USDA Refinement ===")
    
    # „Éï„Çß„Éº„Ç∫2: USDAÁ≤æÁ∑ªÂåñ
    with open(image_path, "rb") as f:
        files = {
            "image": ("food3.jpg", f, "image/jpeg"),
            "initial_analysis_data": (None, json.dumps(phase1_result), "application/json")
        }
        response = requests.post(f"{BASE_URL}/meal-analyses/refine", files=files)
    
    print(f"Phase 2 status: {response.status_code}")
    
    if response.status_code == 200:
        phase2_result = response.json()
        print("Phase 2 successful!")
        print(json.dumps(phase2_result, indent=2))
        
        # USDA FDC ID„ÇíË°®Á§∫
        print("\nUSDA matches:")
        for dish in phase2_result.get("dishes", []):
            print(f"  Dish: {dish['dish_name']}")
            for ingredient in dish.get("ingredients", []):
                if ingredient.get("fdc_id"):
                    print(f"    - {ingredient['ingredient_name']}: FDC ID {ingredient['fdc_id']} ({ingredient.get('usda_source_description', 'N/A')})")
                else:
                    print(f"    - {ingredient['ingredient_name']}: No USDA match")
                    
                # Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÇíË°®Á§∫
                nutrients = ingredient.get("key_nutrients_per_100g", {})
                if nutrients:
                    print(f"      Nutrients per 100g: {nutrients}")
    else:
        print("Phase 2 failed!")
        print(response.text)

if __name__ == "__main__":
    print("Testing Meal Analysis API (English version)")
    print(f"Using image: {image_path}")
    asyncio.run(run_phase1_and_phase2()) 
```

============================================================

üìÅ API „Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÂ±§
============================================================

üìÑ FILE: app/main.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 3140 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 11:39:45
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine
from .core.config import get_settings

# „É≠„ÇÆ„É≥„Ç∞„ÅÆË®≠ÂÆö
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Ë®≠ÂÆö„ÅÆÂèñÂæó
settings = get_settings()

# FastAPI„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰ΩúÊàê
app = FastAPI(
    title="È£ü‰∫ãÂàÜÊûêAPI (Meal Analysis API)",
    description="È£ü‰∫ã„ÅÆÁîªÂÉè„Å®„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàÜÊûê„Åó„ÄÅÊñôÁêÜ„Å®ÊùêÊñô„ÇíÁâπÂÆö„Åô„ÇãAPI„ÄÇUSDA„Éá„Éº„Çø„Éô„Éº„Çπ„Å®„ÅÆÈÄ£Êê∫„Å´„Çà„ÇäÊ†ÑÈ§ä‰æ°Ë®àÁÆó„ÅÆÁ≤æÂ∫¶„ÇíÂêë‰∏ä„ÄÇ",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS„Éü„Éâ„É´„Ç¶„Çß„Ç¢„ÅÆË®≠ÂÆöÔºàÈñãÁô∫Áí∞Â¢ÉÁî®Ôºâ
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Êú¨Áï™Áí∞Â¢É„Åß„ÅØÈÅ©Âàá„Å´Âà∂Èôê„Åô„Çã
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# „É´„Éº„Éà„Éë„Çπ„ÅÆ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
@app.get("/")
async def root():
    """API„ÅÆ„É´„Éº„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà"""
    return {
        "message": "È£ü‰∫ãÂàÜÊûêAPI (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
@app.get("/health")
async def health_check():
    """API„ÅÆ„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 API„É´„Éº„Çø„Éº„ÅÆÁôªÈå≤
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API „Éï„Çß„Éº„Ç∫2„É´„Éº„Çø„Éº„ÅÆÁôªÈå≤Ôºà/refine„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºâ
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# „Çπ„Çø„Éº„Éà„Ç¢„ÉÉ„Éó„Ç§„Éô„É≥„Éà
@app.on_event("startup")
async def startup_event():
    """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ëµ∑ÂãïÊôÇ„ÅÆÂá¶ÁêÜ"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# „Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥„Ç§„Éô„É≥„Éà
@app.on_event("shutdown")
async def shutdown_event():
    """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÁµÇ‰∫ÜÊôÇ„ÅÆÂá¶ÁêÜ"""
    logger.info("Meal Analysis API shutting down...")

# „Ç∞„É≠„Éº„Éê„É´„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "ÂÜÖÈÉ®„Çµ„Éº„Éê„Éº„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
            }
        }
    ) 
```

============================================================

üìÑ FILE: app/api/v1/endpoints/meal_analyses.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 5275 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-27 21:46:45
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, Optional
import logging

from ....services.gemini_service import GeminiMealAnalyzer
from ..schemas.meal import MealAnalysisResponse, ErrorResponse
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
_gemini_analyzer = None


async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç∑„É≥„Ç∞„É´„Éà„É≥Ôºâ
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/",
    response_model=MealAnalysisResponse,
    summary="Analyze meal image",
    description="Upload a meal image to identify dishes, types, quantities, and ingredients using AI analysis."
)
async def analyze_meal(
    image: Annotated[UploadFile, File(description="Meal image file to analyze.")],
    settings: Annotated[Settings, Depends(get_settings)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)],
    optional_text: Annotated[Optional[str], Form(description="Optional additional information about the meal.")] = None
):
    """
    Analyze uploaded meal image and return structured dish information.
    
    Args:
        image: Uploaded image file
        optional_text: Optional user context (not used in current implementation)
        
    Returns:
        MealAnalysisResponse: Structured analysis including dishes and ingredients
    """
    # Validate image file
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "INVALID_IMAGE_FORMAT",
                    "message": "Invalid image file format. Please upload an image (e.g., JPEG, PNG)."
                }
            }
        )
    
    # „Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„ÇãÁîªÂÉèÂΩ¢Âºè„ÅÆÁ¢∫Ë™ç
    supported_formats = ["image/jpeg", "image/png", "image/webp", "image/heic", "image/heif"]
    if image.content_type not in supported_formats:
        logger.warning(f"Unsupported image format: {image.content_type}")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "UNSUPPORTED_IMAGE_FORMAT",
                    "message": f"„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÁîªÂÉèÂΩ¢Âºè„Åß„Åô„ÄÇ„Çµ„Éù„Éº„ÉàÂΩ¢Âºè: {', '.join(supported_formats)}"
                }
            }
        )
    
    # ÁîªÂÉè„Çµ„Ç§„Ç∫„ÅÆÂà∂ÈôêÔºà‰æã: 10MBÔºâ
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    image_bytes = await image.read()
    
    if len(image_bytes) > MAX_FILE_SIZE:
        logger.warning(f"Image file too large: {len(image_bytes)} bytes")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "FILE_TOO_LARGE",
                    "message": f"ÁîªÂÉè„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„Åô„Åé„Åæ„Åô„ÄÇÊúÄÂ§ß„Çµ„Ç§„Ç∫: {MAX_FILE_SIZE // (1024 * 1024)}MB"
                }
            }
        )
    
    if len(image_bytes) == 0:
        logger.warning("Empty image file uploaded")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "EMPTY_FILE",
                    "message": "Á©∫„ÅÆÁîªÂÉè„Éï„Ç°„Ç§„É´„Åß„Åô„ÄÇ"
                }
            }
        )
    
    try:
        logger.info(f"Starting meal analysis for image: {image.filename}, size: {len(image_bytes)} bytes")
        
        # Gemini„Çµ„Éº„Éì„Çπ„Çí‰ΩøÁî®„Åó„Å¶ÁîªÂÉè„ÇíÂàÜÊûê
        analysis_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            optional_text=optional_text
        )
        
        logger.info(f"Meal analysis completed successfully for image: {image.filename}")
        
        # Pydantic„É¢„Éá„É´„Åß„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
        response = MealAnalysisResponse(**analysis_result)
        return response
        
    except RuntimeError as e:
        # Gemini„Çµ„Éº„Éì„Çπ„Åã„Çâ„ÅÆÂÖ∑‰ΩìÁöÑ„Å™„Ç®„É©„Éº
        logger.error(f"Error during meal analysis: {e}")
        raise HTTPException(
            status_code=500,
            detail={
                "error": {
                    "code": "ANALYSIS_ERROR",
                    "message": f"Failed to analyze meal image: {str(e)}"
                }
            }
        )
    except Exception as e:
        # „Åù„ÅÆ‰ªñ„ÅÆ‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº
        logger.error(f"Unexpected error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                }
            }
        ) 
```

============================================================

üìÑ FILE: app/api/v1/endpoints/meal_analyses_refine.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 11018 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 11:39:45
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, List, Optional, Dict
import json
import logging

# Pydantic„É¢„Éá„É´
from ..schemas.meal import (
    InitialAnalysisData,
    MealAnalysisRefinementResponse,
    USDASearchResultItem,
    USDANutrient,
    RefinedIngredient,
    RefinedDish
)

# „Çµ„Éº„Éì„Çπ
from ....services.usda_service import USDAService, get_usda_service, USDASearchResultItem as USDAServiceItem
from ....services.gemini_service import GeminiMealAnalyzer
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
_gemini_analyzer = None

async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç∑„É≥„Ç∞„É´„Éà„É≥Ôºâ
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/refine",
    response_model=MealAnalysisRefinementResponse,
    summary="Refine Meal Analysis with USDA Data",
    description="Refine meal analysis results using USDA FoodData Central database and Gemini AI for more accurate nutritional information."
)
async def refine_meal_analysis(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    initial_analysis_data: Annotated[str, Form(description="JSON response string from Phase 1 API.")],
    usda_service: Annotated[USDAService, Depends(get_usda_service)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)]
):
    """
    Meal analysis refinement endpoint
    
    1. Receive image and Phase 1 analysis results
    2. Search USDA database for each ingredient
    3. Re-analyze with Gemini using USDA candidates
    4. Return refined results
    """
    # 1. Image validation
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Invalid image file format.")
    
    try:
        image_bytes = await image.read()
        # File size check (e.g., 10MB)
        if len(image_bytes) > 10 * 1024 * 1024:
            raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
    except Exception as e:
        logger.error(f"Error reading image file: {e}")
        raise HTTPException(status_code=400, detail="Failed to read image file.")
    
    # 2. Parse initial_analysis_data
    try:
        initial_analysis_dict = json.loads(initial_analysis_data)
        initial_analysis = InitialAnalysisData(**initial_analysis_dict)
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="initial_analysis_data is not valid JSON format.")
    except Exception as e:  # Pydantic validation error
        logger.error(f"Validation error for initial_analysis_data: {e}")
        raise HTTPException(status_code=422, detail=f"initial_analysis_data format error: {str(e)}")
    
    # 3. USDA candidate information collection and prompt text generation
    usda_candidates_prompt_segments = []
    # Dictionary to store USDA search results for later key_nutrients_per_100g assignment (key_nutrients_per_100g will be added later)
    all_usda_search_results_map: Dict[int, USDAServiceItem] = {}
    
    # Data type priority
    preferred_data_types = ["Foundation", "SR Legacy", "Branded"]
    
    for dish in initial_analysis.dishes:
        for ingredient in dish.ingredients:
            search_query = ingredient.ingredient_name
            logger.info(f"Searching USDA for ingredient: {search_query}")
            
            try:
                # Execute USDA search
                usda_results: List[USDAServiceItem] = await usda_service.search_foods(
                    query=search_query,
                    data_types=preferred_data_types,
                    page_size=settings.USDA_SEARCH_CANDIDATES_LIMIT
                )
                
                if usda_results:
                    segment = f"USDA candidates for ingredient '{ingredient.ingredient_name}':\n"
                    for i, item in enumerate(usda_results):
                        all_usda_search_results_map[item.fdc_id] = item  # Save for later reference
                        
                        # Format nutrient information for prompt
                        nutrients_str_parts = []
                        for nutr in item.food_nutrients:
                            if nutr.name and nutr.amount is not None and nutr.unit_name:
                                # Convert nutrient name to a more readable format
                                nutrient_display_name = _get_nutrient_display_name(nutr.name, nutr.nutrient_number)
                                nutrients_str_parts.append(f"{nutrient_display_name}: {nutr.amount}{nutr.unit_name}")
                        
                        nutrients_str = ", ".join(nutrients_str_parts) if nutrients_str_parts else "No nutrient information"
                        
                        segment += (
                            f"{i+1}. FDC ID: {item.fdc_id}, Name: {item.description} ({item.data_type or 'N/A'}), "
                            f"Nutrients (per 100g): {nutrients_str}"
                        )
                        if item.brand_owner:
                            segment += f", Brand: {item.brand_owner}"
                        if item.ingredients_text:  # Branded Foods ingredient information
                            segment += f", Ingredients: {item.ingredients_text[:100]}..."  # If too long, omit
                        segment += "\n"
                    
                    usda_candidates_prompt_segments.append(segment)
                else:
                    logger.warning(f"No USDA results found for ingredient: {search_query}")
                    usda_candidates_prompt_segments.append(f"No USDA candidates found for ingredient '{ingredient.ingredient_name}'.\n")
                    
            except RuntimeError as e:  # USDA service error
                logger.error(f"USDA search error for ingredient '{search_query}': {e}")
                # Even if some USDA searches fail, let Gemini decide
                usda_candidates_prompt_segments.append(f"Error searching USDA candidates for ingredient '{ingredient.ingredient_name}': {str(e)}\n")
            except Exception as e:
                logger.error(f"Unexpected error during USDA search for '{search_query}': {e}")
                usda_candidates_prompt_segments.append(f"Unexpected error searching USDA candidates for ingredient '{ingredient.ingredient_name}': {str(e)}\n")
    
    usda_candidates_prompt_text = "\n---\n".join(usda_candidates_prompt_segments) if usda_candidates_prompt_segments else "No USDA candidate information available."
    
    # 4. Call Gemini service (phase 2 method)
    try:
        logger.info("Calling Gemini for phase 2 analysis")
        refined_gemini_output_dict = await gemini_service.analyze_image_with_usda_context(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            usda_candidates_text=usda_candidates_prompt_text,
            initial_ai_output_text=initial_analysis_data  # Pass Phase 1 output as is
        )
        
        # 5. Parse Gemini output and optionally add key_nutrients_per_100g
        # Parse with Pydantic model to verify it's in the correct schema format
        refined_analysis_response = MealAnalysisRefinementResponse(**refined_gemini_output_dict)
        
        # Add key_nutrients_per_100g in backend
        for dish_resp in refined_analysis_response.dishes:
            for ing_resp in dish_resp.ingredients:
                if ing_resp.fdc_id and ing_resp.fdc_id in all_usda_search_results_map:
                    usda_item = all_usda_search_results_map[ing_resp.fdc_id]
                    key_nutrients = {}
                    
                    # Extract necessary items from USDASearchResultItemPydantic.food_nutrients
                    for nutr in usda_item.food_nutrients:
                        if nutr.name and nutr.amount is not None:
                            # Determine key name based on nutrient number
                            if nutr.nutrient_number == "208":  # Energy
                                key_nutrients["calories_kcal"] = nutr.amount
                            elif nutr.nutrient_number == "203":  # Protein
                                key_nutrients["protein_g"] = nutr.amount
                            elif nutr.nutrient_number == "204":  # Total lipid (fat)
                                key_nutrients["fat_g"] = nutr.amount
                            elif nutr.nutrient_number == "205":  # Carbohydrate
                                key_nutrients["carbohydrate_g"] = nutr.amount
                            elif nutr.nutrient_number == "291":  # Fiber
                                key_nutrients["fiber_g"] = nutr.amount
                            elif nutr.nutrient_number == "269":  # Total sugars
                                key_nutrients["sugars_g"] = nutr.amount
                            elif nutr.nutrient_number == "307":  # Sodium
                                key_nutrients["sodium_mg"] = nutr.amount
                    
                    ing_resp.key_nutrients_per_100g = key_nutrients if key_nutrients else None
        
        logger.info(f"Phase 2 analysis completed successfully. Refined {len(refined_analysis_response.dishes)} dishes.")
        return refined_analysis_response
        
    except RuntimeError as e:  # Gemini service or USDA service error
        logger.error(f"External service error: {e}")
        raise HTTPException(status_code=503, detail=f"External service integration error: {str(e)}")
    except ValueError as e:  # JSON parsing error
        logger.error(f"Processing error: {e}")
        raise HTTPException(status_code=500, detail=f"Processing error: {str(e)}")
    except Exception as e:  # Unexpected other error
        logger.error(f"Unexpected error in refine_meal_analysis: {e}")
        raise HTTPException(status_code=500, detail=f"Unexpected internal error occurred: {str(e)}")


def _get_nutrient_display_name(name: str, nutrient_number: Optional[str]) -> str:
    """
    Display nutrient names in a standardized format
    """
    nutrient_mapping = {
        "208": "Energy",
        "203": "Protein", 
        "204": "Fat",
        "205": "Carbohydrate",
        "291": "Dietary Fiber",
        "269": "Sugars",
        "307": "Sodium"
    }
    
    if nutrient_number and nutrient_number in nutrient_mapping:
        return nutrient_mapping[nutrient_number]
    return name 
```

============================================================

üìÅ „Çµ„Éº„Éì„ÇπÂ±§
============================================================

üìÑ FILE: app/services/gemini_service.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 9130 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:40:13
Â≠òÂú®: ‚úÖ

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

from ..api.v1.schemas.meal import REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Gemini„ÅÆÊßãÈÄ†ÂåñÂá∫Âäõ„ÅÆ„Åü„ÇÅ„ÅÆJSON„Çπ„Ç≠„Éº„Éû„ÇíÂÆöÁæ©
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ÁîªÂÉè„Åã„ÇâÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà„ÄÇ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞„ÄÇ"},
                    "type": {"type": "string", "description": "ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„Éó, „Éá„Ç∂„Éº„ÉàÔºâ„ÄÇ"},
                    "quantity_on_plate": {"type": "string", "description": "Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞Ôºà‰æã: '1ÊùØ', '2Âàá„Çå', 'Á¥Ñ200g'Ôºâ„ÄÇ"},
                    "ingredients": {
                        "type": "array",
                        "description": "„Åì„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„Çã„Å®Êé®ÂÆö„Åï„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà„ÄÇ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ÊùêÊñô„ÅÆÂêçÁß∞„ÄÇ"},
                                "weight_g": {"type": "number", "description": "„Åù„ÅÆÊùêÊñô„ÅÆÊé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ„ÄÇ"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AIÁµåÁî±„ÅßGemini„Çí‰ΩøÁî®„Åó„Å¶È£ü‰∫ãÁîªÂÉè„ÇíÂàÜÊûê„Åô„Çã„ÇØ„É©„Çπ"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-1.5-flash"):
        """
        ÂàùÊúüÂåñ
        
        Args:
            project_id: GCP„Éó„É≠„Ç∏„Çß„ÇØ„ÉàID
            location: Vertex AI„ÅÆ„É≠„Ç±„Éº„Ç∑„Éß„É≥Ôºà‰æã: us-central1Ôºâ
            model_name: ‰ΩøÁî®„Åô„Çã„É¢„Éá„É´Âêç
        """
        # Vertex AI„ÅÆÂàùÊúüÂåñ
        vertexai.init(project=project_id, location=location)
        
        # „É¢„Éá„É´„ÅÆÂàùÊúüÂåñ
        self.model = GenerativeModel(model_name=model_name)
        
        # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„ÅÆÂàùÊúüÂåñ
        self.prompt_loader = PromptLoader()
        
        # generation_config„Çí‰ΩúÊàê
        self.generation_config = GenerationConfig(
            temperature=0.2,
            top_p=0.9,
            top_k=20,
            max_output_tokens=8192,
            response_mime_type="application/json",
            response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
        )
        
        # „Çª„Éº„Éï„ÉÜ„Ç£Ë®≠ÂÆö
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }
    
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        ÁîªÂÉè„Å®„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàÜÊûê„Åó„Å¶È£ü‰∫ãÊÉÖÂ†±„ÇíÊäΩÂá∫
        
        Args:
            image_bytes: ÁîªÂÉè„ÅÆ„Éê„Ç§„Éà„Éá„Éº„Çø
            image_mime_type: ÁîªÂÉè„ÅÆMIME„Çø„Ç§„Éó
            optional_text: „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË™¨Êòé
            
        Returns:
            ÂàÜÊûêÁµêÊûú„ÅÆËæûÊõ∏
            
        Raises:
            RuntimeError: Gemini API„Ç®„É©„ÉºÊôÇ
        """
        try:
            # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„Åã„Çâ„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # ÂÆåÂÖ®„Å™„Éó„É≠„É≥„Éó„Éà„ÇíÊßãÁØâ
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # „Ç≥„É≥„ÉÜ„É≥„ÉÑ„É™„Çπ„Éà„Çí‰ΩúÊàê
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # Gemini API„ÇíÂëº„Å≥Âá∫„ÅóÔºàÈùûÂêåÊúü„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®Ôºâ
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            # „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSON„É¨„Çπ„Éù„É≥„Çπ„Çí„Éë„Éº„Çπ
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        USDA„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩøÁî®„Åó„Å¶ÁîªÂÉè„ÇíÂÜçÂàÜÊûêÔºà„Éï„Çß„Éº„Ç∫2Ôºâ
        
        Args:
            image_bytes: ÁîªÂÉè„ÅÆ„Éê„Ç§„Éà„Éá„Éº„Çø
            image_mime_type: ÁîªÂÉè„ÅÆMIME„Çø„Ç§„Éó
            usda_candidates_text: USDAÂÄôË£úÊÉÖÂ†±„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÉÜ„Ç≠„Çπ„Éà
            initial_ai_output_text: „Éï„Çß„Éº„Ç∫1„ÅÆAIÂá∫ÂäõÔºàJSONÊñáÂ≠óÂàóÔºâ
            
        Returns:
            Á≤æÁ∑ªÂåñ„Åï„Çå„ÅüÂàÜÊûêÁµêÊûú„ÅÆËæûÊõ∏
            
        Raises:
            RuntimeError: Gemini API„Ç®„É©„ÉºÊôÇ
        """
        try:
            # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„Åã„Çâ„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                usda_candidates=usda_candidates_text,
                initial_ai_output=initial_ai_output_text
            )
            
            # ÂÆåÂÖ®„Å™„Éó„É≠„É≥„Éó„Éà„ÇíÊßãÁØâ
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # „Ç≥„É≥„ÉÜ„É≥„ÉÑ„É™„Çπ„Éà„Çí‰ΩúÊàê
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # „Éï„Çß„Éº„Ç∫2Áî®„ÅÆGeneration Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini API„ÇíÂëº„Å≥Âá∫„Åó
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")
            
            # JSON„É¨„Çπ„Éù„É≥„Çπ„Çí„Éë„Éº„Çπ
            result = json.loads(response.text)
            
            logger.info(f"Gemini phase 2 analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in phase 2: {e}. Raw response: {getattr(response, 'text', 'N/A')}")
            raise RuntimeError(f"Error processing response from Gemini (Phase 2): {e}") from e
        except Exception as e:
            import traceback
            logger.error(f"Vertex AI/Gemini API error in phase 2: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e 
```

============================================================

üìÑ FILE: app/services/usda_service.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 9746 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 11:39:45
Â≠òÂú®: ‚úÖ

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings

logger = logging.getLogger(__name__)


class USDANutrient:
    """USDAÊ†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÇíË°®„Åô„ÇØ„É©„Çπ"""
    def __init__(self, name: str, amount: float, unit_name: str, 
                 nutrient_id: Optional[int] = None, 
                 nutrient_number: Optional[str] = None):
        self.name = name
        self.amount = amount
        self.unit_name = unit_name
        self.nutrient_id = nutrient_id
        self.nutrient_number = nutrient_number


class USDASearchResultItem:
    """USDAÊ§úÁ¥¢ÁµêÊûú„Ç¢„Ç§„ÉÜ„É†„ÇíË°®„Åô„ÇØ„É©„Çπ"""
    def __init__(self, fdc_id: int, description: str, 
                 data_type: Optional[str] = None,
                 brand_owner: Optional[str] = None,
                 ingredients_text: Optional[str] = None,
                 food_nutrients: List[USDANutrient] = None,
                 score: Optional[float] = None):
        self.fdc_id = fdc_id
        self.description = description
        self.data_type = data_type
        self.brand_owner = brand_owner
        self.ingredients_text = ingredients_text
        self.food_nutrients = food_nutrients or []
        self.score = score


class USDAService:
    """USDA FoodData Central API„Å®„ÅÆÈÄö‰ø°„ÇíÁÆ°ÁêÜ„Åô„Çã„Çµ„Éº„Éì„Çπ„ÇØ„É©„Çπ"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClient„ÅÆË®≠ÂÆö
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central API„ÅßÈ£üÂìÅ„ÇíÊ§úÁ¥¢
        
        Args:
            query: Ê§úÁ¥¢„ÇØ„Ç®„É™ÊñáÂ≠óÂàó
            data_types: „Éá„Éº„Çø„Çø„Ç§„Éó„ÅÆ„É™„Çπ„ÉàÔºà‰æã: ["Foundation", "SR Legacy", "Branded"]Ôºâ
            page_size: 1„Éö„Éº„Ç∏„ÅÇ„Åü„Çä„ÅÆÁµêÊûúÊï∞
            page_number: ÂèñÂæó„Åô„Çã„Éö„Éº„Ç∏Áï™Âè∑
            sort_by: „ÇΩ„Éº„Éà„Ç≠„Éº
            sort_order: „ÇΩ„Éº„ÉàÈ†ÜÔºà"asc" „Åæ„Åü„ÅØ "desc"Ôºâ
            
        Returns:
            USDASearchResultItem„ÅÆ„É™„Çπ„Éà
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # „Éá„Éº„Çø„Çø„Ç§„Éó„Çí„Ç´„É≥„ÉûÂå∫Âàá„ÇäÊñáÂ≠óÂàó„Å®„Åó„Å¶Ê∏°„Åô
            params["dataType"] = ",".join(data_types)
        
        try:
            logger.info(f"USDA API search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # „É¨„Éº„Éà„É™„Éü„ÉÉ„ÉàÊÉÖÂ†±„ÅÆ„É≠„Ç∞
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrients„Éá„Éº„Çø„Åã„Çâ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÇíÊäΩÂá∫
        
        Args:
            food_nutrients: USDA API„Åã„ÇâËøî„Åï„Çå„ÇãÊ†ÑÈ§äÁ¥†„Éá„Éº„Çø„ÅÆ„É™„Çπ„Éà
            
        Returns:
            USDANutrient„ÅÆ„É™„Çπ„Éà
        """
        nutrients_extracted = []
        
        for nutrient_entry in food_nutrients:
            # Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÅÆÊäΩÂá∫Ôºà„Éá„Éº„ÇøÊßãÈÄ†„ÅØ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å´„Çà„Å£„Å¶Áï∞„Å™„ÇãÔºâ
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # Branded Foods„ÅÆabridged„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å∏„ÅÆÂØæÂøú
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                nutrient_id = nutrient_entry.get("nutrientId")
                name = nutrient_entry.get("nutrientName")
                number = nutrient_entry.get("nutrientNumber")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")  # Branded abridged„Åß„ÅØ"value"
            else:
                # SR Legacy, Foundation, „Åæ„Åü„ÅØ full Branded
                nutrient_id = nutrient_detail.get("id")
                name = nutrient_detail.get("name")
                number = nutrient_detail.get("number")
                unit_name = nutrient_detail.get("unitName")
            
            # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÅÆ„Åø„ÇíÊäΩÂá∫
            if number and str(number) in self.key_nutrient_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        
        return nutrients_extracted
    
    async def get_food_details(
        self, 
        fdc_id: int, 
        format: str = "full",
        target_nutrient_numbers: Optional[List[str]] = None
    ) -> Optional[USDASearchResultItem]:
        """
        ÁâπÂÆö„ÅÆFDC ID„ÅÆÈ£üÂìÅË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæó
        
        Args:
            fdc_id: È£üÂìÅ„ÅÆFDC ID
            format: „É¨„Çπ„Éù„É≥„ÇπÂΩ¢ÂºèÔºà"abridged" „Åæ„Åü„ÅØ "full"Ôºâ
            target_nutrient_numbers: ÂèñÂæó„Åô„ÇãÊ†ÑÈ§äÁ¥†Áï™Âè∑„ÅÆ„É™„Çπ„Éà
            
        Returns:
            USDASearchResultItem „Åæ„Åü„ÅØ None
        """
        params = {
            "api_key": self.api_key,
            "format": format
        }
        
        if target_nutrient_numbers:
            params["nutrients"] = ",".join(target_nutrient_numbers)
        
        try:
            logger.info(f"USDA API get food details: fdc_id={fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            response.raise_for_status()
            
            food_data = response.json()
            nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted
            )
            
        except Exception as e:
            logger.error(f"Error fetching food details for FDC ID {fdc_id}: {str(e)}")
            return None
    
    async def close_client(self):
        """HTTP„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çí„ÇØ„É≠„Éº„Ç∫"""
        await self.client.aclose()


# FastAPI„ÅÆ‰æùÂ≠òÊÄßÊ≥®ÂÖ•Áî®Èñ¢Êï∞
async def get_usda_service():
    """
    USDAService„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊèê‰æõ„Åô„Çã‰æùÂ≠òÊÄßÊ≥®ÂÖ•Èñ¢Êï∞
    """
    service = USDAService()
    try:
        yield service
    finally:
        await service.close_client() 
```

============================================================

üìÅ „Éá„Éº„Çø„É¢„Éá„É´Â±§
============================================================

üìÑ FILE: app/api/v1/schemas/meal.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 6562 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 11:39:45
Â≠òÂú®: ‚úÖ

CONTENT:
```
from typing import List, Optional, Dict
from pydantic import BaseModel, Field


class Ingredient(BaseModel):
    """ÊùêÊñôÊÉÖÂ†±„É¢„Éá„É´"""
    ingredient_name: str = Field(..., description="ÊùêÊñô„ÅÆÂêçÁß∞")
    weight_g: float = Field(..., description="Êé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ", gt=0)


class Dish(BaseModel):
    """ÊñôÁêÜÊÉÖÂ†±„É¢„Éá„É´"""
    dish_name: str = Field(..., description="ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞")
    type: str = Field(..., description="ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„ÉóÔºâ")
    quantity_on_plate: str = Field(..., description="Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞")
    ingredients: List[Ingredient] = Field(..., description="„Åù„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà")


class MealAnalysisResponse(BaseModel):
    """È£ü‰∫ãÂàÜÊûê„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    dishes: List[Dish] = Field(..., description="ÁîªÂÉè„Åã„ÇâÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà")


class ErrorResponse(BaseModel):
    """„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    error: dict = Field(..., description="„Ç®„É©„ÉºÊÉÖÂ†±")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": {
                    "code": "INVALID_INPUT", 
                    "message": "Êèê‰æõ„Åï„Çå„ÅüÁîªÂÉè„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ"
                }
            }
        }


# ========== „Éï„Çß„Éº„Ç∫2Áî®„É¢„Éá„É´ ==========

# „Éï„Çß„Éº„Ç∫1„ÅÆÂá∫Âäõ„ÇíË°®„Åô„É¢„Éá„É´Ôºàinitial_analysis_dataÁî®Ôºâ
InitialAnalysisIngredient = Ingredient  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†
InitialAnalysisDish = Dish  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†
InitialAnalysisData = MealAnalysisResponse  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†


# USDAÊ§úÁ¥¢ÁµêÊûú„ÇíË°®„Åô„É¢„Éá„É´
class USDANutrient(BaseModel):
    """USDAÊ†ÑÈ§äÁ¥†ÊÉÖÂ†±„É¢„Éá„É´"""
    name: str = Field(..., description="Ê†ÑÈ§äÁ¥†Âêç")
    amount: float = Field(..., description="100g„Åæ„Åü„ÅØ100ml„ÅÇ„Åü„Çä„ÅÆÈáè")
    unit_name: str = Field(..., description="Âçò‰ΩçÂêç (‰æã: g, mg, kcal)")
    nutrient_id: Optional[int] = Field(None, description="USDAÊ†ÑÈ§äÁ¥†ID")
    nutrient_number: Optional[str] = Field(None, description="USDAÊ†ÑÈ§äÁ¥†Áï™Âè∑")


class USDASearchResultItem(BaseModel):
    """USDAÊ§úÁ¥¢ÁµêÊûú„Ç¢„Ç§„ÉÜ„É†„É¢„Éá„É´"""
    fdc_id: int = Field(..., description="USDA FoodData Central ID")
    description: str = Field(..., description="È£üÂìÅ„ÅÆÂÖ¨ÂºèÂêçÁß∞")
    data_type: Optional[str] = Field(None, description="USDA„Éá„Éº„Çø„Çø„Ç§„Éó (‰æã: SR Legacy, Branded)")
    brand_owner: Optional[str] = Field(None, description="„Éñ„É©„É≥„ÉâÊâÄÊúâËÄÖ (Branded Foods„ÅÆÂ†¥Âêà)")
    ingredients_text: Optional[str] = Field(None, description="ÂéüÊùêÊñô„É™„Çπ„ÉàÊñáÂ≠óÂàó (Branded Foods„ÅÆÂ†¥Âêà)")
    food_nutrients: List[USDANutrient] = Field(default_factory=list, description="‰∏ªË¶Å„Å™Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÅÆ„É™„Çπ„Éà")
    score: Optional[float] = Field(None, description="Ê§úÁ¥¢ÁµêÊûú„ÅÆÈñ¢ÈÄ£Â∫¶„Çπ„Ç≥„Ç¢")


# „Éï„Çß„Éº„Ç∫2„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Çπ„Ç≠„Éº„Éû
class RefinedIngredient(BaseModel):
    """USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊùêÊñô„É¢„Éá„É´"""
    ingredient_name: str = Field(..., description="ÊùêÊñô„ÅÆÂêçÁß∞ÔºàÁ≤æÁ∑ªÂåñÂæåÔºâ")
    weight_g: float = Field(..., description="ÊùêÊñô„ÅÆÊé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ", gt=0)
    fdc_id: Optional[int] = Field(None, description="ÂØæÂøú„Åô„ÇãUSDAÈ£üÂìÅ„ÅÆFDC ID")
    usda_source_description: Optional[str] = Field(None, description="ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆÂÖ¨ÂºèÂêçÁß∞")
    key_nutrients_per_100g: Optional[Dict[str, float]] = Field(
        None, 
        description="ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Ôºà100g„ÅÇ„Åü„ÇäÔºâ",
        json_schema_extra={
            "example": {
                "calories_kcal": 165,
                "protein_g": 31.0,
                "fat_g": 3.6,
                "carbohydrate_g": 0.0
            }
        }
    )


class RefinedDish(BaseModel):
    """USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊñôÁêÜ„É¢„Éá„É´"""
    dish_name: str = Field(..., description="ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞ÔºàÁ≤æÁ∑ªÂåñÂæåÔºâ")
    type: str = Field(..., description="ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„ÉóÔºâ")
    quantity_on_plate: str = Field(..., description="Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞")
    ingredients: List[RefinedIngredient] = Field(..., description="Á≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊùêÊñô„ÅÆ„É™„Çπ„Éà")


class MealAnalysisRefinementResponse(BaseModel):
    """„Éï„Çß„Éº„Ç∫2È£ü‰∫ãÂàÜÊûêÁ≤æÁ∑ªÂåñ„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    dishes: List[RefinedDish] = Field(..., description="USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà")


# GeminiÂêë„Åë„ÅÆJSON„Çπ„Ç≠„Éº„ÉûÂÆöÁæ©
REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ÁîªÂÉè„Åã„ÇâÁâπÂÆö„ÉªÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà„ÄÇ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞„ÄÇ"},
                    "type": {"type": "string", "description": "ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèúÔºâ„ÄÇ"},
                    "quantity_on_plate": {"type": "string", "description": "Áöø„ÅÆ‰∏ä„ÅÆÈáè„ÄÇ"},
                    "ingredients": {
                        "type": "array",
                        "description": "„Åì„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„Çã„Å®Êé®ÂÆö„Åï„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„ÉàÔºàUSDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñÔºâ„ÄÇ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ÊùêÊñô„ÅÆÂêçÁß∞ÔºàUSDAÊÉÖÂ†±„Å´Âü∫„Å•„ÅçÁ≤æÁ∑ªÂåñ„Åï„Çå„ÇãÂèØËÉΩÊÄß„ÅÇ„ÇäÔºâ„ÄÇ"},
                                "weight_g": {"type": "number", "description": "„Åù„ÅÆÊùêÊñô„ÅÆÊé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ„ÄÇ"},
                                "fdc_id": {"type": "integer", "nullable": True, "description": "ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆFDC ID„ÄÇË©≤ÂΩì„Å™„Åó„ÅÆÂ†¥Âêà„ÅØnull„ÄÇ"},
                                "usda_source_description": {"type": "string", "nullable": True, "description": "ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆÂÖ¨ÂºèÂêçÁß∞„ÄÇ"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
} 
```

============================================================

üìÅ Ë®≠ÂÆöÁÆ°ÁêÜ
============================================================

üìÑ FILE: app/core/config.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 2180 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-27 21:20:37
Â≠òÂú®: ‚úÖ

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    APIË®≠ÂÆö„ÇØ„É©„Çπ
    Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË®≠ÂÆöÂÄ§„ÇíË™≠„ÅøËæº„ÇÄ
    """
    # Vertex AIË®≠ÂÆö
    GEMINI_PROJECT_ID: str  # GCP„Éó„É≠„Ç∏„Çß„ÇØ„ÉàIDÔºàÂøÖÈ†àÔºâ
    GEMINI_LOCATION: str = "us-central1"  # „Éá„Éï„Ç©„É´„Éà„ÅÆ„É≠„Ç±„Éº„Ç∑„Éß„É≥
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA APIË®≠ÂÆö
    USDA_API_KEY: str  # USDA FoodData Central API„Ç≠„ÉºÔºàÂøÖÈ†àÔºâ
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # API„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁßíÊï∞
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1Âõû„ÅÆÊ§úÁ¥¢„ÅßÂèñÂæó„Åô„ÇãÊúÄÂ§ßÂÄôË£úÊï∞
    # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Áï™Âè∑Ôºà„Ç´„É≥„ÉûÂå∫Âàá„ÇäÊñáÂ≠óÂàó„Å®„Åó„Å¶Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË™≠„ÅøËæº„ÇÄÔºâ
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Áï™Âè∑„ÅÆ„É™„Çπ„Éà„ÇíËøî„Åô"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # „Ç≠„É£„ÉÉ„Ç∑„É•Ë®≠ÂÆö
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redis„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅÆURL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDA„É¨„Çπ„Éù„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•ÊúâÂäπÊúüÈñìÔºà1ÊôÇÈñìÔºâ
    
    # APIË®≠ÂÆö
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # „Çµ„Éº„Éê„ÉºË®≠ÂÆö
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # API„Éê„Éº„Ç∏„Éß„É≥
    API_VERSION: str = "v1"
    
    # Google CloudË™çË®ºË®≠ÂÆö
    # GOOGLE_APPLICATION_CREDENTIALS„ÅØÈÄöÂ∏∏Áí∞Â¢ÉÂ§âÊï∞„ÅßË®≠ÂÆö„Åô„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ‰∏çË¶Å
    # gcloud auth application-default login „Åß„ÇÇÂèØ
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    Ë®≠ÂÆö„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„ÇãÔºâ
    """
    return Settings() 
```

============================================================

üìÅ „Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜ
============================================================

üìÑ FILE: app/prompts/__init__.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 114 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:39:32
Â≠òÂú®: ‚úÖ

CONTENT:
```
"""
„Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜ„É¢„Ç∏„É•„Éº„É´
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

üìÑ FILE: app/prompts/prompt_loader.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 4237 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:39:24
Â≠òÂú®: ‚úÖ

CONTENT:
```
"""
„Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„ÅßÁÆ°ÁêÜ„Åô„Çã„É¢„Ç∏„É•„Éº„É´
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """„Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„ÅßÁÆ°ÁêÜ„Åô„Çã„ÇØ„É©„Çπ"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        ÂàùÊúüÂåñ
        
        Args:
            prompts_dir: „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÅåÊ†ºÁ¥ç„Åï„Çå„Å¶„ÅÑ„Çã„Éá„Ç£„É¨„ÇØ„Éà„É™„Éë„Çπ
                        None„ÅÆÂ†¥Âêà„ÅØÁèæÂú®„ÅÆ„Éï„Ç°„Ç§„É´„Å®Âêå„Åò„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩøÁî®
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # „Éó„É≠„É≥„Éó„Éà„Çí„Ç≠„É£„ÉÉ„Ç∑„É•
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
        
        Args:
            filename: „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´Âêç
            
        Returns:
            „Éó„É≠„É≥„Éó„Éà„ÅÆÂÜÖÂÆπ
            
        Raises:
            FileNotFoundError: „Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
            IOError: „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """„Éï„Çß„Éº„Ç∫1„ÅÆ„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        „Éï„Çß„Éº„Ç∫1„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
        
        Args:
            optional_text: „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
            
        Returns:
            „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """„Éï„Çß„Éº„Ç∫2„ÅÆ„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        usda_candidates: str, 
        initial_ai_output: Optional[str] = None
    ) -> str:
        """
        „Éï„Çß„Éº„Ç∫2„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
        
        Args:
            usda_candidates: USDAÂÄôË£úÊÉÖÂ†±
            initial_ai_output: „Éï„Çß„Éº„Ç∫1„ÅÆAIÂá∫Âäõ
            
        Returns:
            „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        if initial_ai_output:
            initial_ai_output_section = f"Initial AI analysis results:\n{initial_ai_output}\n\n"
        else:
            initial_ai_output_section = ""
        
        return template.format(
            initial_ai_output_section=initial_ai_output_section,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """„Éó„É≠„É≥„Éó„Éà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢„Åó„Å¶ÂÜçË™≠„ÅøËæº„Åø„Çí‰øÉ„Åô"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

üìÅ „Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà
============================================================

üìÑ FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 974 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:41:53
Â≠òÂú®: ‚úÖ

CONTENT:
```
You are an experienced culinary analyst. Your task is to analyze meal images and provide a detailed breakdown of dishes and their ingredients in JSON format.

IMPORTANT: You MUST provide ALL responses in English only. This includes dish names, ingredient names, types, and any other text fields.

Please note the following:
1. Carefully observe the image including the plate and make detailed estimates based on surrounding context.
2. Identify all dishes present in the image, determine their types, the quantity of each dish on the plate, and the ingredients contained with their respective amounts.
3. There may be multiple dishes in a single image, so provide information about each dish and its ingredients separately.
4. Your output will be used for nutritional calculations, so ensure your estimates are as accurate as possible.
5. Strictly follow the provided JSON schema in your response.
6. ALL text must be in English (dish names, ingredient names, types, etc.). 
```

============================================================

üìÑ FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 86 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:41:52
Â≠òÂú®: ‚úÖ

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

üìÑ FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 1308 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:41:51
Â≠òÂú®: ‚úÖ

CONTENT:
```
You are an experienced nutritionist and food analysis expert. Comprehensively evaluate the provided meal image, initial AI analysis results, and candidate information from the USDA food database, then refine the initial AI analysis results.

IMPORTANT: You MUST provide ALL responses in English only. This includes dish names, ingredient names, types, and any other text fields.

Your tasks are as follows:
1. For each dish and ingredient included in the initial AI analysis results, select the most appropriate option from the presented USDA food candidates. When making your selection, consider the content of the image, typical uses of ingredients, and the plausibility of nutritional values.
2. Identify the FDC ID of the selected USDA food.
3. Output the final dish/ingredient names, their types, quantities on the plate, and each ingredient (corresponding to the selected USDA food) with its name, estimated weight (in grams), and FDC ID, strictly following the specified JSON schema.
4. If an ingredient from the initial AI analysis results doesn't have appropriate candidates in USDA, or differs significantly from the image, take this into consideration and make the most reasonable judgment.
5. Your output will form the basis for accurate nutritional calculations.
6. ALL text must be in English. 
```

============================================================

üìÑ FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 242 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-28 13:41:49
Â≠òÂú®: ‚úÖ

CONTENT:
```
{initial_ai_output_section}USDA food database candidate information for the above analysis results and image:
{usda_candidates}

Based on this information, generate the final analysis results in JSON format following the system instructions. 
```

============================================================

üéØ SUMMARY
----------------------------------------
Á∑è„Éï„Ç°„Ç§„É´Êï∞: 14
Â≠òÂú®„Éï„Ç°„Ç§„É´Êï∞: 14
ÂàÜÊûêÂÆå‰∫ÜÊôÇÂàª: 2025-05-28 15:33:29

„Åì„ÅÆ„Éï„Ç°„Ç§„É´„Å´„ÅØ„ÄÅtest_english_phase2.pyÂÆüË°åÊôÇ„Å´Èñ¢„Çè„ÇãÂÖ®„Å¶„ÅÆ
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„ÅÆÂÆåÂÖ®„Å™ÂÜÖÂÆπ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
