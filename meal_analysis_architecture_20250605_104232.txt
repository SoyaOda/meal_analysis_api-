================================================================================
MEAL ANALYSIS API - „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£ÊßãÈÄ†„Å®„Éï„Ç°„Ç§„É´ÂàÜÊûê
================================================================================
ÁîüÊàêÊó•ÊôÇ: 2025-06-05 10:42:32
ÂàÜÊûêÂØæË±°: test_english_phase2.py ÂÆüË°åÊôÇ„Å´Âëº„Å≥Âá∫„Åï„Çå„ÇãÂÖ®„Éï„Ç°„Ç§„É´
================================================================================

üìä ARCHITECTURE OVERVIEW
----------------------------------------

üîÑ EXECUTION FLOW (2-Phase Approach):
Phase 1: ÁîªÂÉè ‚Üí Gemini AI ‚Üí ÊñôÁêÜ„ÉªÈ£üÊùêË≠òÂà• (Ëã±Ë™ûÂêç)
Phase 2: Phase1ÁµêÊûú + ÁîªÂÉè ‚Üí USDAÊ§úÁ¥¢ ‚Üí GeminiÂÜçÂàÜÊûê ‚Üí Ê†ÑÈ§äÊàêÂàÜÁ≤æÁ∑ªÂåñ

üèóÔ∏è LAYER STRUCTURE:
‚îú‚îÄ‚îÄ APIÂ±§ (FastAPI)
‚îÇ   ‚îú‚îÄ‚îÄ meal_analyses.py (Phase 1 endpoint)
‚îÇ   ‚îî‚îÄ‚îÄ meal_analyses_refine.py (Phase 2 endpoint)
‚îú‚îÄ‚îÄ „Çµ„Éº„Éì„ÇπÂ±§
‚îÇ   ‚îú‚îÄ‚îÄ gemini_service.py (Vertex AI GeminiÈÄ£Êê∫)
‚îÇ   ‚îî‚îÄ‚îÄ usda_service.py (USDA FoodData Central APIÈÄ£Êê∫)
‚îú‚îÄ‚îÄ „Éá„Éº„Çø„É¢„Éá„É´Â±§
‚îÇ   ‚îî‚îÄ‚îÄ meal.py (Pydantic schemas)
‚îú‚îÄ‚îÄ „Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜÂ±§
‚îÇ   ‚îú‚îÄ‚îÄ prompt_loader.py (Template management)
‚îÇ   ‚îî‚îÄ‚îÄ prompt templates (*.txt)
‚îî‚îÄ‚îÄ Ë®≠ÂÆöÂ±§
    ‚îî‚îÄ‚îÄ config.py (Environment configuration)

üîß TECHNICAL FEATURES:
- ÈùûÂêåÊúüÂá¶ÁêÜ (async/await)
- ÊßãÈÄ†ÂåñJSONÂá∫Âäõ (Gemini response_schema)
- USDAÊ†ÑÈ§ä„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫
- „Ç≠„É£„ÉÉ„Ç∑„É•Ê©üËÉΩ
- ÂåÖÊã¨ÁöÑ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

================================================================================

üìÅ „É°„Ç§„É≥„ÉÜ„Çπ„Éà„Éï„Ç°„Ç§„É´
============================================================

üìÑ FILE: test_english_phase2.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 2808 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
import requests
import json
import asyncio
import httpx

# APIË®≠ÂÆö
BASE_URL = "http://localhost:8000/api/v1"

# „ÉÜ„Çπ„ÉàÁîªÂÉè„ÅÆ„Éë„ÇπÔºàËã±Ë™û„ÅÆÈ£üÊùêÂêç„ÇíÂê´„ÇÄÁîªÂÉè„Çí‰ΩøÁî®Ôºâ
image_path = "test_images/food3.jpg"

async def run_phase1_and_phase2():
    """„Éï„Çß„Éº„Ç∫1‚Üí„Éï„Çß„Éº„Ç∫2„ÅÆÊµÅ„Çå„Çí„ÉÜ„Çπ„Éà"""
    
    print("=== Phase 1: Initial Analysis ===")
    
    # „Éï„Çß„Éº„Ç∫1: ÁîªÂÉèÂàÜÊûê
    with open(image_path, "rb") as f:
        files = {"image": ("food3.jpg", f, "image/jpeg")}
        response = requests.post(f"{BASE_URL}/meal-analyses", files=files)
    
    if response.status_code != 200:
        print(f"Phase 1 failed: {response.status_code}")
        print(response.text)
        return
    
    phase1_result = response.json()
    print("Phase 1 successful!")
    print(json.dumps(phase1_result, indent=2))
    
    # È£üÊùêÂêç„ÇíË°®Á§∫ÔºàËã±Ë™û„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÅØ„ÅöÔºâ
    print("\nDetected ingredients:")
    for dish in phase1_result.get("dishes", []):
        print(f"  Dish: {dish['dish_name']}")
        for ingredient in dish.get("ingredients", []):
            print(f"    - {ingredient['ingredient_name']}: {ingredient['weight_g']}g")
    
    print("\n=== Phase 2: USDA Refinement ===")
    
    # „Éï„Çß„Éº„Ç∫2: USDAÁ≤æÁ∑ªÂåñ
    with open(image_path, "rb") as f:
        files = {
            "image": ("food3.jpg", f, "image/jpeg"),
            "initial_analysis_data": (None, json.dumps(phase1_result), "application/json")
        }
        response = requests.post(f"{BASE_URL}/meal-analyses/refine", files=files)
    
    print(f"Phase 2 status: {response.status_code}")
    
    if response.status_code == 200:
        phase2_result = response.json()
        print("Phase 2 successful!")
        print(json.dumps(phase2_result, indent=2))
        
        # USDA FDC ID„ÇíË°®Á§∫
        print("\nUSDA matches:")
        for dish in phase2_result.get("dishes", []):
            print(f"  Dish: {dish['dish_name']}")
            for ingredient in dish.get("ingredients", []):
                if ingredient.get("fdc_id"):
                    print(f"    - {ingredient['ingredient_name']}: FDC ID {ingredient['fdc_id']} ({ingredient.get('usda_source_description', 'N/A')})")
                else:
                    print(f"    - {ingredient['ingredient_name']}: No USDA match")
                    
                # Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÇíË°®Á§∫
                nutrients = ingredient.get("key_nutrients_per_100g", {})
                if nutrients:
                    print(f"      Nutrients per 100g: {nutrients}")
    else:
        print("Phase 2 failed!")
        print(response.text)

if __name__ == "__main__":
    print("Testing Meal Analysis API (English version)")
    print(f"Using image: {image_path}")
    asyncio.run(run_phase1_and_phase2()) 
```

============================================================

üìÅ API „Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÂ±§
============================================================

üìÑ FILE: app/main.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 3235 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-04 14:18:07
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine
from .core.config import get_settings

# „É≠„ÇÆ„É≥„Ç∞„ÅÆË®≠ÂÆö
logging.basicConfig(
    level=logging.DEBUG,  # ‰∏ÄÊôÇÁöÑ„Å´DEBUG„É¨„Éô„É´„Å´Â§âÊõ¥
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)

# Ë®≠ÂÆö„ÅÆÂèñÂæó
settings = get_settings()

# FastAPI„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰ΩúÊàê
app = FastAPI(
    title="È£ü‰∫ãÂàÜÊûêAPI (Meal Analysis API)",
    description="È£ü‰∫ã„ÅÆÁîªÂÉè„Å®„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàÜÊûê„Åó„ÄÅÊñôÁêÜ„Å®ÊùêÊñô„ÇíÁâπÂÆö„Åô„ÇãAPI„ÄÇUSDA„Éá„Éº„Çø„Éô„Éº„Çπ„Å®„ÅÆÈÄ£Êê∫„Å´„Çà„ÇäÊ†ÑÈ§ä‰æ°Ë®àÁÆó„ÅÆÁ≤æÂ∫¶„ÇíÂêë‰∏ä„ÄÇ",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS„Éü„Éâ„É´„Ç¶„Çß„Ç¢„ÅÆË®≠ÂÆöÔºàÈñãÁô∫Áí∞Â¢ÉÁî®Ôºâ
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Êú¨Áï™Áí∞Â¢É„Åß„ÅØÈÅ©Âàá„Å´Âà∂Èôê„Åô„Çã
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# „É´„Éº„Éà„Éë„Çπ„ÅÆ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
@app.get("/")
async def root():
    """API„ÅÆ„É´„Éº„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà"""
    return {
        "message": "È£ü‰∫ãÂàÜÊûêAPI (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
@app.get("/health")
async def health_check():
    """API„ÅÆ„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 API„É´„Éº„Çø„Éº„ÅÆÁôªÈå≤
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API „Éï„Çß„Éº„Ç∫2„É´„Éº„Çø„Éº„ÅÆÁôªÈå≤Ôºà/refine„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºâ
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# „Çπ„Çø„Éº„Éà„Ç¢„ÉÉ„Éó„Ç§„Éô„É≥„Éà
@app.on_event("startup")
async def startup_event():
    """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ëµ∑ÂãïÊôÇ„ÅÆÂá¶ÁêÜ"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# „Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥„Ç§„Éô„É≥„Éà
@app.on_event("shutdown")
async def shutdown_event():
    """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÁµÇ‰∫ÜÊôÇ„ÅÆÂá¶ÁêÜ"""
    logger.info("Meal Analysis API shutting down...")

# „Ç∞„É≠„Éº„Éê„É´„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅÆ„Éè„É≥„Éâ„É™„É≥„Ç∞"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "ÂÜÖÈÉ®„Çµ„Éº„Éê„Éº„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
            }
        }
    ) 
```

============================================================

üìÑ FILE: app/api/v1/endpoints/meal_analyses.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 5275 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, Optional
import logging

from ....services.gemini_service import GeminiMealAnalyzer
from ..schemas.meal import MealAnalysisResponse, ErrorResponse
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
_gemini_analyzer = None


async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç∑„É≥„Ç∞„É´„Éà„É≥Ôºâ
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/",
    response_model=MealAnalysisResponse,
    summary="Analyze meal image",
    description="Upload a meal image to identify dishes, types, quantities, and ingredients using AI analysis."
)
async def analyze_meal(
    image: Annotated[UploadFile, File(description="Meal image file to analyze.")],
    settings: Annotated[Settings, Depends(get_settings)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)],
    optional_text: Annotated[Optional[str], Form(description="Optional additional information about the meal.")] = None
):
    """
    Analyze uploaded meal image and return structured dish information.
    
    Args:
        image: Uploaded image file
        optional_text: Optional user context (not used in current implementation)
        
    Returns:
        MealAnalysisResponse: Structured analysis including dishes and ingredients
    """
    # Validate image file
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "INVALID_IMAGE_FORMAT",
                    "message": "Invalid image file format. Please upload an image (e.g., JPEG, PNG)."
                }
            }
        )
    
    # „Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„ÇãÁîªÂÉèÂΩ¢Âºè„ÅÆÁ¢∫Ë™ç
    supported_formats = ["image/jpeg", "image/png", "image/webp", "image/heic", "image/heif"]
    if image.content_type not in supported_formats:
        logger.warning(f"Unsupported image format: {image.content_type}")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "UNSUPPORTED_IMAGE_FORMAT",
                    "message": f"„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÁîªÂÉèÂΩ¢Âºè„Åß„Åô„ÄÇ„Çµ„Éù„Éº„ÉàÂΩ¢Âºè: {', '.join(supported_formats)}"
                }
            }
        )
    
    # ÁîªÂÉè„Çµ„Ç§„Ç∫„ÅÆÂà∂ÈôêÔºà‰æã: 10MBÔºâ
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    image_bytes = await image.read()
    
    if len(image_bytes) > MAX_FILE_SIZE:
        logger.warning(f"Image file too large: {len(image_bytes)} bytes")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "FILE_TOO_LARGE",
                    "message": f"ÁîªÂÉè„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„Åô„Åé„Åæ„Åô„ÄÇÊúÄÂ§ß„Çµ„Ç§„Ç∫: {MAX_FILE_SIZE // (1024 * 1024)}MB"
                }
            }
        )
    
    if len(image_bytes) == 0:
        logger.warning("Empty image file uploaded")
        raise HTTPException(
            status_code=400,
            detail={
                "error": {
                    "code": "EMPTY_FILE",
                    "message": "Á©∫„ÅÆÁîªÂÉè„Éï„Ç°„Ç§„É´„Åß„Åô„ÄÇ"
                }
            }
        )
    
    try:
        logger.info(f"Starting meal analysis for image: {image.filename}, size: {len(image_bytes)} bytes")
        
        # Gemini„Çµ„Éº„Éì„Çπ„Çí‰ΩøÁî®„Åó„Å¶ÁîªÂÉè„ÇíÂàÜÊûê
        analysis_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            optional_text=optional_text
        )
        
        logger.info(f"Meal analysis completed successfully for image: {image.filename}")
        
        # Pydantic„É¢„Éá„É´„Åß„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
        response = MealAnalysisResponse(**analysis_result)
        return response
        
    except RuntimeError as e:
        # Gemini„Çµ„Éº„Éì„Çπ„Åã„Çâ„ÅÆÂÖ∑‰ΩìÁöÑ„Å™„Ç®„É©„Éº
        logger.error(f"Error during meal analysis: {e}")
        raise HTTPException(
            status_code=500,
            detail={
                "error": {
                    "code": "ANALYSIS_ERROR",
                    "message": f"Failed to analyze meal image: {str(e)}"
                }
            }
        )
    except Exception as e:
        # „Åù„ÅÆ‰ªñ„ÅÆ‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº
        logger.error(f"Unexpected error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail={
                "error": {
                    "code": "INTERNAL_SERVER_ERROR",
                    "message": "‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                }
            }
        ) 
```

============================================================

üìÑ FILE: app/api/v1/endpoints/meal_analyses_refine.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 17639 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, List, Optional, Dict
import json
import logging

# Pydantic„É¢„Éá„É´
from ..schemas.meal import (
    InitialAnalysisData,
    MealAnalysisRefinementResponse,
    USDASearchResultItem,
    USDANutrient,
    RefinedIngredient,
    RefinedDish,
    CalculatedNutrients
)

# „Çµ„Éº„Éì„Çπ
from ....services.usda_service import USDAService, get_usda_service, USDASearchResultItem as USDAServiceItem
from ....services.gemini_service import GeminiMealAnalyzer
from ....services.nutrition_calculation_service import NutritionCalculationService
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
_gemini_analyzer = None

async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Gemini„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç∑„É≥„Ç∞„É´„Éà„É≥Ôºâ
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/refine",
    response_model=MealAnalysisRefinementResponse,
    summary="Refine Meal Analysis with USDA Data and Dynamic Nutrition Calculation",
    description="Refine meal analysis results using USDA FoodData Central database and Gemini AI with dynamic calculation strategy (dish_level or ingredient_level) for accurate nutritional information."
)
async def refine_meal_analysis(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    initial_analysis_data: Annotated[str, Form(description="JSON response string from Phase 1 API.")],
    usda_service: Annotated[USDAService, Depends(get_usda_service)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)]
):
    """
    Meal analysis refinement endpoint with dynamic nutrition calculation strategy
    
    Âá¶ÁêÜ„Éï„É≠„ÉºÔºà‰ªïÊßòÊõ∏Ê∫ñÊã†Ôºâ:
    1. ÁîªÂÉè„Å®„Éï„Çß„Éº„Ç∫1ÂàÜÊûê„Éá„Éº„Çø„ÇíÂèó‰ø°
    2. ÂêÑÈ£üÊùê„Å´„Å§„ÅÑ„Å¶USDA„Éá„Éº„Çø„Éô„Éº„Çπ„ÇíÊ§úÁ¥¢
    3. Gemini„Å´USDAÂÄôË£úÊÉÖÂ†±„ÇíÊèê‰æõ„Åó„Å¶calculation_strategy„ÇíÊ±∫ÂÆö
    4. calculation_strategy„Å´Âü∫„Å•„ÅÑ„Å¶Ê†ÑÈ§äË®àÁÆó„ÇíÂÆüË°å
    5. Á≤æÁ∑ªÂåñ„Åï„Çå„ÅüÁµêÊûú„ÇíËøî„Åô
    """
    warnings = []
    errors = []
    
    # 1. Image validation
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Invalid image file format.")
    
    try:
        image_bytes = await image.read()
        # File size check (e.g., 10MB)
        if len(image_bytes) > 10 * 1024 * 1024:
            raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
    except Exception as e:
        logger.error(f"Error reading image file: {e}")
        raise HTTPException(status_code=400, detail="Failed to read image file.")
    
    # 2. Parse initial_analysis_data
    try:
        initial_analysis_dict = json.loads(initial_analysis_data)
        initial_analysis = InitialAnalysisData(**initial_analysis_dict)
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="initial_analysis_data is not valid JSON format.")
    except Exception as e:  # Pydantic validation error
        logger.error(f"Validation error for initial_analysis_data: {e}")
        raise HTTPException(status_code=422, detail=f"initial_analysis_data format error: {str(e)}")
    
    # 3. USDA candidate information collection
    usda_candidates_prompt_segments = []
    all_usda_search_results_map: Dict[int, USDAServiceItem] = {}
    
    # Data type priority
    preferred_data_types = ["Foundation", "SR Legacy", "FNDDS", "Branded"]
    
    # Search for both individual ingredients and potential dish-level items
    all_search_terms = set()
    
    # Add ingredient names
    for dish in initial_analysis.dishes:
        # Add dish name for potential dish-level calculation
        all_search_terms.add(dish.dish_name)
        
        for ingredient in dish.ingredients:
            all_search_terms.add(ingredient.ingredient_name)
    
    # Execute USDA searches
    for search_term in all_search_terms:
        logger.info(f"Searching USDA for: {search_term}")
        
        try:
            logger.debug(f"Before USDA search call for '{search_term}', preferred_data_types: {preferred_data_types}")
            usda_results: List[USDAServiceItem] = await usda_service.search_foods(
                query=search_term,
                data_types=preferred_data_types,
                page_size=settings.USDA_SEARCH_CANDIDATES_LIMIT
            )
            logger.debug(f"After USDA search call for '{search_term}', got {len(usda_results)} results")
            
            if usda_results:
                segment = f"USDA candidates for '{search_term}':\n"
                for i, item in enumerate(usda_results):
                    all_usda_search_results_map[item.fdc_id] = item
                    
                    # Format nutrient information for prompt
                    nutrients_str_parts = []
                    for nutr in item.food_nutrients:
                        if nutr.name and nutr.amount is not None and nutr.unit_name:
                            nutrient_display_name = _get_nutrient_display_name(nutr.name, nutr.nutrient_number)
                            nutrients_str_parts.append(f"{nutrient_display_name}: {nutr.amount}{nutr.unit_name}")
                    
                    nutrients_str = ", ".join(nutrients_str_parts) if nutrients_str_parts else "No nutrient information"
                    
                    segment += (
                        f"{i+1}. FDC ID: {item.fdc_id}, Name: {item.description} ({item.data_type or 'N/A'}), "
                        f"Nutrients (per 100g): {nutrients_str}"
                    )
                    if item.brand_owner:
                        segment += f", Brand: {item.brand_owner}"
                    if item.ingredients_text:
                        segment += f", Ingredients: {item.ingredients_text[:100]}..."
                    segment += "\n"
                
                usda_candidates_prompt_segments.append(segment)
            else:
                logger.warning(f"No USDA results found for: {search_term}")
                usda_candidates_prompt_segments.append(f"No USDA candidates found for '{search_term}'.\n")
                
        except RuntimeError as e:
            error_msg = f"USDA search error for '{search_term}': {e}"
            logger.error(error_msg)
            errors.append(error_msg)
            usda_candidates_prompt_segments.append(f"Error searching USDA candidates for '{search_term}': {str(e)}\n")
        except Exception as e:
            error_msg = f"Unexpected error during USDA search for '{search_term}': {e}"
            logger.error(error_msg)
            errors.append(error_msg)
    
    usda_candidates_prompt_text = "\n---\n".join(usda_candidates_prompt_segments) if usda_candidates_prompt_segments else "No USDA candidate information available."
    
    # 4. Call Gemini service (phase 2) for strategy determination and FDC ID matching
    try:
        logger.info("Calling Gemini for phase 2 analysis with dynamic strategy determination")
        logger.debug(f"usda_candidates_prompt_text length: {len(usda_candidates_prompt_text)}")
        logger.debug(f"initial_analysis_data type: {type(initial_analysis_data)}, length: {len(initial_analysis_data)}")
        refined_gemini_output_dict = await gemini_service.analyze_image_with_usda_context(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            usda_candidates_text=usda_candidates_prompt_text,
            initial_ai_output_text=initial_analysis_data
        )
        
        logger.info(f"Gemini phase 2 completed. Processing {len(refined_gemini_output_dict.get('dishes', []))} dishes.")
        
    except RuntimeError as e:
        error_msg = f"Gemini service error: {e}"
        logger.error(error_msg)
        raise HTTPException(status_code=503, detail=f"External service integration error: {str(e)}")
    except Exception as e:
        error_msg = f"Unexpected error in Gemini phase 2: {e}"
        logger.error(error_msg)
        raise HTTPException(status_code=500, detail=f"Processing error: {str(e)}")
    
    # 5. Process Gemini output with dynamic calculation strategy (‰ªïÊßòÊõ∏Ê∫ñÊã†)
    refined_dishes = []
    nutrition_service = NutritionCalculationService()
    
    for i, dish_response in enumerate(refined_gemini_output_dict.get('dishes', [])):
        try:
            strategy = dish_response.get('calculation_strategy')
            dish_name = dish_response.get('dish_name', f'Dish {i+1}')
            
            logger.info(f"Processing dish '{dish_name}' with strategy '{strategy}'")
            
            dish_total_actual_nutrients = None
            refined_ingredients = []
            
            # Get corresponding initial analysis dish for weight information
            initial_dish = None
            if i < len(initial_analysis.dishes):
                initial_dish = initial_analysis.dishes[i]
            
            if strategy == "dish_level":
                # Dish-level calculation
                dish_fdc_id = dish_response.get('fdc_id')
                
                if dish_fdc_id and initial_dish:
                    # Calculate dish total weight from initial analysis ingredients
                    dish_weight_g = sum(ing.weight_g for ing in initial_dish.ingredients)
                    
                    # Get nutrition data for the dish
                    key_nutrients_100g = await usda_service.get_food_details_for_nutrition(dish_fdc_id)
                    
                    if key_nutrients_100g and dish_weight_g > 0:
                        dish_total_actual_nutrients = nutrition_service.calculate_actual_nutrients(
                            key_nutrients_100g, dish_weight_g
                        )
                        logger.info(f"Dish-level calculation completed for '{dish_name}': {dish_total_actual_nutrients}")
                    else:
                        warning_msg = f"Could not calculate dish-level nutrition for '{dish_name}' (FDC ID: {dish_fdc_id})"
                        logger.warning(warning_msg)
                        warnings.append(warning_msg)
                
                # Process ingredients (descriptive purpose, no nutrition calculation)
                for ing_data in dish_response.get('ingredients', []):
                    # Find corresponding initial ingredient for weight
                    initial_weight = 0.0
                    if initial_dish:
                        for initial_ing in initial_dish.ingredients:
                            if initial_ing.ingredient_name.lower() in ing_data.get('ingredient_name', '').lower() or \
                               ing_data.get('ingredient_name', '').lower() in initial_ing.ingredient_name.lower():
                                initial_weight = initial_ing.weight_g
                                break
                    
                    refined_ingredient = RefinedIngredient(
                        ingredient_name=ing_data.get('ingredient_name', ''),
                        weight_g=initial_weight,
                        fdc_id=None,  # Not used in dish_level strategy
                        usda_source_description=None,
                        key_nutrients_per_100g=None,
                        actual_nutrients=None  # Not calculated in dish_level
                    )
                    refined_ingredients.append(refined_ingredient)
            
            elif strategy == "ingredient_level":
                # Ingredient-level calculation
                ingredient_actual_nutrients_list = []
                
                for ing_data in dish_response.get('ingredients', []):
                    ing_fdc_id = ing_data.get('fdc_id')
                    ing_name = ing_data.get('ingredient_name', '')
                    
                    # Find corresponding initial ingredient for weight
                    initial_weight = 0.0
                    if initial_dish:
                        for initial_ing in initial_dish.ingredients:
                            if initial_ing.ingredient_name.lower() in ing_name.lower() or \
                               ing_name.lower() in initial_ing.ingredient_name.lower():
                                initial_weight = initial_ing.weight_g
                                break
                    
                    actual_ing_nutrients = None
                    key_nutrients_100g = None
                    
                    if ing_fdc_id and initial_weight > 0:
                        # Get nutrition data for the ingredient
                        key_nutrients_100g = await usda_service.get_food_details_for_nutrition(ing_fdc_id)
                        
                        if key_nutrients_100g:
                            actual_ing_nutrients = nutrition_service.calculate_actual_nutrients(
                                key_nutrients_100g, initial_weight
                            )
                            ingredient_actual_nutrients_list.append(actual_ing_nutrients)
                            logger.debug(f"Ingredient-level calculation for '{ing_name}': {actual_ing_nutrients}")
                        else:
                            warning_msg = f"Could not get nutrition data for ingredient '{ing_name}' (FDC ID: {ing_fdc_id})"
                            logger.warning(warning_msg)
                            warnings.append(warning_msg)
                    else:
                        warning_msg = f"Missing FDC ID or weight for ingredient '{ing_name}'"
                        logger.warning(warning_msg)
                        warnings.append(warning_msg)
                    
                    refined_ingredient = RefinedIngredient(
                        ingredient_name=ing_name,
                        weight_g=initial_weight,
                        fdc_id=ing_fdc_id,
                        usda_source_description=ing_data.get('usda_source_description'),
                        key_nutrients_per_100g=key_nutrients_100g,
                        actual_nutrients=actual_ing_nutrients
                    )
                    refined_ingredients.append(refined_ingredient)
                
                # Aggregate nutrients from ingredients
                if ingredient_actual_nutrients_list:
                    dish_total_actual_nutrients = nutrition_service.aggregate_nutrients_for_dish_from_ingredients(
                        refined_ingredients
                    )
                    logger.info(f"Ingredient-level aggregation completed for '{dish_name}': {dish_total_actual_nutrients}")
            
            else:
                error_msg = f"Unknown calculation_strategy '{strategy}' for dish '{dish_name}'"
                logger.error(error_msg)
                errors.append(error_msg)
            
            # Create refined dish
            refined_dish = RefinedDish(
                dish_name=dish_name,
                type=dish_response.get('type', 'Unknown'),
                quantity_on_plate=dish_response.get('quantity_on_plate', ''),
                calculation_strategy=strategy,
                fdc_id=dish_response.get('fdc_id') if strategy == "dish_level" else None,
                usda_source_description=dish_response.get('usda_source_description') if strategy == "dish_level" else None,
                key_nutrients_per_100g=key_nutrients_100g if strategy == "dish_level" and 'key_nutrients_100g' in locals() else None,
                ingredients=refined_ingredients,
                dish_total_actual_nutrients=dish_total_actual_nutrients
            )
            
            refined_dishes.append(refined_dish)
            
        except Exception as e:
            error_msg = f"Error processing dish {i+1}: {e}"
            logger.error(error_msg)
            errors.append(error_msg)
    
    # 6. Calculate total meal nutrients
    total_meal_nutrients = None
    if refined_dishes:
        total_meal_nutrients = nutrition_service.aggregate_nutrients_for_meal(refined_dishes)
        logger.info(f"Total meal nutrients calculated: {total_meal_nutrients}")
    
    # 7. Create final response
    response = MealAnalysisRefinementResponse(
        dishes=refined_dishes,
        total_meal_nutrients=total_meal_nutrients,
        warnings=warnings if warnings else None,
        errors=errors if errors else None
    )
    
    logger.info(f"Phase 2 analysis completed successfully. Processed {len(refined_dishes)} dishes with {len(warnings)} warnings and {len(errors)} errors.")
    return response


def _get_nutrient_display_name(name: str, nutrient_number: Optional[str]) -> str:
    """
    Display nutrient names in a standardized format
    """
    nutrient_mapping = {
        "208": "Energy",
        "203": "Protein", 
        "204": "Fat",
        "205": "Carbohydrate",
        "291": "Dietary Fiber",
        "269": "Sugars",
        "307": "Sodium"
    }
    
    if nutrient_number and nutrient_number in nutrient_mapping:
        return nutrient_mapping[nutrient_number]
    return name 
```

============================================================

üìÅ „Çµ„Éº„Éì„ÇπÂ±§
============================================================

üìÑ FILE: app/services/gemini_service.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 9130 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

from ..api.v1.schemas.meal import REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Gemini„ÅÆÊßãÈÄ†ÂåñÂá∫Âäõ„ÅÆ„Åü„ÇÅ„ÅÆJSON„Çπ„Ç≠„Éº„Éû„ÇíÂÆöÁæ©
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ÁîªÂÉè„Åã„ÇâÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà„ÄÇ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞„ÄÇ"},
                    "type": {"type": "string", "description": "ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„Éó, „Éá„Ç∂„Éº„ÉàÔºâ„ÄÇ"},
                    "quantity_on_plate": {"type": "string", "description": "Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞Ôºà‰æã: '1ÊùØ', '2Âàá„Çå', 'Á¥Ñ200g'Ôºâ„ÄÇ"},
                    "ingredients": {
                        "type": "array",
                        "description": "„Åì„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„Çã„Å®Êé®ÂÆö„Åï„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà„ÄÇ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ÊùêÊñô„ÅÆÂêçÁß∞„ÄÇ"},
                                "weight_g": {"type": "number", "description": "„Åù„ÅÆÊùêÊñô„ÅÆÊé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ„ÄÇ"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AIÁµåÁî±„ÅßGemini„Çí‰ΩøÁî®„Åó„Å¶È£ü‰∫ãÁîªÂÉè„ÇíÂàÜÊûê„Åô„Çã„ÇØ„É©„Çπ"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-1.5-flash"):
        """
        ÂàùÊúüÂåñ
        
        Args:
            project_id: GCP„Éó„É≠„Ç∏„Çß„ÇØ„ÉàID
            location: Vertex AI„ÅÆ„É≠„Ç±„Éº„Ç∑„Éß„É≥Ôºà‰æã: us-central1Ôºâ
            model_name: ‰ΩøÁî®„Åô„Çã„É¢„Éá„É´Âêç
        """
        # Vertex AI„ÅÆÂàùÊúüÂåñ
        vertexai.init(project=project_id, location=location)
        
        # „É¢„Éá„É´„ÅÆÂàùÊúüÂåñ
        self.model = GenerativeModel(model_name=model_name)
        
        # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„ÅÆÂàùÊúüÂåñ
        self.prompt_loader = PromptLoader()
        
        # generation_config„Çí‰ΩúÊàê
        self.generation_config = GenerationConfig(
            temperature=0.2,
            top_p=0.9,
            top_k=20,
            max_output_tokens=8192,
            response_mime_type="application/json",
            response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
        )
        
        # „Çª„Éº„Éï„ÉÜ„Ç£Ë®≠ÂÆö
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }
    
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        ÁîªÂÉè„Å®„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàÜÊûê„Åó„Å¶È£ü‰∫ãÊÉÖÂ†±„ÇíÊäΩÂá∫
        
        Args:
            image_bytes: ÁîªÂÉè„ÅÆ„Éê„Ç§„Éà„Éá„Éº„Çø
            image_mime_type: ÁîªÂÉè„ÅÆMIME„Çø„Ç§„Éó
            optional_text: „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË™¨Êòé
            
        Returns:
            ÂàÜÊûêÁµêÊûú„ÅÆËæûÊõ∏
            
        Raises:
            RuntimeError: Gemini API„Ç®„É©„ÉºÊôÇ
        """
        try:
            # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„Åã„Çâ„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # ÂÆåÂÖ®„Å™„Éó„É≠„É≥„Éó„Éà„ÇíÊßãÁØâ
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # „Ç≥„É≥„ÉÜ„É≥„ÉÑ„É™„Çπ„Éà„Çí‰ΩúÊàê
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # Gemini API„ÇíÂëº„Å≥Âá∫„ÅóÔºàÈùûÂêåÊúü„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®Ôºâ
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            # „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSON„É¨„Çπ„Éù„É≥„Çπ„Çí„Éë„Éº„Çπ
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        USDA„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩøÁî®„Åó„Å¶ÁîªÂÉè„ÇíÂÜçÂàÜÊûêÔºà„Éï„Çß„Éº„Ç∫2Ôºâ
        
        Args:
            image_bytes: ÁîªÂÉè„ÅÆ„Éê„Ç§„Éà„Éá„Éº„Çø
            image_mime_type: ÁîªÂÉè„ÅÆMIME„Çø„Ç§„Éó
            usda_candidates_text: USDAÂÄôË£úÊÉÖÂ†±„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÉÜ„Ç≠„Çπ„Éà
            initial_ai_output_text: „Éï„Çß„Éº„Ç∫1„ÅÆAIÂá∫ÂäõÔºàJSONÊñáÂ≠óÂàóÔºâ
            
        Returns:
            Á≤æÁ∑ªÂåñ„Åï„Çå„ÅüÂàÜÊûêÁµêÊûú„ÅÆËæûÊõ∏
            
        Raises:
            RuntimeError: Gemini API„Ç®„É©„ÉºÊôÇ
        """
        try:
            # „Éó„É≠„É≥„Éó„Éà„É≠„Éº„ÉÄ„Éº„Åã„Çâ„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                usda_candidates=usda_candidates_text,
                initial_ai_output=initial_ai_output_text
            )
            
            # ÂÆåÂÖ®„Å™„Éó„É≠„É≥„Éó„Éà„ÇíÊßãÁØâ
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # „Ç≥„É≥„ÉÜ„É≥„ÉÑ„É™„Çπ„Éà„Çí‰ΩúÊàê
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # „Éï„Çß„Éº„Ç∫2Áî®„ÅÆGeneration Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini API„ÇíÂëº„Å≥Âá∫„Åó
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")
            
            # JSON„É¨„Çπ„Éù„É≥„Çπ„Çí„Éë„Éº„Çπ
            result = json.loads(response.text)
            
            logger.info(f"Gemini phase 2 analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in phase 2: {e}. Raw response: {getattr(response, 'text', 'N/A')}")
            raise RuntimeError(f"Error processing response from Gemini (Phase 2): {e}") from e
        except Exception as e:
            import traceback
            logger.error(f"Vertex AI/Gemini API error in phase 2: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e 
```

============================================================

üìÑ FILE: app/services/usda_service.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 16154 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings

logger = logging.getLogger(__name__)


class USDANutrient:
    """USDAÊ†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÇíË°®„Åô„ÇØ„É©„Çπ"""
    def __init__(self, name: str, amount: float, unit_name: str, 
                 nutrient_id: Optional[int] = None, 
                 nutrient_number: Optional[str] = None):
        self.name = name
        self.amount = amount
        self.unit_name = unit_name
        self.nutrient_id = nutrient_id
        self.nutrient_number = nutrient_number


class USDASearchResultItem:
    """USDAÊ§úÁ¥¢ÁµêÊûú„Ç¢„Ç§„ÉÜ„É†„ÇíË°®„Åô„ÇØ„É©„Çπ"""
    def __init__(self, fdc_id: int, description: str, 
                 data_type: Optional[str] = None,
                 brand_owner: Optional[str] = None,
                 ingredients_text: Optional[str] = None,
                 food_nutrients: List[USDANutrient] = None,
                 score: Optional[float] = None):
        self.fdc_id = fdc_id
        self.description = description
        self.data_type = data_type
        self.brand_owner = brand_owner
        self.ingredients_text = ingredients_text
        self.food_nutrients = food_nutrients or []
        self.score = score


class USDAService:
    """USDA FoodData Central API„Å®„ÅÆÈÄö‰ø°„ÇíÁÆ°ÁêÜ„Åô„Çã„Çµ„Éº„Éì„Çπ„ÇØ„É©„Çπ"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClient„ÅÆË®≠ÂÆö
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central API„ÅßÈ£üÂìÅ„ÇíÊ§úÁ¥¢
        
        Args:
            query: Ê§úÁ¥¢„ÇØ„Ç®„É™ÊñáÂ≠óÂàó
            data_types: „Éá„Éº„Çø„Çø„Ç§„Éó„ÅÆ„É™„Çπ„ÉàÔºà‰æã: ["Foundation", "SR Legacy", "Branded"]Ôºâ
            page_size: 1„Éö„Éº„Ç∏„ÅÇ„Åü„Çä„ÅÆÁµêÊûúÊï∞
            page_number: ÂèñÂæó„Åô„Çã„Éö„Éº„Ç∏Áï™Âè∑
            sort_by: „ÇΩ„Éº„Éà„Ç≠„Éº
            sort_order: „ÇΩ„Éº„ÉàÈ†ÜÔºà"asc" „Åæ„Åü„ÅØ "desc"Ôºâ
            
        Returns:
            USDASearchResultItem„ÅÆ„É™„Çπ„Éà
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # „Éá„Éº„Çø„Çø„Ç§„Éó„Çí„Ç´„É≥„ÉûÂå∫Âàá„ÇäÊñáÂ≠óÂàó„Å®„Åó„Å¶Ê∏°„Åô
            params["dataType"] = ",".join(data_types)
        
        try:
            logger.info(f"USDA API search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # „É¨„Éº„Éà„É™„Éü„ÉÉ„ÉàÊÉÖÂ†±„ÅÆ„É≠„Ç∞
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrients„Éá„Éº„Çø„Åã„Çâ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÇíÊäΩÂá∫
        
        Args:
            food_nutrients: USDA API„Åã„ÇâËøî„Åï„Çå„ÇãÊ†ÑÈ§äÁ¥†„Éá„Éº„Çø„ÅÆ„É™„Çπ„Éà
            
        Returns:
            USDANutrient„ÅÆ„É™„Çπ„Éà
        """
        nutrients_extracted = []
        
        for nutrient_entry in food_nutrients:
            # Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÅÆÊäΩÂá∫Ôºà„Éá„Éº„ÇøÊßãÈÄ†„ÅØ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å´„Çà„Å£„Å¶Áï∞„Å™„ÇãÔºâ
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # Branded Foods„ÅÆabridged„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å∏„ÅÆÂØæÂøú
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                nutrient_id = nutrient_entry.get("nutrientId")
                name = nutrient_entry.get("nutrientName")
                number = nutrient_entry.get("nutrientNumber")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")  # Branded abridged„Åß„ÅØ"value"
            else:
                # SR Legacy, Foundation, „Åæ„Åü„ÅØ full Branded
                nutrient_id = nutrient_detail.get("id")
                name = nutrient_detail.get("name")
                number = nutrient_detail.get("number")
                unit_name = nutrient_detail.get("unitName")
            
            # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÅÆ„Åø„ÇíÊäΩÂá∫
            if number and str(number) in self.key_nutrient_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        
        return nutrients_extracted
    
    async def get_food_details(
        self, 
        fdc_id: int, 
        format: str = "full",
        target_nutrient_numbers: Optional[List[str]] = None
    ) -> Optional[USDASearchResultItem]:
        """
        ÁâπÂÆö„ÅÆFDC ID„ÅÆÈ£üÂìÅË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæó
        
        Args:
            fdc_id: È£üÂìÅ„ÅÆFDC ID
            format: „É¨„Çπ„Éù„É≥„ÇπÂΩ¢ÂºèÔºà"abridged" „Åæ„Åü„ÅØ "full"Ôºâ
            target_nutrient_numbers: ÂèñÂæó„Åô„ÇãÊ†ÑÈ§äÁ¥†Áï™Âè∑„ÅÆ„É™„Çπ„Éà
            
        Returns:
            USDASearchResultItem „Åæ„Åü„ÅØ None
        """
        params = {
            "api_key": self.api_key,
            "format": format
        }
        
        if target_nutrient_numbers:
            params["nutrients"] = ",".join(target_nutrient_numbers)
        
        try:
            logger.info(f"USDA API get food details: fdc_id={fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            response.raise_for_status()
            
            food_data = response.json()
            nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted
            )
            
        except Exception as e:
            logger.error(f"Error fetching food details for FDC ID {fdc_id}: {str(e)}")
            return None

    async def get_food_details_for_nutrition(self, fdc_id: int) -> Optional[Dict[str, float]]:
        """
        Ê†ÑÈ§äË®àÁÆóÁî®„ÅÆÈ£üÂìÅË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæóÔºà‰ªïÊßòÊõ∏Ê∫ñÊã†Ôºâ
        
        ÂÖ•Âäõ: FDC ID
        Âá¶ÁêÜ: „Ç≠„É£„ÉÉ„Ç∑„É•Á¢∫Ë™çÂæå„ÄÅÂøÖË¶Å„Å™„ÇâUSDA API„Åã„ÇâÈ£üÂìÅË©≥Á¥∞„ÇíÂèñÂæó„Åó„ÄÅ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†ÔºàË®≠ÂÆö„Éï„Ç°„Ç§„É´„ÅßÂÆöÁæ©„Åï„Çå„ÅüIDÔºâ„Çí100g„ÅÇ„Åü„Çä„ÅßÊäΩÂá∫„Éª„Éë„Éº„Çπ„ÄÇÁµêÊûú„Çí„Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò„ÄÇ
        Âá∫Âäõ: 100g„ÅÇ„Åü„Çä„ÅÆ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†ËæûÊõ∏„ÄÅ„Åæ„Åü„ÅØ None„ÄÇ
        
        Args:
            fdc_id: È£üÂìÅ„ÅÆFDC ID
            
        Returns:
            Optional[Dict[str, float]]: 100g„ÅÇ„Åü„Çä„ÅÆ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†ËæûÊõ∏„ÄÅ„Åæ„Åü„ÅØ None
        """
        if not fdc_id:
            logger.warning("Invalid FDC ID provided")
            return None
        
        try:
            # TODO: Â∞ÜÊù•ÁöÑ„Å´„Ç≠„É£„ÉÉ„Ç∑„É•Êà¶Áï•„ÇíÂÆüË£ÖÔºàRedisÁ≠âÔºâ
            # ÁèæÁä∂„ÅØÁõ¥Êé•API„Åã„ÇâÂèñÂæó
            
            logger.info(f"USDA API get food details for nutrition: fdc_id={fdc_id}")
            
            params = {
                "api_key": self.api_key,
                "format": "full",  # Ë©≥Á¥∞„Å™Ê†ÑÈ§äÊÉÖÂ†±„ÅåÂøÖË¶Å
                "nutrients": ",".join(self.key_nutrient_numbers)  # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÅÆ„Åø„ÇíÂèñÂæó
            }
            
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            # „É¨„Éº„Éà„É™„Éü„ÉÉ„ÉàÊÉÖÂ†±„ÅÆ„É≠„Ç∞
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data_raw = response.json()
            
            # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÇíÊäΩÂá∫„Éª„Éë„Éº„Çπ
            key_nutrients = self._parse_nutrients_for_calculation(food_data_raw)
            
            if key_nutrients:
                logger.info(f"Successfully extracted {len(key_nutrients)} key nutrients for FDC ID {fdc_id}")
                # TODO: Â∞ÜÊù•ÁöÑ„Å´„Åì„Åì„Åß„Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
                return key_nutrients
            else:
                logger.warning(f"No key nutrients found for FDC ID {fdc_id}")
                return None
                
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error for FDC ID {fdc_id}: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found")
                return None
            elif e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded for FDC ID {fdc_id}") from e
            raise RuntimeError(f"USDA API error for FDC ID {fdc_id}: {e.response.status_code}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}")
            raise RuntimeError(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error getting food details for nutrition (FDC ID {fdc_id}): {str(e)}")
            return None

    def _parse_nutrients_for_calculation(self, food_data_raw: dict) -> Dict[str, float]:
        """
        USDA API„É¨„Çπ„Éù„É≥„Çπ„Åã„ÇâÊ†ÑÈ§äË®àÁÆóÁî®„ÅÆ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÇíÊäΩÂá∫ÔºàÂÜÖÈÉ®„É°„ÇΩ„ÉÉ„ÉâÔºâ
        
        Args:
            food_data_raw: USDA API„Åã„Çâ„ÅÆÁîü„ÅÆÈ£üÂìÅ„Éá„Éº„Çø
            
        Returns:
            Dict[str, float]: ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†ËæûÊõ∏Ôºà„Ç≠„Éº„ÅØÊ®ôÊ∫ñÂåñ„Åï„Çå„ÅüÂêçÂâçÔºâ
        """
        key_nutrients = {}
        
        try:
            food_nutrients = food_data_raw.get("foodNutrients", [])
            
            for nutrient_entry in food_nutrients:
                # Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÅÆÊäΩÂá∫Ôºà„Éá„Éº„ÇøÊßãÈÄ†„ÅØ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å´„Çà„Å£„Å¶Áï∞„Å™„ÇãÔºâ
                nutrient_detail = nutrient_entry.get("nutrient", {})
                amount = nutrient_entry.get("amount")
                
                # Branded Foods„ÅÆabridged„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å∏„ÅÆÂØæÂøú
                if not nutrient_detail and "nutrientId" in nutrient_entry:
                    number = nutrient_entry.get("nutrientNumber")
                    amount = nutrient_entry.get("value")  # Branded abridged„Åß„ÅØ"value"
                else:
                    # SR Legacy, Foundation, „Åæ„Åü„ÅØ full Branded
                    number = nutrient_detail.get("number")
                
                # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞ÔºàÊ†ÑÈ§äÁ¥†Áï™Âè∑„Åã„ÇâÊ®ôÊ∫ñÂåñ„Åï„Çå„Åü„Ç≠„ÉºÂêç„Å∏Ôºâ
                if number and str(number) in self.key_nutrient_numbers and amount is not None:
                    if str(number) == "208":  # Energy (calories)
                        key_nutrients["calories_kcal"] = float(amount)
                    elif str(number) == "203":  # Protein
                        key_nutrients["protein_g"] = float(amount)
                    elif str(number) == "204":  # Total lipid (fat)
                        key_nutrients["fat_g"] = float(amount)
                    elif str(number) == "205":  # Carbohydrate, by difference
                        key_nutrients["carbohydrates_g"] = float(amount)
                    elif str(number) == "291":  # Fiber, total dietary (optional)
                        key_nutrients["fiber_g"] = float(amount)
                    elif str(number) == "269":  # Sugars, total (optional)
                        key_nutrients["sugars_g"] = float(amount)
                    elif str(number) == "307":  # Sodium (optional)
                        key_nutrients["sodium_mg"] = float(amount)
            
            # ÂøÖÈ†àÊ†ÑÈ§äÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ0.0„Å®„Åó„Å¶Ë®≠ÂÆö
            essential_nutrients = ["calories_kcal", "protein_g", "fat_g", "carbohydrates_g"]
            for nutrient in essential_nutrients:
                if nutrient not in key_nutrients:
                    key_nutrients[nutrient] = 0.0
                    logger.debug(f"Missing essential nutrient {nutrient}, set to 0.0")
            
            logger.debug(f"Parsed key nutrients: {key_nutrients}")
            return key_nutrients
            
        except Exception as e:
            logger.error(f"Error parsing nutrients for calculation: {str(e)}")
            return {}
    
    async def close_client(self):
        """HTTP„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çí„ÇØ„É≠„Éº„Ç∫"""
        await self.client.aclose()


# FastAPI„ÅÆ‰æùÂ≠òÊÄßÊ≥®ÂÖ•Áî®Èñ¢Êï∞
async def get_usda_service():
    """
    USDAService„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊèê‰æõ„Åô„Çã‰æùÂ≠òÊÄßÊ≥®ÂÖ•Èñ¢Êï∞
    """
    service = USDAService()
    try:
        yield service
    finally:
        await service.close_client() 
```

============================================================

üìÅ „Éá„Éº„Çø„É¢„Éá„É´Â±§
============================================================

üìÑ FILE: app/api/v1/schemas/meal.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 11147 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
from typing import List, Optional, Dict, Literal
from pydantic import BaseModel, Field, field_validator


class Ingredient(BaseModel):
    """ÊùêÊñôÊÉÖÂ†±„É¢„Éá„É´"""
    ingredient_name: str = Field(..., description="ÊùêÊñô„ÅÆÂêçÁß∞")
    weight_g: float = Field(..., description="Êé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰ΩçÔºâ", gt=0)


class Dish(BaseModel):
    """ÊñôÁêÜÊÉÖÂ†±„É¢„Éá„É´"""
    dish_name: str = Field(..., description="ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞")
    type: str = Field(..., description="ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„ÉóÔºâ")
    quantity_on_plate: str = Field(..., description="Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞")
    ingredients: List[Ingredient] = Field(..., description="„Åù„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà")


class MealAnalysisResponse(BaseModel):
    """È£ü‰∫ãÂàÜÊûê„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    dishes: List[Dish] = Field(..., description="ÁîªÂÉè„Åã„ÇâÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà")


class ErrorResponse(BaseModel):
    """„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    error: dict = Field(..., description="„Ç®„É©„ÉºÊÉÖÂ†±")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": {
                    "code": "INVALID_INPUT", 
                    "message": "Êèê‰æõ„Åï„Çå„ÅüÁîªÂÉè„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ"
                }
            }
        }


# ========== „Éï„Çß„Éº„Ç∫2Áî®„É¢„Éá„É´ ==========

# „Éï„Çß„Éº„Ç∫1„ÅÆÂá∫Âäõ„ÇíË°®„Åô„É¢„Éá„É´Ôºàinitial_analysis_dataÁî®Ôºâ
InitialAnalysisIngredient = Ingredient  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†
InitialAnalysisDish = Dish  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†
InitialAnalysisData = MealAnalysisResponse  # „Éï„Çß„Éº„Ç∫1„Å®Âêå„ÅòÊßãÈÄ†


# USDAÊ§úÁ¥¢ÁµêÊûú„ÇíË°®„Åô„É¢„Éá„É´
class USDANutrient(BaseModel):
    """USDAÊ†ÑÈ§äÁ¥†ÊÉÖÂ†±„É¢„Éá„É´"""
    name: str = Field(..., description="Ê†ÑÈ§äÁ¥†Âêç")
    amount: float = Field(..., description="100g„Åæ„Åü„ÅØ100ml„ÅÇ„Åü„Çä„ÅÆÈáè")
    unit_name: str = Field(..., description="Âçò‰ΩçÂêç (‰æã: g, mg, kcal)")
    nutrient_id: Optional[int] = Field(None, description="USDAÊ†ÑÈ§äÁ¥†ID")
    nutrient_number: Optional[str] = Field(None, description="USDAÊ†ÑÈ§äÁ¥†Áï™Âè∑")


class USDASearchResultItem(BaseModel):
    """USDAÊ§úÁ¥¢ÁµêÊûú„Ç¢„Ç§„ÉÜ„É†„É¢„Éá„É´"""
    fdc_id: int = Field(..., description="USDA FoodData Central ID")
    description: str = Field(..., description="È£üÂìÅ„ÅÆÂÖ¨ÂºèÂêçÁß∞")
    data_type: Optional[str] = Field(None, description="USDA„Éá„Éº„Çø„Çø„Ç§„Éó (‰æã: SR Legacy, Branded)")
    brand_owner: Optional[str] = Field(None, description="„Éñ„É©„É≥„ÉâÊâÄÊúâËÄÖ (Branded Foods„ÅÆÂ†¥Âêà)")
    ingredients_text: Optional[str] = Field(None, description="ÂéüÊùêÊñô„É™„Çπ„ÉàÊñáÂ≠óÂàó (Branded Foods„ÅÆÂ†¥Âêà)")
    food_nutrients: List[USDANutrient] = Field(default_factory=list, description="‰∏ªË¶Å„Å™Ê†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÅÆ„É™„Çπ„Éà")
    score: Optional[float] = Field(None, description="Ê§úÁ¥¢ÁµêÊûú„ÅÆÈñ¢ÈÄ£Â∫¶„Çπ„Ç≥„Ç¢")


# Ë®àÁÆóÊ∏à„ÅøÊ†ÑÈ§äÁ¥†ÊÉÖÂ†±„ÇíÊ†ºÁ¥ç„Åô„ÇãÂÖ±ÈÄö„É¢„Éá„É´
class CalculatedNutrients(BaseModel):
    """Ë®àÁÆóÊ∏à„ÅøÊ†ÑÈ§äÁ¥†„É¢„Éá„É´"""
    calories_kcal: float = Field(0.0, description="Ë®àÁÆó„Åï„Çå„ÅüÁ∑è„Ç´„É≠„É™„Éº (kcal)")
    protein_g: float = Field(0.0, description="Ë®àÁÆó„Åï„Çå„ÅüÁ∑è„Çø„É≥„Éë„ÇØË≥™ (g)")
    carbohydrates_g: float = Field(0.0, description="Ë®àÁÆó„Åï„Çå„ÅüÁ∑èÁÇ≠Ê∞¥ÂåñÁâ© (g)")
    fat_g: float = Field(0.0, description="Ë®àÁÆó„Åï„Çå„ÅüÁ∑èËÑÇË≥™ (g)")

    class Config:
        json_schema_extra = {
            "example": {
                "calories_kcal": 82.5,
                "protein_g": 15.5,
                "carbohydrates_g": 0.0,
                "fat_g": 1.8
            }
        }


# „Éï„Çß„Éº„Ç∫2„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Çπ„Ç≠„Éº„Éû
class RefinedIngredient(BaseModel):
    """USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊùêÊñô„É¢„Éá„É´"""
    ingredient_name: str = Field(..., description="ÊùêÊñô„ÅÆÂêçÁß∞ÔºàÁ≤æÁ∑ªÂåñÂæåÔºâ")
    weight_g: float = Field(..., description="ÊùêÊñô„ÅÆÊé®ÂÆöÈáçÈáèÔºà„Ç∞„É©„É†Âçò‰Ωç„ÄÅ„Éï„Çß„Éº„Ç∫1Áî±Êù•Ôºâ", gt=0)  # „Åì„ÅÆÈáçÈáè„ÅØ„Éï„Çß„Éº„Ç∫1„Åã„ÇâÂºï„ÅçÁ∂ô„Åå„Çå„Çã
    fdc_id: Optional[int] = Field(None, description="ÂØæÂøú„Åô„ÇãUSDAÈ£üÂìÅ„ÅÆFDC ID (È£üÊùê„É¨„Éô„É´„ÅÆÂ†¥Âêà)")
    usda_source_description: Optional[str] = Field(None, description="ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆÂÖ¨ÂºèÂêçÁß∞ (È£üÊùê„É¨„Éô„É´„ÅÆÂ†¥Âêà)")
    key_nutrients_per_100g: Optional[Dict[str, float]] = Field(
        None,
        description="ÈÅ∏Êäû„Åï„Çå„ÅüUSDAÈ£üÂìÅ„ÅÆ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Ôºà100g„ÅÇ„Åü„ÇäÔºâ„ÄÇ„Ç≠„Éº„ÅØ'calories_kcal', 'protein_g', 'carbohydrates_g', 'fat_g'„ÄÇ",
    )
    actual_nutrients: Optional[CalculatedNutrients] = Field(
        None,
        description="„Åì„ÅÆÈ£üÊùê„ÅÆÊé®ÂÆöÈáçÈáè„Å®100g„ÅÇ„Åü„Çä„ÅÆÊ†ÑÈ§äÁ¥†„Å´Âü∫„Å•„ÅÑ„Å¶Ë®àÁÆó„Åï„Çå„ÅüÂÆüÈöõ„ÅÆÊ†ÑÈ§äÁ¥†Èáè„ÄÇ"
    )

    @field_validator('key_nutrients_per_100g')
    def check_ingredient_nutrients_values(cls, v):
        if v is not None:
            for key, value in v.items():
                if value is None:
                    v[key] = 0.0
        return v


class RefinedDish(BaseModel):
    """USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊñôÁêÜ„É¢„Éá„É´"""
    dish_name: str = Field(..., description="ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ„ÅÆÂêçÁß∞ÔºàÁ≤æÁ∑ªÂåñÂæåÔºâ")
    type: str = Field(..., description="ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, „Çπ„Éº„ÉóÔºâ")
    quantity_on_plate: str = Field(..., description="Áöø„ÅÆ‰∏ä„Å´Ëºâ„Å£„Å¶„ÅÑ„ÇãÊñôÁêÜ„ÅÆ„Åä„Åä„Çà„Åù„ÅÆÈáè„ÇÑÂÄãÊï∞")
    
    calculation_strategy: Optional[Literal["dish_level", "ingredient_level"]] = Field(  # NEW FIELD
        None, 
        description="„Åì„ÅÆÊñôÁêÜ„ÅÆÊ†ÑÈ§äË®àÁÆóÊñπÈáù (Gemini„ÅåÊ±∫ÂÆö)"
    )
    
    # dish_levelË®àÁÆóÊôÇ„Å´‰ΩøÁî®„Åï„Çå„Çã„Éï„Ç£„Éº„É´„Éâ
    fdc_id: Optional[int] = Field(None, description="ÊñôÁêÜÂÖ®‰Ωì„ÅÆFDC ID (dish_levelË®àÁÆóÊôÇ)")
    usda_source_description: Optional[str] = Field(None, description="ÊñôÁêÜÂÖ®‰Ωì„ÅÆUSDAÂÖ¨ÂºèÂêçÁß∞ (dish_levelË®àÁÆóÊôÇ)")
    key_nutrients_per_100g: Optional[Dict[str, float]] = Field(  # „Åì„ÅÆÊñôÁêÜÂÖ®‰Ωì„ÅÆ100g„ÅÇ„Åü„ÇäÊ†ÑÈ§äÁ¥† (dish_levelË®àÁÆóÊôÇ)
        None,
        description="ÊñôÁêÜÂÖ®‰Ωì„ÅÆ100g„ÅÇ„Åü„Çä‰∏ªË¶ÅÊ†ÑÈ§äÁ¥† (dish_levelË®àÁÆóÊôÇ)„ÄÇ„Ç≠„Éº„ÅØ'calories_kcal', 'protein_g', 'carbohydrates_g', 'fat_g'„ÄÇ",
    )

    ingredients: List[RefinedIngredient] = Field(default_factory=list, description="„Åì„ÅÆÊñôÁêÜ„Å´Âê´„Åæ„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà„ÄÇcalculation_strategy„Åå'dish_level'„ÅÆÂ†¥Âêà„ÄÅ„Åì„Çå„Çâ„ÅÆÊùêÊñô„ÅÆactual_nutrients„ÅØË®àÁÆó„Åï„Çå„Å™„ÅÑ„Åì„Å®„Åå„ÅÇ„Çã„ÄÇ")
    
    dish_total_actual_nutrients: Optional[CalculatedNutrients] = Field(  # dish_level„ÅÆÂ†¥Âêà„ÅØÊñôÁêÜÂÖ®‰Ωì„ÅÆË®àÁÆóÁµêÊûú„ÄÅingredient_level„ÅÆÂ†¥Âêà„ÅØÊùêÊñô„ÅÆÈõÜË®àÁµêÊûú
        None,
        description="„Åì„ÅÆÊñôÁêÜ„ÅÆÂêàË®àÊ†ÑÈ§äÁ¥†„ÄÇcalculation_strategy„Å´Âü∫„Å•„ÅçË®àÁÆó„Åï„Çå„Çã„ÄÇ"
    )

    @field_validator('key_nutrients_per_100g')
    def check_dish_nutrients_values(cls, v):
        if v is not None:
            for key, value in v.items():
                if value is None:
                    v[key] = 0.0
        return v


class MealAnalysisRefinementResponse(BaseModel):
    """„Éï„Çß„Éº„Ç∫2È£ü‰∫ãÂàÜÊûêÁ≤æÁ∑ªÂåñ„É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´"""
    dishes: List[RefinedDish] = Field(..., description="USDAÊÉÖÂ†±„ÅßÁ≤æÁ∑ªÂåñ„ÉªÊ†ÑÈ§äË®àÁÆó„Åï„Çå„ÅüÊñôÁêÜ„ÅÆ„É™„Çπ„Éà")
    total_meal_nutrients: Optional[CalculatedNutrients] = Field(
        None,
        description="È£ü‰∫ãÂÖ®‰Ωì„ÅÆÂÖ®„Å¶„ÅÆÊñôÁêÜ„ÅÆÊ†ÑÈ§äÁ¥†„ÇíÈõÜË®à„Åó„ÅüÂêàË®àÂÄ§„ÄÇ"
    )
    warnings: Optional[List[str]] = Field(None, description="Âá¶ÁêÜ‰∏≠„Å´Áô∫Áîü„Åó„ÅüË≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„É™„Çπ„Éà„ÄÇ")
    errors: Optional[List[str]] = Field(None, description="Âá¶ÁêÜ‰∏≠„Å´Áô∫Áîü„Åó„Åü„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„É™„Çπ„Éà„ÄÇ")


# GeminiÂêë„Åë„ÅÆJSON„Çπ„Ç≠„Éº„ÉûÂÆöÁæ© (REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA) „ÅÆÊõ¥Êñ∞
REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ÁîªÂÉè„Åã„ÇâÁâπÂÆö„ÉªÁ≤æÁ∑ªÂåñ„Åï„Çå„ÅüÊñôÁêÜ/È£üÂìÅ„Ç¢„Ç§„ÉÜ„É†„ÅÆ„É™„Çπ„Éà„ÄÇ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ÁâπÂÆö„Åï„Çå„ÅüÊñôÁêÜ/È£üÂìÅ„Ç¢„Ç§„ÉÜ„É†„ÅÆÂêçÁß∞„ÄÇ"},
                    "type": {"type": "string", "description": "ÊñôÁêÜ„ÅÆÁ®ÆÈ°ûÔºà‰æã: ‰∏ªËèú, ÂâØËèú, ÂçòÂìÅÈ£üÂìÅÔºâ„ÄÇ"},
                    "quantity_on_plate": {"type": "string", "description": "Áöø„ÅÆ‰∏ä„ÅÆÈáè„ÄÇ"},
                    "calculation_strategy": {  # NEW: Gemini„Å´Âá∫Âäõ„Åï„Åõ„Çã
                        "type": "string",
                        "enum": ["dish_level", "ingredient_level"],
                        "description": "„Åì„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆÊ†ÑÈ§äË®àÁÆóÊñπÈáù„ÄÇ"
                    },
                    "fdc_id": {  # NEW: dish_level„ÅÆÂ†¥Âêà„ÅÆFDC ID (nullÂèØËÉΩ)
                        "type": "integer",
                        "description": "calculation_strategy„Åå'dish_level'„ÅÆÂ†¥Âêà„ÄÅ„Åì„ÅÆÊñôÁêÜ/È£üÂìÅ„Ç¢„Ç§„ÉÜ„É†ÂÖ®‰Ωì„ÅÆFDC ID„ÄÇ„Åù„Çå‰ª•Â§ñ„ÅØnull„ÄÇ"
                    },
                    "usda_source_description": {  # NEW: dish_level„ÅÆÂ†¥Âêà„ÅÆË™¨Êòé (nullÂèØËÉΩ)
                        "type": "string",
                        "description": "calculation_strategy„Åå'dish_level'„ÅÆÂ†¥Âêà„ÄÅ„Åì„ÅÆÊñôÁêÜ/È£üÂìÅ„Ç¢„Ç§„ÉÜ„É†ÂÖ®‰Ωì„ÅÆUSDAÂÖ¨ÂºèÂêçÁß∞„ÄÇ„Åù„Çå‰ª•Â§ñ„ÅØnull„ÄÇ"
                    },
                    "ingredients": {
                        "type": "array",
                        "description": "„Åì„ÅÆÊñôÁêÜ/È£üÂìÅ„Ç¢„Ç§„ÉÜ„É†„Å´Âê´„Åæ„Çå„Çã„Å®Êé®ÂÆö„Åï„Çå„ÇãÊùêÊñô„ÅÆ„É™„Çπ„Éà„ÄÇcalculation_strategy„Åå'ingredient_level'„ÅÆÂ†¥Âêà„ÄÅÂêÑÊùêÊñô„Å´fdc_id„Å®usda_source_description„ÅåÂøÖË¶Å„ÄÇ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ÊùêÊñô„ÅÆÂêçÁß∞„ÄÇ"},
                                # weight_g „ÅØ„Éï„Çß„Éº„Ç∫1„Åã„ÇâÂºï„ÅçÁ∂ô„Åå„Çå„Çã„Åü„ÇÅ„ÄÅGemini„ÅØÂá∫Âäõ‰∏çË¶Å
                                "fdc_id": {
                                    "type": "integer",
                                    "description": "calculation_strategy„Åå'ingredient_level'„ÅÆÂ†¥Âêà„ÄÅ„Åì„ÅÆÊùêÊñô„ÅÆFDC ID„ÄÇ„Åù„Çå‰ª•Â§ñ„ÅØnull„Åæ„Åü„ÅØÁúÅÁï•ÂèØ„ÄÇ"
                                },
                                "usda_source_description": {
                                    "type": "string",
                                    "description": "calculation_strategy„Åå'ingredient_level'„ÅÆÂ†¥Âêà„ÄÅ„Åì„ÅÆÊùêÊñô„ÅÆUSDAÂÖ¨ÂºèÂêçÁß∞„ÄÇ„Åù„Çå‰ª•Â§ñ„ÅØnull„Åæ„Åü„ÅØÁúÅÁï•ÂèØ„ÄÇ"
                                }
                            },
                            "required": ["ingredient_name"]  # Áä∂Ê≥Å„Å´Âøú„Åò„Å¶fdc_id, usda_source_description„ÇÇÂøÖÈ†à
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "calculation_strategy", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
} 
```

============================================================

üìÅ Ë®≠ÂÆöÁÆ°ÁêÜ
============================================================

üìÑ FILE: app/core/config.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 2180 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    APIË®≠ÂÆö„ÇØ„É©„Çπ
    Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË®≠ÂÆöÂÄ§„ÇíË™≠„ÅøËæº„ÇÄ
    """
    # Vertex AIË®≠ÂÆö
    GEMINI_PROJECT_ID: str  # GCP„Éó„É≠„Ç∏„Çß„ÇØ„ÉàIDÔºàÂøÖÈ†àÔºâ
    GEMINI_LOCATION: str = "us-central1"  # „Éá„Éï„Ç©„É´„Éà„ÅÆ„É≠„Ç±„Éº„Ç∑„Éß„É≥
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA APIË®≠ÂÆö
    USDA_API_KEY: str  # USDA FoodData Central API„Ç≠„ÉºÔºàÂøÖÈ†àÔºâ
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # API„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁßíÊï∞
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1Âõû„ÅÆÊ§úÁ¥¢„ÅßÂèñÂæó„Åô„ÇãÊúÄÂ§ßÂÄôË£úÊï∞
    # ‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Áï™Âè∑Ôºà„Ç´„É≥„ÉûÂå∫Âàá„ÇäÊñáÂ≠óÂàó„Å®„Åó„Å¶Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË™≠„ÅøËæº„ÇÄÔºâ
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """‰∏ªË¶ÅÊ†ÑÈ§äÁ¥†Áï™Âè∑„ÅÆ„É™„Çπ„Éà„ÇíËøî„Åô"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # „Ç≠„É£„ÉÉ„Ç∑„É•Ë®≠ÂÆö
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redis„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅÆURL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDA„É¨„Çπ„Éù„É≥„Çπ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•ÊúâÂäπÊúüÈñìÔºà1ÊôÇÈñìÔºâ
    
    # APIË®≠ÂÆö
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # „Çµ„Éº„Éê„ÉºË®≠ÂÆö
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # API„Éê„Éº„Ç∏„Éß„É≥
    API_VERSION: str = "v1"
    
    # Google CloudË™çË®ºË®≠ÂÆö
    # GOOGLE_APPLICATION_CREDENTIALS„ÅØÈÄöÂ∏∏Áí∞Â¢ÉÂ§âÊï∞„ÅßË®≠ÂÆö„Åô„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ‰∏çË¶Å
    # gcloud auth application-default login „Åß„ÇÇÂèØ
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    Ë®≠ÂÆö„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„ÇãÔºâ
    """
    return Settings() 
```

============================================================

üìÅ „Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜ
============================================================

üìÑ FILE: app/prompts/__init__.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 114 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-05-29 16:07:57
Â≠òÂú®: ‚úÖ

CONTENT:
```
"""
„Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜ„É¢„Ç∏„É•„Éº„É´
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

üìÑ FILE: app/prompts/prompt_loader.py
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 4237 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
"""
„Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„ÅßÁÆ°ÁêÜ„Åô„Çã„É¢„Ç∏„É•„Éº„É´
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """„Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„ÅßÁÆ°ÁêÜ„Åô„Çã„ÇØ„É©„Çπ"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        ÂàùÊúüÂåñ
        
        Args:
            prompts_dir: „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÅåÊ†ºÁ¥ç„Åï„Çå„Å¶„ÅÑ„Çã„Éá„Ç£„É¨„ÇØ„Éà„É™„Éë„Çπ
                        None„ÅÆÂ†¥Âêà„ÅØÁèæÂú®„ÅÆ„Éï„Ç°„Ç§„É´„Å®Âêå„Åò„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩøÁî®
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # „Éó„É≠„É≥„Éó„Éà„Çí„Ç≠„É£„ÉÉ„Ç∑„É•
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
        
        Args:
            filename: „Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´Âêç
            
        Returns:
            „Éó„É≠„É≥„Éó„Éà„ÅÆÂÜÖÂÆπ
            
        Raises:
            FileNotFoundError: „Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà
            IOError: „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """„Éï„Çß„Éº„Ç∫1„ÅÆ„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        „Éï„Çß„Éº„Ç∫1„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
        
        Args:
            optional_text: „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
            
        Returns:
            „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """„Éï„Çß„Éº„Ç∫2„ÅÆ„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        usda_candidates: str, 
        initial_ai_output: Optional[str] = None
    ) -> str:
        """
        „Éï„Çß„Éº„Ç∫2„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó
        
        Args:
            usda_candidates: USDAÂÄôË£úÊÉÖÂ†±
            initial_ai_output: „Éï„Çß„Éº„Ç∫1„ÅÆAIÂá∫Âäõ
            
        Returns:
            „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„Åø„ÅÆ„É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        if initial_ai_output:
            initial_ai_output_section = f"Initial AI analysis results:\n{initial_ai_output}\n\n"
        else:
            initial_ai_output_section = ""
        
        return template.format(
            initial_ai_output_section=initial_ai_output_section,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """„Éó„É≠„É≥„Éó„Éà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢„Åó„Å¶ÂÜçË™≠„ÅøËæº„Åø„Çí‰øÉ„Åô"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

üìÅ „Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà
============================================================

üìÑ FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 974 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
You are an experienced culinary analyst. Your task is to analyze meal images and provide a detailed breakdown of dishes and their ingredients in JSON format.

IMPORTANT: You MUST provide ALL responses in English only. This includes dish names, ingredient names, types, and any other text fields.

Please note the following:
1. Carefully observe the image including the plate and make detailed estimates based on surrounding context.
2. Identify all dishes present in the image, determine their types, the quantity of each dish on the plate, and the ingredients contained with their respective amounts.
3. There may be multiple dishes in a single image, so provide information about each dish and its ingredients separately.
4. Your output will be used for nutritional calculations, so ensure your estimates are as accurate as possible.
5. Strictly follow the provided JSON schema in your response.
6. ALL text must be in English (dish names, ingredient names, types, etc.). 
```

============================================================

üìÑ FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 86 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-01 16:12:20
Â≠òÂú®: ‚úÖ

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

üìÑ FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 4338 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
You are an expert food item identifier, data matcher, and nutritional analysis strategist. Your task is to refine an initial meal analysis by:
1.  Determining the best `calculation_strategy` ("dish_level" or "ingredient_level") for each identified dish/food item.
2.  Matching the dish/food item (if "dish_level") OR its constituent ingredients (if "ingredient_level") to the most appropriate USDA FoodData Central (FDC) entries based on provided candidate information.
3.  Providing the official USDA `usda_source_description` for all matched FDC IDs.

IMPORTANT:
1.  You MUST provide ALL responses in English only.
2.  Your primary goal is to output the `calculation_strategy` for each dish, and then the relevant `fdc_id`(s) and `usda_source_description`(s) according to that strategy.
3.  You DO NOT need to calculate or return any nutritional values (calories, protein, etc.). This will be handled by a separate system.
4.  The `weight_g` for each ingredient is already determined in a previous phase and should NOT be modified or output by you.
5.  Strictly follow the provided JSON schema for your response (see REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA).

Your tasks for EACH dish/food item identified in the initial analysis:

TASK 1: Determine `calculation_strategy`.
   - If the dish/food item is a single, simple item (e.g., "Apple", "Banana", "Chicken Breast Fillet") AND a good, specific FDC ID candidate exists for it:
     Choose `calculation_strategy: "dish_level"`.
   - If the dish is a complex, mixed dish (e.g., "Homemade Vegetable Stir-fry", "Mixed Salad with various toppings", "Beef Stew"):
     Choose `calculation_strategy: "ingredient_level"`. You will then need to identify FDC IDs for its constituent ingredients.
   - If the dish is a somewhat standardized prepared dish (e.g., "Pepperoni Pizza", "Cheeseburger") AND a representative FDC ID candidate exists for the *entire dish*:
     Choose `calculation_strategy: "dish_level"`.
   - If a standardized dish does NOT have a good representative FDC ID for the entire dish, OR if breaking it down into its main ingredients would be more accurate:
     Choose `calculation_strategy: "ingredient_level"`.
   - Provide a brief rationale for your choice of strategy if it's not obvious (though this rationale is not part of the JSON output).

TASK 2: Output FDC ID(s) and Description(s) based on the chosen `calculation_strategy`.

   IF `calculation_strategy` is "dish_level":
     a. From the USDA candidates for the *dish/food item itself*, select the single most appropriate FDC ID.
     b. Set this as the `fdc_id` for the dish in your JSON output.
     c. Set the corresponding `usda_source_description` for the dish.
     d. The `ingredients` array for this dish in your JSON output should still list the ingredients identified in Phase 1 (or refined by you if necessary for clarity), but these ingredients will NOT have their own `fdc_id` or `usda_source_description` set by you in this "dish_level" scenario (set them to `null` or omit). Their primary purpose here is descriptive.

   IF `calculation_strategy` is "ingredient_level":
     a. Set the `fdc_id` and `usda_source_description` for the *dish itself* to `null` in your JSON output.
     b. For EACH `ingredient` within that dish (from the initial analysis, possibly refined by you):
        i. From the USDA candidates provided for *that specific ingredient*, select the single most appropriate FDC ID.
        ii. Set this as the `fdc_id` for that ingredient in your JSON output.
        iii. Set the corresponding `usda_source_description` for that ingredient.
        iv. If no suitable FDC ID is found for an ingredient, set its `fdc_id` and `usda_source_description` to `null`.

General Guidelines for FDC ID Selection (for dish or ingredient):
- Consider typical uses of ingredients and the most plausible match to the image context (if discernible) and initial `ingredient_name`.
- Prioritize FDC ID candidates in this order if relevant and good matches exist: 'Foundation Foods', 'SR Legacy', 'FNDDS' (Survey), then 'Branded Foods'.
- You may slightly refine `dish_name` or `ingredient_name` if the USDA description offers a more precise or common English term for the same food item, ensuring it still accurately represents the food.

Output the final analysis in the specified JSON format. 
```

============================================================

üìÑ FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: 689 bytes
ÊúÄÁµÇÊõ¥Êñ∞: 2025-06-05 10:30:58
Â≠òÂú®: ‚úÖ

CONTENT:
```
{initial_ai_output_section}
Above is the initial AI analysis of the meal.

USDA food database candidate information for the items in the initial analysis and potentially for the overall dishes:
{usda_candidates}

Based on all this information (initial analysis, USDA candidates, and implicitly the image context from the initial analysis), please refine the analysis. For each dish/food item:
1. Determine its `calculation_strategy` ('dish_level' or 'ingredient_level').
2. Provide the `fdc_id` and `usda_source_description` according to that strategy, as detailed in the system instructions.
Remember to follow the JSON schema strictly. Do not calculate or return any nutritional values. 
```

============================================================

üéØ SUMMARY
----------------------------------------
Á∑è„Éï„Ç°„Ç§„É´Êï∞: 14
Â≠òÂú®„Éï„Ç°„Ç§„É´Êï∞: 14
ÂàÜÊûêÂÆå‰∫ÜÊôÇÂàª: 2025-06-05 10:42:32

„Åì„ÅÆ„Éï„Ç°„Ç§„É´„Å´„ÅØ„ÄÅtest_english_phase2.pyÂÆüË°åÊôÇ„Å´Èñ¢„Çè„ÇãÂÖ®„Å¶„ÅÆ
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„ÅÆÂÆåÂÖ®„Å™ÂÜÖÂÆπ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
