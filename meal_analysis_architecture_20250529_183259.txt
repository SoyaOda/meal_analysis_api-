================================================================================
MEAL ANALYSIS API - アーキテクチャ構造とファイル分析
================================================================================
生成日時: 2025-05-29 18:32:59
分析対象: test_english_phase2.py 実行時に呼び出される全ファイル
================================================================================

📊 ARCHITECTURE OVERVIEW
----------------------------------------

🔄 EXECUTION FLOW (2-Phase Approach):
Phase 1: 画像 → Gemini AI → 料理・食材識別 (英語名)
Phase 2: Phase1結果 + 画像 → USDA検索 → Gemini再分析 → 栄養成分精緻化

🏗️ LAYER STRUCTURE:
├── API層 (FastAPI)
│   ├── meal_analyses.py (Phase 1 endpoint)
│   └── meal_analyses_refine.py (Phase 2 endpoint)
├── サービス層
│   ├── gemini_service.py (Vertex AI Gemini連携)
│   └── usda_service.py (USDA FoodData Central API連携)
├── データモデル層
│   └── meal.py (Pydantic schemas)
├── プロンプト管理層
│   ├── prompt_loader.py (Template management)
│   └── prompt templates (*.txt)
└── 設定層
    └── config.py (Environment configuration)

🔧 TECHNICAL FEATURES:
- 非同期処理 (async/await)
- 構造化JSON出力 (Gemini response_schema)
- USDA栄養データベース連携
- キャッシュ機能
- 包括的エラーハンドリング

================================================================================

📁 メインテストファイル
============================================================

📄 FILE: test_english_phase2.py
--------------------------------------------------
ファイルサイズ: 2808 bytes
最終更新: 2025-05-29 16:53:14
存在: ✅

CONTENT:
```
import requests
import json
import asyncio
import httpx

# API設定
BASE_URL = "http://localhost:8000/api/v1"

# テスト画像のパス（英語の食材名を含む画像を使用）
image_path = "test_images/food3.jpg"

async def run_phase1_and_phase2():
    """フェーズ1→フェーズ2の流れをテスト"""
    
    print("=== Phase 1: Initial Analysis ===")
    
    # フェーズ1: 画像分析
    with open(image_path, "rb") as f:
        files = {"image": ("food3.jpg", f, "image/jpeg")}
        response = requests.post(f"{BASE_URL}/meal-analyses", files=files)
    
    if response.status_code != 200:
        print(f"Phase 1 failed: {response.status_code}")
        print(response.text)
        return
    
    phase1_result = response.json()
    print("Phase 1 successful!")
    print(json.dumps(phase1_result, indent=2))
    
    # 食材名を表示（英語になっているはず）
    print("\nDetected ingredients:")
    for dish in phase1_result.get("dishes", []):
        print(f"  Dish: {dish['dish_name']}")
        for ingredient in dish.get("ingredients", []):
            print(f"    - {ingredient['ingredient_name']}: {ingredient['weight_g']}g")
    
    print("\n=== Phase 2: USDA Refinement ===")
    
    # フェーズ2: USDA精緻化
    with open(image_path, "rb") as f:
        files = {
            "image": ("food3.jpg", f, "image/jpeg"),
            "initial_analysis_data": (None, json.dumps(phase1_result), "application/json")
        }
        response = requests.post(f"{BASE_URL}/meal-analyses/refine", files=files)
    
    print(f"Phase 2 status: {response.status_code}")
    
    if response.status_code == 200:
        phase2_result = response.json()
        print("Phase 2 successful!")
        print(json.dumps(phase2_result, indent=2))
        
        # USDA FDC IDを表示
        print("\nUSDA matches:")
        for dish in phase2_result.get("dishes", []):
            print(f"  Dish: {dish['dish_name']}")
            for ingredient in dish.get("ingredients", []):
                if ingredient.get("fdc_id"):
                    print(f"    - {ingredient['ingredient_name']}: FDC ID {ingredient['fdc_id']} ({ingredient.get('usda_source_description', 'N/A')})")
                else:
                    print(f"    - {ingredient['ingredient_name']}: No USDA match")
                    
                # 栄養素情報を表示
                nutrients = ingredient.get("key_nutrients_per_100g", {})
                if nutrients:
                    print(f"      Nutrients per 100g: {nutrients}")
    else:
        print("Phase 2 failed!")
        print(response.text)

if __name__ == "__main__":
    print("Testing Meal Analysis API (English version)")
    print(f"Using image: {image_path}")
    asyncio.run(run_phase1_and_phase2()) 
```

============================================================

📁 API エンドポイント層
============================================================

📄 FILE: app/main.py
--------------------------------------------------
ファイルサイズ: 3235 bytes
最終更新: 2025-05-29 16:07:57
存在: ✅

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine
from .core.config import get_settings

# ロギングの設定
logging.basicConfig(
    level=logging.DEBUG,  # 一時的にDEBUGレベルに変更
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)

# 設定の取得
settings = get_settings()

# FastAPIアプリケーションの作成
app = FastAPI(
    title="食事分析API (Meal Analysis API)",
    description="食事の画像とテキストを分析し、料理と材料を特定するAPI。USDAデータベースとの連携により栄養価計算の精度を向上。",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORSミドルウェアの設定（開発環境用）
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # 本番環境では適切に制限する
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# ルートパスのエンドポイント
@app.get("/")
async def root():
    """APIのルートエンドポイント"""
    return {
        "message": "食事分析API (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# ヘルスチェックエンドポイント
@app.get("/health")
async def health_check():
    """APIのヘルスチェック"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 APIルーターの登録
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API フェーズ2ルーターの登録（/refineエンドポイント）
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# スタートアップイベント
@app.on_event("startup")
async def startup_event():
    """アプリケーション起動時の処理"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# シャットダウンイベント
@app.on_event("shutdown")
async def shutdown_event():
    """アプリケーション終了時の処理"""
    logger.info("Meal Analysis API shutting down...")

# グローバルエラーハンドラー
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """予期しないエラーのハンドリング"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "内部サーバーエラーが発生しました。"
            }
        }
    ) 
```

============================================================

📄 FILE: app/api/v1/endpoints/meal_analyses.py
--------------------------------------------------
ファイルサイズ: 7582 bytes
最終更新: 2025-05-29 17:57:41
存在: ✅

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, Optional
import logging
import time  # 実行時間測定のため

from ....services.gemini_service import GeminiMealAnalyzer
from ..schemas.meal import Phase1AnalysisResponse, MealAnalysisResponse, ErrorResponse
from ....services.logging_service import get_meal_analysis_logger, ProcessingPhase, LogLevel
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Geminiサービスインスタンスのキャッシュ
_gemini_analyzer = None


async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Geminiサービスインスタンスを取得（シングルトン）
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "",
    response_model=Phase1AnalysisResponse,
    summary="Analyze Meal Image (Phase 1 v2.1)",
    description="v2.1: 食事画像を分析し、料理・食材識別とUSDAクエリ候補生成を行います。"
)
async def analyze_meal_v2_1(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    optional_text: Annotated[Optional[str], None] = None
):
    """
    v2.1仕様：食事画像の基本分析
    
    処理フロー:
    1. 画像の基本バリデーション
    2. Gemini AI による食事分析（Phase 1）
    3. USDAクエリ候補の生成
    4. 結果返却
    """
    # ログサービス初期化
    meal_logger = get_meal_analysis_logger()
    session_id = meal_logger.start_session(
        endpoint="/api/v1/meal-analyses",
        image_filename=getattr(image, 'filename', None),
        image_size_bytes=None  # 後で設定
    )
    
    start_time = time.time()
    
    try:
        # 1. Image validation
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.REQUEST_RECEIVED,
            message="Starting Phase 1 meal analysis"
        )
        
        if not image.content_type or not image.content_type.startswith("image/"):
            raise HTTPException(status_code=400, detail="Invalid image file format.")
        
        try:
            image_bytes = await image.read()
            # Update image size in session
            if session_id in meal_logger.active_sessions:
                meal_logger.active_sessions[session_id].image_size_bytes = len(image_bytes)
            
            # File size check (e.g., 10MB)
            if len(image_bytes) > 10 * 1024 * 1024:
                raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
        except Exception as e:
            logger.error(f"Error reading image file: {e}")
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.REQUEST_RECEIVED,
                error_message="Failed to read image file",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail="Failed to read image file.")

        # 2. Geminiサービスインスタンス取得
        gemini_service = await get_gemini_analyzer(settings)

        # 3. Call Gemini service (Phase 1)
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.PHASE1_START,
            message="Starting Gemini Phase 1 analysis"
        )
        
        phase1_start_time = time.time()
        try:
            result = await gemini_service.analyze_image_phase1(
                image_bytes=image_bytes,
                image_mime_type=image.content_type,
                optional_text=optional_text
            )
            phase1_duration = (time.time() - phase1_start_time) * 1000
            
            # Phase 1結果をログに記録
            dishes_count = len(result.get('dishes', []))
            usda_queries_count = sum(
                len(dish.get('usda_query_candidates', [])) 
                for dish in result.get('dishes', [])
            )
            
            meal_logger.update_phase1_results(
                session_id=session_id,
                duration_ms=phase1_duration,
                dishes_count=dishes_count,
                usda_queries_count=usda_queries_count,
                phase1_output=result
            )
            
        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE1_START,
                error_message="Gemini Phase 1 analysis failed",
                error_details=str(e)
            )
            raise HTTPException(status_code=503, detail=f"Gemini API error: {e}")

        # 4. レスポンス作成とセッション終了
        response = Phase1AnalysisResponse(**result)
        
        meal_logger.end_session(
            session_id=session_id,
            warnings=None,
            errors=None
        )
        
        return response
        
    except Exception as e:
        # 予期しないエラーのログ記録
        meal_logger.log_error(
            session_id=session_id,
            phase=ProcessingPhase.ERROR_OCCURRED,
            error_message="Unexpected error during Phase 1 processing",
            error_details=str(e)
        )
        
        # セッション終了（エラー時）
        meal_logger.end_session(
            session_id=session_id,
            warnings=None,
            errors=[str(e)]
        )
        
        raise


# 後方互換性のため、古いエンドポイントも維持
@router.post(
    "/legacy",
    response_model=MealAnalysisResponse,
    summary="Legacy Meal Analysis (v1.0 compatibility)",
    description="後方互換性のための旧バージョンエンドポイント。新しい機能にはメインエンドポイント `/` を使用してください。"
)
async def analyze_meal_legacy(
    image: Annotated[UploadFile, File(description="Meal image file to analyze.")],
    settings: Annotated[Settings, Depends(get_settings)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)],
    optional_text: Annotated[Optional[str], Form(description="Optional additional information about the meal.")] = None
):
    """
    後方互換性のための旧フォーマット
    """
    # 同じ検証を実行
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Invalid image file format.")
    
    image_bytes = await image.read()
    if len(image_bytes) > 10 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="File too large.")
    
    try:
        # 旧メソッドを使用（存在する場合）
        analysis_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            optional_text=optional_text
        )
        
        response = MealAnalysisResponse(**analysis_result)
        return response
        
    except Exception as e:
        logger.error(f"Legacy analysis error: {e}")
        raise HTTPException(status_code=500, detail=str(e)) 
```

============================================================

📄 FILE: app/api/v1/endpoints/meal_analyses_refine.py
--------------------------------------------------
ファイルサイズ: 21048 bytes
最終更新: 2025-05-29 17:57:01
存在: ✅

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, List, Optional, Dict
import json
import logging
import asyncio  # 非同期処理のため
import time  # 実行時間測定のため

# 新しいPydanticモデル
from ..schemas.meal import (
    Phase1AnalysisResponse,  # Phase 1 出力をパースするために使用
    Phase2GeminiResponse,    # Phase 2 Gemini出力をパースするために使用
    MealAnalysisRefinementResponse,
    USDASearchResultItem,
    RefinedDishResponse,
    RefinedIngredientResponse,
    CalculatedNutrients
)

# サービス
from ....services.usda_service import USDAService, get_usda_service
from ....services.gemini_service import GeminiMealAnalyzer
from ....services.nutrition_calculation_service import NutritionCalculationService, get_nutrition_calculation_service
from ....services.logging_service import get_meal_analysis_logger, ProcessingPhase, LogLevel
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Geminiサービスインスタンスのキャッシュ
_gemini_analyzer = None

async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Geminiサービスインスタンスを取得（シングルトン）
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/refine",
    response_model=MealAnalysisRefinementResponse,
    summary="Refine Meal Analysis with USDA Data & Enhanced Gemini Strategy (v2.1)",
    description="v2.1: Phase 1からUSDAクエリ候補を受信し、全候補で検索を実行。Phase 2 Geminiがcalculation_strategyを決定し、FDC IDを選択。決定論的で精度の高い栄養計算を提供。"
)
async def refine_meal_analysis(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    # NEW: Phase 1 出力は JSON 文字列として受け取る
    phase1_analysis_json: Annotated[str, Form(description="JSON response string from Phase 1 API.")],
    usda_service: Annotated[USDAService, Depends(get_usda_service)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)]
):
    """
    v2.1仕様：食事分析精緻化エンドポイント
    
    処理フロー:
    1. Phase 1分析結果とUSDAクエリ候補を受信
    2. 全USDAクエリ候補で並列検索を実行
    3. Phase 2 Geminiで calculation_strategy 決定とFDC ID選択
    4. calculation_strategyに基づく栄養計算
    5. 精緻化された結果を返す
    """
    # ログサービス初期化
    meal_logger = get_meal_analysis_logger()
    session_id = meal_logger.start_session(
        endpoint="/api/v1/meal-analyses/refine",
        image_filename=getattr(image, 'filename', None),
        image_size_bytes=None  # 後で設定
    )
    
    start_time = time.time()
    warnings = []
    errors = []

    try:
        # 1. Image validation (既存ロジック)
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.REQUEST_RECEIVED,
            message="Validating image file"
        )
        
        if not image.content_type or not image.content_type.startswith("image/"):
            raise HTTPException(status_code=400, detail="Invalid image file format.")
        
        try:
            image_bytes = await image.read()
            # Update image size in session
            if session_id in meal_logger.active_sessions:
                meal_logger.active_sessions[session_id].image_size_bytes = len(image_bytes)
            
            # File size check (e.g., 10MB)
            if len(image_bytes) > 10 * 1024 * 1024:
                raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
        except Exception as e:
            logger.error(f"Error reading image file: {e}")
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.REQUEST_RECEIVED,
                error_message="Failed to read image file",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail="Failed to read image file.")

        # 2. Parse Phase 1 analysis_data
        try:
            phase1_dict = json.loads(phase1_analysis_json)
            phase1_analysis = Phase1AnalysisResponse(**phase1_dict)
            
            # ログにPhase 1情報を記録
            dishes_count = len(phase1_analysis.dishes)
            usda_queries_count = sum(len(dish.usda_query_candidates) for dish in phase1_analysis.dishes)
            
            meal_logger.log_entry(
                session_id=session_id,
                level=LogLevel.INFO,
                phase=ProcessingPhase.PHASE1_COMPLETE,
                message=f"Phase 1 data received: {dishes_count} dishes, {usda_queries_count} USDA queries",
                data={
                    "dishes_count": dishes_count,
                    "usda_queries_count": usda_queries_count,
                    "phase1_output": phase1_dict
                }
            )
            
        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE1_COMPLETE,
                error_message="Failed to parse Phase 1 JSON",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail=f"Invalid Phase 1 JSON: {e}")

        # 3. Execute ALL USDA searches based on Phase 1 candidates
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.USDA_SEARCH_START,
            message="Starting USDA searches for all query candidates"
        )
        
        usda_search_start_time = time.time()
        usda_search_tasks = []
        query_map = {}  # クエリと元の料理/食材名をマッピング
        unique_queries = set()

        for dish in phase1_analysis.dishes:
            for candidate in dish.usda_query_candidates:
                if candidate.query_term not in unique_queries:
                    # NEW: search_foods_rich を使用
                    usda_search_tasks.append(usda_service.search_foods_rich(candidate.query_term))
                    query_map[candidate.query_term] = candidate.original_term or dish.dish_name
                    unique_queries.add(candidate.query_term)

        # 非同期でUSDA検索を実行
        logger.info(f"Starting {len(usda_search_tasks)} USDA searches")
        usda_search_results_list = await asyncio.gather(*usda_search_tasks, return_exceptions=True)
        usda_search_duration = (time.time() - usda_search_start_time) * 1000

        # 4. Format USDA results for Gemini prompt
        usda_candidates_prompt_segments = []
        all_usda_search_results_map: Dict[int, USDASearchResultItem] = {}  # FDC ID で引けるように
        search_term_to_results: Dict[str, List[USDASearchResultItem]] = {}  # クエリ -> 結果
        total_results_found = 0
        search_details = []

        for query, results_or_exc in zip(unique_queries, usda_search_results_list):
            original_term = query_map.get(query, query)
            if isinstance(results_or_exc, Exception):
                segment = f"Error searching USDA for '{query}' (related to '{original_term}'): {results_or_exc}\n"
                errors.append(f"USDA Search failed for {query}: {results_or_exc}")
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "error",
                    "error": str(results_or_exc)
                })
            elif not results_or_exc:
                segment = f"No USDA candidates found for '{query}' (related to '{original_term}').\n"
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "no_results"
                })
            else:
                search_term_to_results[query] = results_or_exc
                total_results_found += len(results_or_exc)
                segment = f"USDA candidates for '{query}' (related to '{original_term}'):\n"
                
                result_summaries = []
                for i, item in enumerate(results_or_exc):
                    all_usda_search_results_map[item.fdc_id] = item
                    # NEW: データタイプとブランド情報をプロンプトに含める
                    segment += (
                        f"  {i+1}. FDC ID: {item.fdc_id}, Name: {item.description} "
                        f"(Type: {item.data_type or 'N/A'}"
                        f"{f', Brand: {item.brand_owner}' if item.brand_owner else ''}), "
                        f"Score: {item.score:.2f}\n"
                        # 必要であれば ingredientsText や nutrients も一部含める
                    )
                    if item.ingredients_text:
                        segment += f"    Ingredients: {item.ingredients_text[:150]}...\n"
                    
                    result_summaries.append({
                        "fdc_id": item.fdc_id,
                        "description": item.description,
                        "data_type": item.data_type,
                        "score": item.score
                    })
                
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "success",
                    "results_count": len(results_or_exc),
                    "results": result_summaries
                })
            
            usda_candidates_prompt_segments.append(segment)

        usda_candidates_prompt_text = "\n---\n".join(usda_candidates_prompt_segments)
        
        # USDA検索結果をログに記録
        meal_logger.update_usda_search_results(
            session_id=session_id,
            duration_ms=usda_search_duration,
            queries_executed=len(unique_queries),
            results_found=total_results_found,
            search_details=search_details
        )

        # 5. Call Gemini service (Phase 2) for strategy and FDC ID selection
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.PHASE2_START,
            message="Starting Phase 2 Gemini for strategy determination and FDC ID selection"
        )
        
        phase2_start_time = time.time()
        try:
            logger.info("Calling Gemini Phase 2 for strategy determination and FDC ID selection")
            # NEW: refine_analysis_phase2 を使用
            gemini_output_dict = await gemini_service.refine_analysis_phase2(
                image_bytes=image_bytes,
                image_mime_type=image.content_type,
                phase1_output_text=phase1_analysis_json,
                usda_results_text=usda_candidates_prompt_text
            )
            gemini_phase2_response = Phase2GeminiResponse(**gemini_output_dict)
            phase2_duration = (time.time() - phase2_start_time) * 1000
            
            # Phase 2結果を解析してログに記録
            strategy_decisions = {}
            fdc_selections = {}
            for dish in gemini_phase2_response.dishes:
                strategy_decisions[dish.dish_name] = {
                    "strategy": dish.calculation_strategy,
                    "reason": dish.reason_for_strategy
                }
                fdc_selections[dish.dish_name] = {
                    "dish_fdc_id": dish.fdc_id,
                    "dish_reason": dish.reason_for_choice,
                    "ingredients": [{
                        "name": ing.ingredient_name,
                        "fdc_id": ing.fdc_id,
                        "reason": ing.reason_for_choice
                    } for ing in dish.ingredients]
                }
            
            meal_logger.update_phase2_results(
                session_id=session_id,
                duration_ms=phase2_duration,
                strategy_decisions=strategy_decisions,
                fdc_selections=fdc_selections,
                phase2_output=gemini_output_dict
            )

        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE2_START,
                error_message="Gemini Phase 2 failed",
                error_details=str(e)
            )
            raise HTTPException(status_code=503, detail=f"Gemini Phase 2 error: {e}")

        # 6. Process Gemini output and perform Nutrition Calculation
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.NUTRITION_CALC_START,
            message="Starting nutrition calculation based on Phase 2 strategy"
        )
        
        nutrition_calc_start_time = time.time()
        refined_dishes_response: List[RefinedDishResponse] = []
        nutrition_service = get_nutrition_calculation_service()  # 栄養計算サービス

        # Phase 1 の重量情報をマッピングしやすくする
        phase1_weights_map = {
            (d.dish_name, i.ingredient_name): i.weight_g
            for d in phase1_analysis.dishes
            for i in d.ingredients
        }

        for gemini_dish in gemini_phase2_response.dishes:
            # Phase 1 Dish を名前で探す (厳密にはIDなどで引くべきだが、今回は名前で)
            p1_dish = next((d for d in phase1_analysis.dishes if d.dish_name == gemini_dish.dish_name), None)
            if not p1_dish:
                warnings.append(f"Could not match Phase 2 dish '{gemini_dish.dish_name}' to Phase 1.")
                continue

            dish_total_nutrients = None
            refined_ingredients_list: List[RefinedIngredientResponse] = []
            dish_key_nutrients_100g = None

            if gemini_dish.calculation_strategy == "dish_level":
                dish_fdc_id = gemini_dish.fdc_id
                if dish_fdc_id:
                    dish_weight_g = sum(ing.weight_g for ing in p1_dish.ingredients)
                    dish_key_nutrients_100g = await usda_service.get_food_details_for_nutrition(dish_fdc_id)
                    if dish_key_nutrients_100g and dish_weight_g > 0:
                        dish_total_nutrients = nutrition_service.calculate_actual_nutrients(dish_key_nutrients_100g, dish_weight_g)
                    else:
                        warnings.append(f"Could not calculate dish-level nutrition for '{gemini_dish.dish_name}'")
                else:
                    warnings.append(f"Dish-level strategy selected for '{gemini_dish.dish_name}' but no FDC ID provided.")

                # 材料情報は説明的に残すが、栄養計算はしない (Fallback FDC ID は取得・表示)
                for gemini_ing in gemini_dish.ingredients:
                    weight = phase1_weights_map.get((gemini_dish.dish_name, gemini_ing.ingredient_name), 0.0)
                    ing_nutrients_100g = await usda_service.get_food_details_for_nutrition(gemini_ing.fdc_id) if gemini_ing.fdc_id else None
                    refined_ingredients_list.append(RefinedIngredientResponse(
                        ingredient_name=gemini_ing.ingredient_name,
                        weight_g=weight,
                        fdc_id=gemini_ing.fdc_id,  # Fallback ID
                        usda_source_description=gemini_ing.usda_source_description,
                        reason_for_choice=gemini_ing.reason_for_choice,
                        key_nutrients_per_100g=ing_nutrients_100g,
                        actual_nutrients=None  # Not calculated here
                    ))

            elif gemini_dish.calculation_strategy == "ingredient_level":
                ingredient_nutrients_list = []
                for gemini_ing in gemini_dish.ingredients:
                    weight = phase1_weights_map.get((gemini_dish.dish_name, gemini_ing.ingredient_name), 0.0)
                    ing_fdc_id = gemini_ing.fdc_id
                    ing_nutrients_100g = None
                    ing_actual_nutrients = None

                    if ing_fdc_id and weight > 0:
                        ing_nutrients_100g = await usda_service.get_food_details_for_nutrition(ing_fdc_id)
                        if ing_nutrients_100g:
                            ing_actual_nutrients = nutrition_service.calculate_actual_nutrients(ing_nutrients_100g, weight)
                            ingredient_nutrients_list.append(ing_actual_nutrients)
                        else:
                            warnings.append(f"Could not get nutrition for ingredient '{gemini_ing.ingredient_name}' (FDC ID: {ing_fdc_id})")
                    else:
                        warnings.append(f"Missing FDC ID or weight for ingredient '{gemini_ing.ingredient_name}'")

                    refined_ingredients_list.append(RefinedIngredientResponse(
                        ingredient_name=gemini_ing.ingredient_name,
                        weight_g=weight,
                        fdc_id=ing_fdc_id,
                        usda_source_description=gemini_ing.usda_source_description,
                        reason_for_choice=gemini_ing.reason_for_choice,
                        key_nutrients_per_100g=ing_nutrients_100g,
                        actual_nutrients=ing_actual_nutrients
                    ))
                # 材料から料理全体の栄養を合計
                dish_total_nutrients = nutrition_service.aggregate_nutrients_for_dish_from_ingredients(
                    [ing for ing in refined_ingredients_list if ing.actual_nutrients]  # None を除外
                )

            # RefinedDishResponse を作成
            refined_dishes_response.append(RefinedDishResponse(
                dish_name=gemini_dish.dish_name,
                type=p1_dish.type,
                quantity_on_plate=p1_dish.quantity_on_plate,
                calculation_strategy=gemini_dish.calculation_strategy,
                reason_for_strategy=gemini_dish.reason_for_strategy,
                fdc_id=gemini_dish.fdc_id,
                usda_source_description=gemini_dish.usda_source_description,
                reason_for_choice=gemini_dish.reason_for_choice,
                key_nutrients_per_100g=dish_key_nutrients_100g,
                ingredients=refined_ingredients_list,
                dish_total_actual_nutrients=dish_total_nutrients
            ))

        # 7. Calculate total meal nutrients
        total_meal_nutrients = nutrition_service.aggregate_nutrients_for_meal(
            [dish.dish_total_actual_nutrients for dish in refined_dishes_response if dish.dish_total_actual_nutrients]
        )
        
        nutrition_calc_duration = (time.time() - nutrition_calc_start_time) * 1000
        total_calories = total_meal_nutrients.calories_kcal if total_meal_nutrients else 0.0
        
        # 栄養計算結果をログに記録
        meal_logger.update_nutrition_results(
            session_id=session_id,
            duration_ms=nutrition_calc_duration,
            total_calories=total_calories,
            final_nutrition={
                "total_meal_nutrients": total_meal_nutrients.dict() if total_meal_nutrients else None,
                "dishes_count": len(refined_dishes_response),
                "warnings_count": len(warnings),
                "errors_count": len(errors)
            }
        )

        # 8. Create final response
        response = MealAnalysisRefinementResponse(
            dishes=refined_dishes_response,
            total_meal_nutrients=total_meal_nutrients,
            warnings=warnings if warnings else None,
            errors=errors if errors else None
        )
        
        # セッション終了
        meal_logger.end_session(
            session_id=session_id,
            warnings=warnings,
            errors=errors
        )
        
        return response

    except Exception as e:
        # 予期しないエラーのログ記録
        meal_logger.log_error(
            session_id=session_id,
            phase=ProcessingPhase.ERROR_OCCURRED,
            error_message="Unexpected error during request processing",
            error_details=str(e)
        )
        
        # セッション終了（エラー時）
        meal_logger.end_session(
            session_id=session_id,
            warnings=warnings,
            errors=errors + [str(e)]
        )
        
        raise 
```

============================================================

📁 サービス層
============================================================

📄 FILE: app/services/gemini_service.py
--------------------------------------------------
ファイルサイズ: 12578 bytes
最終更新: 2025-05-29 17:41:52
存在: ✅

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

# 新しいスキーマをインポート
from ..api.v1.schemas.meal import PHASE_1_GEMINI_SCHEMA, PHASE_2_GEMINI_SCHEMA, MEAL_ANALYSIS_GEMINI_SCHEMA, REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Geminiの構造化出力のためのJSONスキーマを定義
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "画像から特定された料理のリスト。",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "特定された料理の名称。"},
                    "type": {"type": "string", "description": "料理の種類（例: 主菜, 副菜, スープ, デザート）。"},
                    "quantity_on_plate": {"type": "string", "description": "皿の上に載っている料理のおおよその量や個数（例: '1杯', '2切れ', '約200g'）。"},
                    "ingredients": {
                        "type": "array",
                        "description": "この料理に含まれると推定される材料のリスト。",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "材料の名称。"},
                                "weight_g": {"type": "number", "description": "その材料の推定重量（グラム単位）。"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AI経由でGeminiを使用して食事画像を分析するクラス (v2.1対応)"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-2.5-flash-preview-05-20"):
        """
        初期化
        
        Args:
            project_id: GCPプロジェクトID
            location: Vertex AIのロケーション（例: us-central1）
            model_name: 使用するモデル名
        """
        # Vertex AIの初期化
        vertexai.init(project=project_id, location=location)
        
        # モデルの初期化
        self.model = GenerativeModel(model_name=model_name)
        
        # プロンプトローダーの初期化（必須）
        self.prompt_loader = PromptLoader()
        
        # セーフティ設定
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }

    async def analyze_image_phase1(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        Phase 1: 画像を分析し、料理・食材とUSDAクエリ候補を抽出 (v2.1仕様)
        """
        try:
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            contents = [Part.from_text(full_prompt), Part.from_data(data=image_bytes, mime_type=image_mime_type)]

            generation_config = GenerationConfig(
                temperature=0.3, # 候補を広げるために少し上げることも検討
                top_p=0.9,
                top_k=20,
                max_output_tokens=16384, # トークン制限を増やす
                response_mime_type="application/json",
                # NEW: Phase 1 用のスキーマを使用
                response_schema=PHASE_1_GEMINI_SCHEMA
            )

            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )

            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 1).")

            result = json.loads(response.text)
            logger.info(f"Gemini Phase 1 analysis completed. Found {len(result.get('dishes', []))} dishes.")
            return result

        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error (Phase 1): {e}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 1) API request failed: {e}") from e

    async def refine_analysis_phase2(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        phase1_output_text: str, # Phase 1 の生 JSON 出力
        usda_results_text: str # 整形された全 USDA 検索結果
    ) -> Dict:
        """
        Phase 2: USDA候補に基づき、calculation_strategy を決定し、FDC ID を選択 (v2.1仕様)
        """
        try:
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                initial_ai_output=phase1_output_text,
                usda_candidates=usda_results_text
            )
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            contents = [Part.from_text(full_prompt), Part.from_data(data=image_bytes, mime_type=image_mime_type)]

            generation_config = GenerationConfig(
                temperature=0.1, # 決定論的な出力を目指すため低めに設定
                top_p=0.8,
                top_k=10,
                max_output_tokens=16384, # トークン制限を増やす
                response_mime_type="application/json",
                # NEW: Phase 2 用のスキーマを使用
                response_schema=PHASE_2_GEMINI_SCHEMA
            )

            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )

            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")

            result = json.loads(response.text)
            logger.info(f"Gemini Phase 2 analysis completed. Processed {len(result.get('dishes', []))} dishes.")
            return result

        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error (Phase 2): {e}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e

    # 後方互換性のために既存メソッドも保持
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        後方互換性のための既存メソッド（既存のPhase 1として動作）
        """
        try:
            # プロンプトローダーからプロンプトを取得
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # 完全なプロンプトを構築
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # コンテンツリストを作成
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # 後方互換性のため既存スキーマを使用
            generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIを呼び出し（非同期メソッドを使用）
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )
            
            # レスポンスのテキストを取得
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSONレスポンスをパース
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        後方互換性のための既存メソッド（既存のPhase 2として動作）
        """
        try:
            # プロンプトローダーからプロンプトを取得
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                initial_ai_output=initial_ai_output_text or "{}",
                usda_candidates=usda_candidates_text
            )
            
            # 完全なプロンプトを構築
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # コンテンツリストを作成
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # フェーズ2用のGeneration Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIを呼び出し
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # レスポンスのテキストを取得
            if not response.text:
                raise ValueError("No response returned from Gemini Phase 2.")
            
            # JSONレスポンスをパース
            result = json.loads(response.text)
            
            logger.info(f"Gemini Phase 2 refinement completed successfully. Processed {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in Phase 2: {e}")
            raise RuntimeError(f"Error processing Phase 2 response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error in Phase 2: {e}")
            raise RuntimeError(f"Vertex AI/Gemini Phase 2 API request failed: {e}") from e


def get_gemini_analyzer(project_id: str, location: str, model_name: str) -> GeminiMealAnalyzer:
    """GeminiMealAnalyzerのインスタンスを作成して返す"""
    return GeminiMealAnalyzer(project_id=project_id, location=location, model_name=model_name) 
```

============================================================

📄 FILE: app/services/usda_service.py
--------------------------------------------------
ファイルサイズ: 13467 bytes
最終更新: 2025-05-29 17:39:14
存在: ✅

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings
from ..api.v1.schemas.meal import USDANutrient, USDASearchResultItem

logger = logging.getLogger(__name__)


class USDAService:
    """USDA FoodData Central APIとの通信を管理するサービスクラス"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClientの設定
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods_rich(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 10, # 候補数を増やす (設定可能に)
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central APIで食品を検索し、詳細な情報を返す (v2.1仕様)
        
        Args:
            query: 検索クエリ文字列
            data_types: データタイプのリスト（例: ["Foundation", "SR Legacy", "Branded"]）
            page_size: 1ページあたりの結果数
            page_number: 取得するページ番号
            sort_by: ソートキー
            sort_order: ソート順（"asc" または "desc"）
            
        Returns:
            USDASearchResultItemのリスト（新しいPydanticモデル）
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # データタイプをカンマ区切り文字列として渡す
            params["dataType"] = ",".join(data_types)
        
        # NEW: requireAllWords を True に設定して精度を上げることも検討 (ただしヒット数が減る)
        # params["requireAllWords"] = "true"
        
        try:
            logger.info(f"USDA API rich search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # レートリミット情報のログ
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                # NEW: foodNutrients を詳細に取得・パース
                # NOTE: 検索結果の foodNutrients は限定的なことが多い。
                # 詳細な栄養素は get_food_details_for_nutrition で取得する。
                # ここでは主に FDC ID, description, dataType, brandOwner, ingredients を重視。
                nutrients_extracted = self._extract_key_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    # NEW: ingredientsText を取得
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API rich search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods_rich: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_key_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrientsデータから主要栄養素を抽出 (新しいPydanticモデル使用)
        """
        # 主要栄養素 (configから取得) のみを抽出する
        nutrients_extracted = []
        key_numbers = self.key_nutrient_numbers # Settings から取得

        for nutrient_entry in food_nutrients:
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")

            if not nutrient_detail and "nutrientId" in nutrient_entry: # Branded abridged
                number = nutrient_entry.get("nutrientNumber")
                name = nutrient_entry.get("nutrientName")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")
                nutrient_id = nutrient_entry.get("nutrientId")
            else: # Standard
                number = nutrient_detail.get("number")
                name = nutrient_detail.get("name")
                unit_name = nutrient_detail.get("unitName")
                nutrient_id = nutrient_detail.get("id")

            if number and str(number) in key_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        return nutrients_extracted

    async def get_food_details(self, fdc_id: int) -> Optional[USDASearchResultItem]:
        """
        特定のFDC IDの食品詳細情報を取得 (新しいPydanticモデル使用)
        """
        params = {
            "api_key": self.api_key,
            "format": "full"  # ingredients も確実に取得するために format="full" を使用
        }
        
        try:
            logger.info(f"Getting USDA food details for FDC ID: {fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            if "X-RateLimit-Remaining" in response.headers:
                logger.debug(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data = response.json()
            
            # _extract_key_nutrients を使用して栄養素をパース
            nutrients_extracted = self._extract_key_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted,
                score=None  # 詳細取得時はスコアなし
            )
            
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found")
                return None
            logger.error(f"USDA API error getting food details: {e.response.status_code} - {e.response.text}")
            raise RuntimeError(f"USDA API error: {e.response.status_code}") from e
        except Exception as e:
            logger.error(f"Error getting food details for FDC ID {fdc_id}: {str(e)}")
            raise RuntimeError(f"Error getting food details: {str(e)}") from e

    async def get_food_details_for_nutrition(self, fdc_id: int) -> Optional[Dict[str, float]]:
        """
        栄養計算用の食品詳細情報を取得 (既存ロジックを維持・確認)
        """
        params = {
            "api_key": self.api_key,
            "format": "full",
            # 主要栄養素のみ取得
            "nutrients": ",".join(self.key_nutrient_numbers)
        }
        
        try:
            logger.debug(f"Getting nutrition data for FDC ID: {fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            if "X-RateLimit-Remaining" in response.headers:
                logger.debug(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data = response.json()
            
            return self._parse_nutrients_for_calculation(food_data)
            
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found for nutrition calculation")
                return None
            logger.error(f"USDA API error getting nutrition data: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"Error getting nutrition data for FDC ID {fdc_id}: {str(e)}")
            return None

    def _parse_nutrients_for_calculation(self, food_data_raw: dict) -> Dict[str, float]:
        """
        USDA APIレスポンスから栄養計算用の栄養素辞書を作成
        """
        nutrients_dict = {}
        food_nutrients = food_data_raw.get("foodNutrients", [])
        
        # 栄養素番号と標準名の対応表
        nutrient_map = {
            "208": "calories_kcal",      # Energy
            "203": "protein_g",          # Protein  
            "205": "carbohydrates_g",    # Carbohydrate
            "204": "fat_g",              # Total lipid (fat)
            "291": "fiber_g",            # Fiber, total dietary
            "269": "sugars_g",           # Sugars, total
            "307": "sodium_mg"           # Sodium
        }
        
        for nutrient_entry in food_nutrients:
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # データ構造の違いに対応
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                # Branded Foods abridged format
                number = nutrient_entry.get("nutrientNumber")
                amount = nutrient_entry.get("value")
            else:
                # Standard format
                number = nutrient_detail.get("number")
            
            if number and str(number) in nutrient_map and amount is not None:
                standard_name = nutrient_map[str(number)]
                nutrients_dict[standard_name] = float(amount)
        
        logger.debug(f"Parsed nutrients for calculation: {nutrients_dict}")
        return nutrients_dict

    # 後方互換性のために既存メソッドも保持
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List:
        """
        後方互換性のための既存search_foodsメソッド
        """
        # 新しいsearch_foods_richを呼び出して、古い形式に変換
        rich_results = await self.search_foods_rich(
            query=query,
            data_types=data_types,
            page_size=page_size,
            page_number=page_number,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        # 後方互換性のために古いUSDASearchResultItemクラス形式に変換
        # （実際の実装では、必要に応じてレガシークラスを保持する）
        return rich_results
    
    async def close_client(self):
        """HTTPクライアントのクリーンアップ"""
        if self.client:
            await self.client.aclose()


@lru_cache()
def get_usda_service():
    """USDAServiceのシングルトンインスタンスを取得"""
    return USDAService() 
```

============================================================

📁 データモデル層
============================================================

📄 FILE: app/api/v1/schemas/meal.py
--------------------------------------------------
ファイルサイズ: 17460 bytes
最終更新: 2025-05-29 17:37:41
存在: ✅

CONTENT:
```
from typing import List, Optional, Dict, Literal
from pydantic import BaseModel, Field, field_validator

# --- 共通モデル ---

class CalculatedNutrients(BaseModel):
    """計算済み栄養素モデル"""
    calories_kcal: float = Field(0.0, description="計算された総カロリー (kcal)")
    protein_g: float = Field(0.0, description="計算された総タンパク質 (g)")
    carbohydrates_g: float = Field(0.0, description="計算された総炭水化物 (g)")
    fat_g: float = Field(0.0, description="計算された総脂質 (g)")
    fiber_g: Optional[float] = Field(None, description="計算された総食物繊維 (g)")
    sugars_g: Optional[float] = Field(None, description="計算された総糖質 (g)")
    sodium_mg: Optional[float] = Field(None, description="計算された総ナトリウム (mg)")

class USDANutrient(BaseModel):
    """USDA栄養素情報モデル (USDA Serviceが返す)"""
    name: str = Field(..., description="栄養素名")
    amount: float = Field(..., description="100gまたは100mlあたりの量")
    unit_name: str = Field(..., description="単位名 (例: g, mg, kcal)")
    nutrient_id: Optional[int] = Field(None, description="USDA栄養素ID")
    nutrient_number: Optional[str] = Field(None, description="USDA栄養素番号")

class USDASearchResultItem(BaseModel):
    """USDA検索結果アイテムモデル (USDA Serviceが返す)"""
    fdc_id: int = Field(..., description="USDA FoodData Central ID")
    description: str = Field(..., description="食品の公式名称")
    data_type: Optional[str] = Field(None, description="USDAデータタイプ (例: SR Legacy, Branded)")
    brand_owner: Optional[str] = Field(None, description="ブランド所有者 (Branded Foodsの場合)")
    ingredients_text: Optional[str] = Field(None, description="原材料リスト文字列 (Branded/FNDDSの場合, **Assumption: String**)")
    food_nutrients: List[USDANutrient] = Field(default_factory=list, description="主要な栄養素情報のリスト")
    score: Optional[float] = Field(None, description="検索結果の関連度スコア")

# --- Phase 1 Gemini 出力モデル ---

class USDACandidateQuery(BaseModel):
    """Phase 1でGeminiが出力するUSDAクエリ候補"""
    query_term: str = Field(..., description="USDA検索に使用する具体的なクエリ文字列 (英語)")
    granularity_level: Literal["dish", "ingredient", "branded_product"] = Field(..., description="このクエリが対象とする粒度レベル")
    original_term: str = Field("", description="このクエリが由来する元の料理名または食材名")
    reason_for_query: str = Field("", description="このクエリ候補を生成した簡単な理由")

class Phase1Ingredient(BaseModel):
    """Phase 1 材料モデル"""
    ingredient_name: str = Field(..., description="材料の名称 (英語)")
    weight_g: float = Field(..., description="推定重量（グラム単位）", ge=0.1)

class Phase1Dish(BaseModel):
    """Phase 1 料理モデル"""
    dish_name: str = Field(..., description="特定された料理の名称 (英語)")
    type: str = Field(..., description="料理の種類（例: Main course, Side dish）")
    quantity_on_plate: str = Field(..., description="皿の上の量や個数")
    ingredients: List[Phase1Ingredient] = Field(..., description="含まれる材料のリスト")
    # NEW: Phase 1でクエリ候補を出力
    usda_query_candidates: List[USDACandidateQuery] = Field(..., description="この料理/食材に関連するUSDAクエリ候補リスト")

class Phase1AnalysisResponse(BaseModel):
    """Phase 1 食事分析レスポンスモデル"""
    dishes: List[Phase1Dish] = Field(..., description="画像から特定された料理のリスト")

# --- Phase 2 Gemini 出力モデル (Gemini向けスキーマ) ---

class RefinedIngredientGeminiOutput(BaseModel):
    """Phase 2 Gemini出力用 - 材料モデル"""
    ingredient_name: str = Field(..., description="材料の名称 (英語)。Phase 1から引き継ぎ、必要なら修正。")
    fdc_id: Optional[int] = Field(None, description="選択されたFDC ID。ingredient_levelの場合、またはdish_levelのFallback時に設定。")
    usda_source_description: Optional[str] = Field(None, description="選択されたFDC IDの公式名称。")
    reason_for_choice: Optional[str] = Field(None, description="このFDC IDを選択した理由、または選択しなかった理由。")

class RefinedDishGeminiOutput(BaseModel):
    """Phase 2 Gemini出力用 - 料理モデル"""
    dish_name: str = Field(..., description="料理の名称 (英語)。Phase 1から引き継ぎ、必要なら修正。")
    calculation_strategy: Literal["dish_level", "ingredient_level"] = Field(..., description="この料理の栄養計算方針。")
    reason_for_strategy: str = Field(..., description="この計算戦略を選択した理由。")
    fdc_id: Optional[int] = Field(None, description="dish_levelの場合に選択されたFDC ID。")
    usda_source_description: Optional[str] = Field(None, description="dish_levelの場合に選択されたFDC IDの公式名称。")
    reason_for_choice: Optional[str] = Field(None, description="dish_levelの場合、このFDC IDを選択した理由。")
    ingredients: List[RefinedIngredientGeminiOutput] = Field(..., description="材料リスト。各材料についてFDC IDと選択理由を記述。")

class Phase2GeminiResponse(BaseModel):
    """Phase 2 Gemini出力用 - 全体モデル"""
    dishes: List[RefinedDishGeminiOutput] = Field(..., description="精緻化された料理リスト。")

# --- Phase 2 API 出力モデル (最終レスポンス) ---

class RefinedIngredientResponse(BaseModel):
    """Phase 2 API出力用 - 材料モデル"""
    ingredient_name: str
    weight_g: float
    fdc_id: Optional[int]
    usda_source_description: Optional[str]
    reason_for_choice: Optional[str] # From Gemini
    key_nutrients_per_100g: Optional[Dict[str, float]] # From USDA Service
    actual_nutrients: Optional[CalculatedNutrients] # From Nutrition Calculation

class RefinedDishResponse(BaseModel):
    """Phase 2 API出力用 - 料理モデル"""
    dish_name: str
    type: str # From Phase 1
    quantity_on_plate: str # From Phase 1
    calculation_strategy: Literal["dish_level", "ingredient_level"] # From Gemini
    reason_for_strategy: Optional[str] # From Gemini
    fdc_id: Optional[int] # From Gemini (dish_level)
    usda_source_description: Optional[str] # From Gemini (dish_level)
    reason_for_choice: Optional[str] # From Gemini (dish_level)
    key_nutrients_per_100g: Optional[Dict[str, float]] # From USDA Service (dish_level)
    ingredients: List[RefinedIngredientResponse]
    dish_total_actual_nutrients: Optional[CalculatedNutrients] # From Nutrition Calculation

class MealAnalysisRefinementResponse(BaseModel):
    """Phase 2 食事分析精緻化レスポンスモデル"""
    dishes: List[RefinedDishResponse]
    total_meal_nutrients: Optional[CalculatedNutrients]
    warnings: Optional[List[str]] = Field(None, description="処理中に発生した警告メッセージ。")
    errors: Optional[List[str]] = Field(None, description="処理中に発生したエラーメッセージ。")

# --- 後方互換性のために既存モデルも保持 ---

class Ingredient(BaseModel):
    """材料情報モデル (既存API用)"""
    ingredient_name: str = Field(..., description="材料の名称")
    weight_g: float = Field(..., description="推定重量（グラム単位）", ge=0.1)

class Dish(BaseModel):
    """料理情報モデル (既存API用)"""
    dish_name: str = Field(..., description="特定された料理の名称")
    type: str = Field(..., description="料理の種類（例: 主菜, 副菜, スープ）")
    quantity_on_plate: str = Field(..., description="皿の上に載っている料理のおおよその量や個数")
    ingredients: List[Ingredient] = Field(..., description="その料理に含まれる材料のリスト")

class MealAnalysisResponse(BaseModel):
    """食事分析レスポンスモデル (既存API用)"""
    dishes: List[Dish] = Field(..., description="画像から特定された料理のリスト")

class ErrorResponse(BaseModel):
    """エラーレスポンスモデル"""
    error: dict = Field(..., description="エラー情報")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": {
                    "code": "INVALID_INPUT", 
                    "message": "提供された画像ファイル形式はサポートされていません。"
                }
            }
        }

# --- 後方互換性のエイリアス ---
InitialAnalysisIngredient = Ingredient  
InitialAnalysisDish = Dish  
InitialAnalysisData = MealAnalysisResponse  

# --- RefinedIngredient/RefinedDish は RefinedIngredientResponse/RefinedDishResponse へのエイリアス ---
RefinedIngredient = RefinedIngredientResponse
RefinedDish = RefinedDishResponse

# --- Gemini向けJSONスキーマ定義 (手動で修正) ---

# Phase 1 Schema - 手動で定義してGemini API互換にする
PHASE_1_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "画像から特定された料理のリスト",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "特定された料理の名称 (英語)"},
                    "type": {"type": "string", "description": "料理の種類（例: Main course, Side dish）"},
                    "quantity_on_plate": {"type": "string", "description": "皿の上の量や個数"},
                    "ingredients": {
                        "type": "array",
                        "description": "含まれる材料のリスト",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "材料の名称 (英語)"},
                                "weight_g": {"type": "number", "description": "推定重量（グラム単位）", "minimum": 0.1}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    },
                    "usda_query_candidates": {
                        "type": "array",
                        "description": "この料理/食材に関連するUSDAクエリ候補リスト",
                        "items": {
                            "type": "object",
                            "properties": {
                                "query_term": {"type": "string", "description": "USDA検索に使用する具体的なクエリ文字列 (英語)"},
                                "granularity_level": {
                                    "type": "string",
                                    "enum": ["dish", "ingredient", "branded_product"],
                                    "description": "このクエリが対象とする粒度レベル"
                                },
                                "original_term": {"type": "string", "description": "このクエリが由来する元の料理名または食材名"},
                                "reason_for_query": {"type": "string", "description": "このクエリ候補を生成した簡単な理由"}
                            },
                            "required": ["query_term", "granularity_level", "original_term", "reason_for_query"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients", "usda_query_candidates"]
            }
        }
    },
    "required": ["dishes"]
}

# Phase 2 Schema - 手動で定義してGemini API互換にする
PHASE_2_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "精緻化された料理リスト",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "料理の名称 (英語)。Phase 1から引き継ぎ、必要なら修正。"},
                    "calculation_strategy": {
                        "type": "string",
                        "enum": ["dish_level", "ingredient_level"],
                        "description": "この料理の栄養計算方針"
                    },
                    "reason_for_strategy": {"type": "string", "description": "この計算戦略を選択した理由"},
                    "fdc_id": {"type": "integer", "description": "dish_levelの場合に選択されたFDC ID"},
                    "usda_source_description": {"type": "string", "description": "dish_levelの場合に選択されたFDC IDの公式名称"},
                    "reason_for_choice": {"type": "string", "description": "dish_levelの場合、このFDC IDを選択した理由"},
                    "ingredients": {
                        "type": "array",
                        "description": "材料リスト。各材料についてFDC IDと選択理由を記述",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "材料の名称 (英語)。Phase 1から引き継ぎ、必要なら修正"},
                                "fdc_id": {"type": "integer", "description": "選択されたFDC ID。ingredient_levelの場合、またはdish_levelのFallback時に設定"},
                                "usda_source_description": {"type": "string", "description": "選択されたFDC IDの公式名称"},
                                "reason_for_choice": {"type": "string", "description": "このFDC IDを選択した理由、または選択しなかった理由"}
                            },
                            "required": ["ingredient_name"]
                        }
                    }
                },
                "required": ["dish_name", "calculation_strategy", "reason_for_strategy", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}

# 後方互換性のために既存スキーマも保持
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "画像から特定された料理のリスト。",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "特定された料理の名称。"},
                    "type": {"type": "string", "description": "料理の種類（例: 主菜, 副菜, スープ, デザート）。"},
                    "quantity_on_plate": {"type": "string", "description": "皿の上に載っている料理のおおよその量や個数（例: '1杯', '2切れ', '約200g'）。"},
                    "ingredients": {
                        "type": "array",
                        "description": "この料理に含まれると推定される材料のリスト。",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "材料の名称。"},
                                "weight_g": {"type": "number", "description": "その材料の推定重量（グラム単位）。"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    },
                    "usda_query_candidates": {
                        "type": "array",
                        "description": "この料理/食材に関連するUSDAクエリ候補リスト。",
                        "items": {
                            "type": "object",
                            "properties": {
                                "query_term": {"type": "string", "description": "USDA検索に使用する具体的なクエリ文字列 (英語)"},
                                "granularity_level": {
                                    "type": "string", 
                                    "enum": ["dish", "ingredient", "branded_product"],
                                    "description": "このクエリが対象とする粒度レベル"
                                },
                                "original_term": {"type": "string", "description": "このクエリが由来する元の料理名または食材名"},
                                "reason_for_query": {"type": "string", "description": "このクエリ候補を生成した簡単な理由"}
                            },
                            "required": ["query_term", "granularity_level"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients", "usda_query_candidates"]
            }
        }
    },
    "required": ["dishes"]
}

REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA = PHASE_2_GEMINI_SCHEMA 
```

============================================================

📁 設定管理
============================================================

📄 FILE: app/core/config.py
--------------------------------------------------
ファイルサイズ: 2180 bytes
最終更新: 2025-05-29 16:07:57
存在: ✅

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    API設定クラス
    環境変数から設定値を読み込む
    """
    # Vertex AI設定
    GEMINI_PROJECT_ID: str  # GCPプロジェクトID（必須）
    GEMINI_LOCATION: str = "us-central1"  # デフォルトのロケーション
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA API設定
    USDA_API_KEY: str  # USDA FoodData Central APIキー（必須）
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # APIタイムアウト秒数
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1回の検索で取得する最大候補数
    # 主要栄養素番号（カンマ区切り文字列として環境変数から読み込む）
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """主要栄養素番号のリストを返す"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # キャッシュ設定
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redisを使用する場合のURL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDAレスポンスのキャッシュ有効期間（1時間）
    
    # API設定
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # サーバー設定
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # APIバージョン
    API_VERSION: str = "v1"
    
    # Google Cloud認証設定
    # GOOGLE_APPLICATION_CREDENTIALSは通常環境変数で設定するため、ここでは不要
    # gcloud auth application-default login でも可
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    設定インスタンスを取得（キャッシュされる）
    """
    return Settings() 
```

============================================================

📁 プロンプト管理
============================================================

📄 FILE: app/prompts/__init__.py
--------------------------------------------------
ファイルサイズ: 114 bytes
最終更新: 2025-05-29 16:07:57
存在: ✅

CONTENT:
```
"""
プロンプト管理モジュール
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

📄 FILE: app/prompts/prompt_loader.py
--------------------------------------------------
ファイルサイズ: 4029 bytes
最終更新: 2025-05-29 17:41:19
存在: ✅

CONTENT:
```
"""
プロンプトファイルを読み込んで管理するモジュール
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """プロンプトファイルを読み込んで管理するクラス"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        初期化
        
        Args:
            prompts_dir: プロンプトファイルが格納されているディレクトリパス
                        Noneの場合は現在のファイルと同じディレクトリを使用
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # プロンプトをキャッシュ
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        プロンプトファイルを読み込む
        
        Args:
            filename: プロンプトファイル名
            
        Returns:
            プロンプトの内容
            
        Raises:
            FileNotFoundError: ファイルが見つからない場合
            IOError: ファイル読み込みエラー
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """フェーズ1のシステムプロンプトを取得"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        フェーズ1のユーザープロンプトを取得
        
        Args:
            optional_text: オプションのテキスト
            
        Returns:
            フォーマット済みのユーザープロンプト
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """フェーズ2のシステムプロンプトを取得"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        initial_ai_output: str,
        usda_candidates: str
    ) -> str:
        """
        フェーズ2のユーザープロンプトを取得
        
        Args:
            initial_ai_output: フェーズ1のAI出力（JSON文字列）
            usda_candidates: USDA候補情報
            
        Returns:
            フォーマット済みのユーザープロンプト
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        return template.format(
            initial_ai_output=initial_ai_output,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """プロンプトキャッシュをクリアして再読み込みを促す"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

📁 プロンプトテンプレート
============================================================

📄 FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
ファイルサイズ: 2004 bytes
最終更新: 2025-05-29 17:15:57
存在: ✅

CONTENT:
```
You are an expert culinary analyst and food database specialist. Your primary task is to analyze meal images and identify potential dishes and ingredients, focusing on generating *effective query terms for the USDA FoodData Central database*.

**Your Goals:**

1.  **Identify Dishes & Ingredients:** Recognize distinct dishes and their likely core ingredients from the image.
2.  **Estimate Weights:** Provide a reasonable weight estimate (in grams) for each ingredient.
3.  **Generate USDA Query Candidates:** This is CRITICAL. For each identified dish AND its key ingredients, suggest *multiple, plausible query terms* in English that are likely to yield good results in the USDA FoodData Central database.
    * **Think like a database search:** Consider common names, specific names, and *especially Branded Food names* if recognizable packaging or product types are visible.
    * **Consider Granularity:** Provide queries at different levels:
        * `dish`: For the whole dish (e.g., "Lasagna", "Tuna Salad Sandwich").
        * `ingredient`: For core components (e.g., "Ground Beef", "Cheddar Cheese", "Tuna, canned in oil", "Whole wheat bread").
        * `branded_product`: If a specific brand or product is likely (e.g., "Kraft Macaroni & Cheese", "Hellmann's Real Mayonnaise", "StarKist Chunk Light Tuna in Oil").
    * **Prioritize USDA Likelihood:** Avoid overly generic terms ("Sauce", "Seasoning") or terms unlikely to be in USDA (e.g., "Homemade Dashi Broth"). Focus on searchable food items.
    * **Provide Reasons:** Briefly explain why each query term is suggested.
4.  **Output Format:** Strictly adhere to the provided JSON schema (`Phase1AnalysisResponse`).
5.  **Language:** ALL text outputs MUST be in English.

**Instructions:**

* Analyze the provided image carefully.
* For each dish, list its name, type, quantity, and ingredients (with weights).
* For each dish, provide a list of `USDACandidateQuery` objects.
* Ensure your JSON output is valid according to the schema. 
```

============================================================

📄 FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
ファイルサイズ: 86 bytes
最終更新: 2025-05-29 16:53:14
存在: ✅

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

📄 FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
ファイルサイズ: 3717 bytes
最終更新: 2025-05-29 17:18:17
存在: ✅

CONTENT:
```
You are an advanced Nutritional Analysis Strategist and USDA Data Matcher. Your mission is to analyze an initial meal assessment and a comprehensive list of USDA FoodData Central (FDC) search results to determine the *optimal strategy for nutritional calculation* for each dish and select the *most accurate FDC IDs*. Your decisions must be **deterministic** and aimed at maximizing **accuracy and stability**.

**Your Core Tasks for EACH Dish:**

1.  **Determine `calculation_strategy`:** Choose either `"dish_level"` or `"ingredient_level"`.
    * **`dish_level`:** Use when a *single, representative FDC ID* accurately describes the *entire dish* and its likely nutritional profile. This is often suitable for:
        * **Specific Branded Products:** If a high-confidence match exists (e.g., "McDonald's Big Mac", "Stouffer's Lasagna"). **Prioritize Branded Foods if a strong match exists.**
        * **Simple, Standardized Items:** If a good Foundation or SR Legacy match exists (e.g., "Apple", "Chicken Breast, grilled", "Milk, 2%").
        * **Standardized Recipes in FNDDS/SR Legacy:** If a *good* FNDDS or SR Legacy entry exists for a common prepared dish (e.g., "Macaroni and Cheese, prepared").
    * **`ingredient_level`:** Use when the dish is complex, highly variable, homemade, or lacks a suitable single FDC ID. This is often suitable for:
        * **Salads, Stir-fries, Stews, Casseroles:** Dishes with many variable components.
        * **Standardized dishes *without* a good FDC match:** If the available dish-level FDC IDs seem inaccurate.
        * When *breaking down* provides higher accuracy (e.g., a specific sandwich where you can identify bread, meat, cheese, and sauce FDC IDs).
    * **Provide `reason_for_strategy`:** Clearly explain *why* you chose this strategy based on the dish and the available USDA data.

2.  **Select FDC IDs:**
    * **If `dish_level`:**
        * Select the *single best FDC ID* for the *entire dish* from the provided USDA candidates.
        * Provide this as the dish `fdc_id` and `usda_source_description`.
        * Provide `reason_for_choice` for this FDC ID.
        * For *each ingredient* listed in the initial analysis, *still attempt to find a plausible FDC ID* and list it. This serves as a **fallback/verification** mechanism, but these FDC IDs *won't* be used for the primary calculation in this strategy. Provide a reason for each ingredient FDC ID selection.
    * **If `ingredient_level`:**
        * Set the dish `fdc_id` and `usda_source_description` to `null`.
        * For *each ingredient*, select the *single best FDC ID* from the provided USDA candidates for that ingredient.
        * Provide these as the `fdc_id` and `usda_source_description` for each ingredient.
        * Provide `reason_for_choice` for each FDC ID selection. If no good match exists, set FDC ID to `null` and explain why.

**FDC ID Selection Guidelines:**

* **Prioritize:** 1. Branded (if strong match) -> 2. Foundation -> 3. SR Legacy -> 4. FNDDS.
* **Relevance:** Choose the ID that best matches the *context* (image, initial name) and has a high score/good description.
* **Data Type:** Consider the nature of the USDA type. Foundation is analytical, SR/FNDDS can be averaged/calculated, Branded is label-based.
* **Ingredients Text (Branded/FNDDS):** Use this to verify if a Branded/FNDDS entry is a reasonable match.

**Output Requirements:**

* Strictly adhere to the provided JSON schema (`Phase2GeminiResponse`).
* Include all required fields, especially `calculation_strategy`, `reason_for_strategy`, `fdc_id`, `usda_source_description`, and `reason_for_choice`.
* ALL text outputs MUST be in English.
* DO NOT perform any nutritional calculations. 
```

============================================================

📄 FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
ファイルサイズ: 820 bytes
最終更新: 2025-05-29 17:18:37
存在: ✅

CONTENT:
```
Here is the initial meal analysis (Phase 1 Output):
```json
{initial_ai_output}
```

Here are the potential USDA FDC ID candidates based on queries from Phase 1. Review these carefully, noting the FDC ID, Name, Data Type, Brand, and Score:

{usda_candidates}

Based on the initial analysis, the image context (implicitly known from Phase 1), and ALL the provided USDA candidates, please perform the Phase 2 refinement as per the system instructions. For each dish:

1. Decide the calculation_strategy.
2. Provide the reason_for_strategy.
3. Select the best FDC ID(s) according to the chosen strategy.
4. Provide the usda_source_description for each selected FDC ID.
5. Provide the reason_for_choice for each selected FDC ID.

Ensure your response is in English and strictly follows the Phase2GeminiResponse JSON schema. 
```

============================================================

🎯 SUMMARY
----------------------------------------
総ファイル数: 14
存在ファイル数: 14
分析完了時刻: 2025-05-29 18:32:59

このファイルには、test_english_phase2.py実行時に関わる全ての
アプリケーションファイルの完全な内容が含まれています。
