================================================================================
MEAL ANALYSIS API - ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ§‹é€ ã¨ãƒ•ã‚¡ã‚¤ãƒ«åˆ†æ
================================================================================
ç”Ÿæˆæ—¥æ™‚: 2025-05-29 18:32:59
åˆ†æå¯¾è±¡: test_english_phase2.py å®Ÿè¡Œæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹å…¨ãƒ•ã‚¡ã‚¤ãƒ«
================================================================================

ğŸ“Š ARCHITECTURE OVERVIEW
----------------------------------------

ğŸ”„ EXECUTION FLOW (2-Phase Approach):
Phase 1: ç”»åƒ â†’ Gemini AI â†’ æ–™ç†ãƒ»é£Ÿæè­˜åˆ¥ (è‹±èªå)
Phase 2: Phase1çµæœ + ç”»åƒ â†’ USDAæ¤œç´¢ â†’ Geminiå†åˆ†æ â†’ æ „é¤Šæˆåˆ†ç²¾ç·»åŒ–

ğŸ—ï¸ LAYER STRUCTURE:
â”œâ”€â”€ APIå±¤ (FastAPI)
â”‚   â”œâ”€â”€ meal_analyses.py (Phase 1 endpoint)
â”‚   â””â”€â”€ meal_analyses_refine.py (Phase 2 endpoint)
â”œâ”€â”€ ã‚µãƒ¼ãƒ“ã‚¹å±¤
â”‚   â”œâ”€â”€ gemini_service.py (Vertex AI Geminié€£æº)
â”‚   â””â”€â”€ usda_service.py (USDA FoodData Central APIé€£æº)
â”œâ”€â”€ ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å±¤
â”‚   â””â”€â”€ meal.py (Pydantic schemas)
â”œâ”€â”€ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†å±¤
â”‚   â”œâ”€â”€ prompt_loader.py (Template management)
â”‚   â””â”€â”€ prompt templates (*.txt)
â””â”€â”€ è¨­å®šå±¤
    â””â”€â”€ config.py (Environment configuration)

ğŸ”§ TECHNICAL FEATURES:
- éåŒæœŸå‡¦ç† (async/await)
- æ§‹é€ åŒ–JSONå‡ºåŠ› (Gemini response_schema)
- USDAæ „é¤Šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é€£æº
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½
- åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

================================================================================

ğŸ“ ãƒ¡ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
============================================================

ğŸ“„ FILE: test_english_phase2.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 2808 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:53:14
å­˜åœ¨: âœ…

CONTENT:
```
import requests
import json
import asyncio
import httpx

# APIè¨­å®š
BASE_URL = "http://localhost:8000/api/v1"

# ãƒ†ã‚¹ãƒˆç”»åƒã®ãƒ‘ã‚¹ï¼ˆè‹±èªã®é£Ÿæåã‚’å«ã‚€ç”»åƒã‚’ä½¿ç”¨ï¼‰
image_path = "test_images/food3.jpg"

async def run_phase1_and_phase2():
    """ãƒ•ã‚§ãƒ¼ã‚º1â†’ãƒ•ã‚§ãƒ¼ã‚º2ã®æµã‚Œã‚’ãƒ†ã‚¹ãƒˆ"""
    
    print("=== Phase 1: Initial Analysis ===")
    
    # ãƒ•ã‚§ãƒ¼ã‚º1: ç”»åƒåˆ†æ
    with open(image_path, "rb") as f:
        files = {"image": ("food3.jpg", f, "image/jpeg")}
        response = requests.post(f"{BASE_URL}/meal-analyses", files=files)
    
    if response.status_code != 200:
        print(f"Phase 1 failed: {response.status_code}")
        print(response.text)
        return
    
    phase1_result = response.json()
    print("Phase 1 successful!")
    print(json.dumps(phase1_result, indent=2))
    
    # é£Ÿæåã‚’è¡¨ç¤ºï¼ˆè‹±èªã«ãªã£ã¦ã„ã‚‹ã¯ãšï¼‰
    print("\nDetected ingredients:")
    for dish in phase1_result.get("dishes", []):
        print(f"  Dish: {dish['dish_name']}")
        for ingredient in dish.get("ingredients", []):
            print(f"    - {ingredient['ingredient_name']}: {ingredient['weight_g']}g")
    
    print("\n=== Phase 2: USDA Refinement ===")
    
    # ãƒ•ã‚§ãƒ¼ã‚º2: USDAç²¾ç·»åŒ–
    with open(image_path, "rb") as f:
        files = {
            "image": ("food3.jpg", f, "image/jpeg"),
            "initial_analysis_data": (None, json.dumps(phase1_result), "application/json")
        }
        response = requests.post(f"{BASE_URL}/meal-analyses/refine", files=files)
    
    print(f"Phase 2 status: {response.status_code}")
    
    if response.status_code == 200:
        phase2_result = response.json()
        print("Phase 2 successful!")
        print(json.dumps(phase2_result, indent=2))
        
        # USDA FDC IDã‚’è¡¨ç¤º
        print("\nUSDA matches:")
        for dish in phase2_result.get("dishes", []):
            print(f"  Dish: {dish['dish_name']}")
            for ingredient in dish.get("ingredients", []):
                if ingredient.get("fdc_id"):
                    print(f"    - {ingredient['ingredient_name']}: FDC ID {ingredient['fdc_id']} ({ingredient.get('usda_source_description', 'N/A')})")
                else:
                    print(f"    - {ingredient['ingredient_name']}: No USDA match")
                    
                # æ „é¤Šç´ æƒ…å ±ã‚’è¡¨ç¤º
                nutrients = ingredient.get("key_nutrients_per_100g", {})
                if nutrients:
                    print(f"      Nutrients per 100g: {nutrients}")
    else:
        print("Phase 2 failed!")
        print(response.text)

if __name__ == "__main__":
    print("Testing Meal Analysis API (English version)")
    print(f"Using image: {image_path}")
    asyncio.run(run_phase1_and_phase2()) 
```

============================================================

ğŸ“ API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå±¤
============================================================

ğŸ“„ FILE: app/main.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 3235 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:07:57
å­˜åœ¨: âœ…

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine
from .core.config import get_settings

# ãƒ­ã‚®ãƒ³ã‚°ã®è¨­å®š
logging.basicConfig(
    level=logging.DEBUG,  # ä¸€æ™‚çš„ã«DEBUGãƒ¬ãƒ™ãƒ«ã«å¤‰æ›´
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)

# è¨­å®šã®å–å¾—
settings = get_settings()

# FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä½œæˆ
app = FastAPI(
    title="é£Ÿäº‹åˆ†æAPI (Meal Analysis API)",
    description="é£Ÿäº‹ã®ç”»åƒã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æã—ã€æ–™ç†ã¨ææ–™ã‚’ç‰¹å®šã™ã‚‹APIã€‚USDAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã®é€£æºã«ã‚ˆã‚Šæ „é¤Šä¾¡è¨ˆç®—ã®ç²¾åº¦ã‚’å‘ä¸Šã€‚",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORSãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®è¨­å®šï¼ˆé–‹ç™ºç’°å¢ƒç”¨ï¼‰
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # æœ¬ç•ªç’°å¢ƒã§ã¯é©åˆ‡ã«åˆ¶é™ã™ã‚‹
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
@app.get("/")
async def root():
    """APIã®ãƒ«ãƒ¼ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""
    return {
        "message": "é£Ÿäº‹åˆ†æAPI (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
@app.get("/health")
async def health_check():
    """APIã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 APIãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API ãƒ•ã‚§ãƒ¼ã‚º2ãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²ï¼ˆ/refineã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼‰
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
@app.on_event("startup")
async def startup_event():
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã®å‡¦ç†"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
@app.on_event("shutdown")
async def shutdown_event():
    """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†"""
    logger.info("Meal Analysis API shutting down...")

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "å†…éƒ¨ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
            }
        }
    ) 
```

============================================================

ğŸ“„ FILE: app/api/v1/endpoints/meal_analyses.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 7582 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:57:41
å­˜åœ¨: âœ…

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, Optional
import logging
import time  # å®Ÿè¡Œæ™‚é–“æ¸¬å®šã®ãŸã‚

from ....services.gemini_service import GeminiMealAnalyzer
from ..schemas.meal import Phase1AnalysisResponse, MealAnalysisResponse, ErrorResponse
from ....services.logging_service import get_meal_analysis_logger, ProcessingPhase, LogLevel
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
_gemini_analyzer = None


async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ï¼‰
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "",
    response_model=Phase1AnalysisResponse,
    summary="Analyze Meal Image (Phase 1 v2.1)",
    description="v2.1: é£Ÿäº‹ç”»åƒã‚’åˆ†æã—ã€æ–™ç†ãƒ»é£Ÿæè­˜åˆ¥ã¨USDAã‚¯ã‚¨ãƒªå€™è£œç”Ÿæˆã‚’è¡Œã„ã¾ã™ã€‚"
)
async def analyze_meal_v2_1(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    optional_text: Annotated[Optional[str], None] = None
):
    """
    v2.1ä»•æ§˜ï¼šé£Ÿäº‹ç”»åƒã®åŸºæœ¬åˆ†æ
    
    å‡¦ç†ãƒ•ãƒ­ãƒ¼:
    1. ç”»åƒã®åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    2. Gemini AI ã«ã‚ˆã‚‹é£Ÿäº‹åˆ†æï¼ˆPhase 1ï¼‰
    3. USDAã‚¯ã‚¨ãƒªå€™è£œã®ç”Ÿæˆ
    4. çµæœè¿”å´
    """
    # ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
    meal_logger = get_meal_analysis_logger()
    session_id = meal_logger.start_session(
        endpoint="/api/v1/meal-analyses",
        image_filename=getattr(image, 'filename', None),
        image_size_bytes=None  # å¾Œã§è¨­å®š
    )
    
    start_time = time.time()
    
    try:
        # 1. Image validation
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.REQUEST_RECEIVED,
            message="Starting Phase 1 meal analysis"
        )
        
        if not image.content_type or not image.content_type.startswith("image/"):
            raise HTTPException(status_code=400, detail="Invalid image file format.")
        
        try:
            image_bytes = await image.read()
            # Update image size in session
            if session_id in meal_logger.active_sessions:
                meal_logger.active_sessions[session_id].image_size_bytes = len(image_bytes)
            
            # File size check (e.g., 10MB)
            if len(image_bytes) > 10 * 1024 * 1024:
                raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
        except Exception as e:
            logger.error(f"Error reading image file: {e}")
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.REQUEST_RECEIVED,
                error_message="Failed to read image file",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail="Failed to read image file.")

        # 2. Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å–å¾—
        gemini_service = await get_gemini_analyzer(settings)

        # 3. Call Gemini service (Phase 1)
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.PHASE1_START,
            message="Starting Gemini Phase 1 analysis"
        )
        
        phase1_start_time = time.time()
        try:
            result = await gemini_service.analyze_image_phase1(
                image_bytes=image_bytes,
                image_mime_type=image.content_type,
                optional_text=optional_text
            )
            phase1_duration = (time.time() - phase1_start_time) * 1000
            
            # Phase 1çµæœã‚’ãƒ­ã‚°ã«è¨˜éŒ²
            dishes_count = len(result.get('dishes', []))
            usda_queries_count = sum(
                len(dish.get('usda_query_candidates', [])) 
                for dish in result.get('dishes', [])
            )
            
            meal_logger.update_phase1_results(
                session_id=session_id,
                duration_ms=phase1_duration,
                dishes_count=dishes_count,
                usda_queries_count=usda_queries_count,
                phase1_output=result
            )
            
        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE1_START,
                error_message="Gemini Phase 1 analysis failed",
                error_details=str(e)
            )
            raise HTTPException(status_code=503, detail=f"Gemini API error: {e}")

        # 4. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä½œæˆã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†
        response = Phase1AnalysisResponse(**result)
        
        meal_logger.end_session(
            session_id=session_id,
            warnings=None,
            errors=None
        )
        
        return response
        
    except Exception as e:
        # äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã®ãƒ­ã‚°è¨˜éŒ²
        meal_logger.log_error(
            session_id=session_id,
            phase=ProcessingPhase.ERROR_OCCURRED,
            error_message="Unexpected error during Phase 1 processing",
            error_details=str(e)
        )
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰
        meal_logger.end_session(
            session_id=session_id,
            warnings=None,
            errors=[str(e)]
        )
        
        raise


# å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã€å¤ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚ç¶­æŒ
@router.post(
    "/legacy",
    response_model=MealAnalysisResponse,
    summary="Legacy Meal Analysis (v1.0 compatibility)",
    description="å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‚æ–°ã—ã„æ©Ÿèƒ½ã«ã¯ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ `/` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"
)
async def analyze_meal_legacy(
    image: Annotated[UploadFile, File(description="Meal image file to analyze.")],
    settings: Annotated[Settings, Depends(get_settings)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)],
    optional_text: Annotated[Optional[str], Form(description="Optional additional information about the meal.")] = None
):
    """
    å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®æ—§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    """
    # åŒã˜æ¤œè¨¼ã‚’å®Ÿè¡Œ
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Invalid image file format.")
    
    image_bytes = await image.read()
    if len(image_bytes) > 10 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="File too large.")
    
    try:
        # æ—§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
        analysis_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_bytes,
            image_mime_type=image.content_type,
            optional_text=optional_text
        )
        
        response = MealAnalysisResponse(**analysis_result)
        return response
        
    except Exception as e:
        logger.error(f"Legacy analysis error: {e}")
        raise HTTPException(status_code=500, detail=str(e)) 
```

============================================================

ğŸ“„ FILE: app/api/v1/endpoints/meal_analyses_refine.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 21048 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:57:01
å­˜åœ¨: âœ…

CONTENT:
```
from fastapi import APIRouter, File, Form, UploadFile, HTTPException, Depends
from typing import Annotated, List, Optional, Dict
import json
import logging
import asyncio  # éåŒæœŸå‡¦ç†ã®ãŸã‚
import time  # å®Ÿè¡Œæ™‚é–“æ¸¬å®šã®ãŸã‚

# æ–°ã—ã„Pydanticãƒ¢ãƒ‡ãƒ«
from ..schemas.meal import (
    Phase1AnalysisResponse,  # Phase 1 å‡ºåŠ›ã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨
    Phase2GeminiResponse,    # Phase 2 Geminiå‡ºåŠ›ã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨
    MealAnalysisRefinementResponse,
    USDASearchResultItem,
    RefinedDishResponse,
    RefinedIngredientResponse,
    CalculatedNutrients
)

# ã‚µãƒ¼ãƒ“ã‚¹
from ....services.usda_service import USDAService, get_usda_service
from ....services.gemini_service import GeminiMealAnalyzer
from ....services.nutrition_calculation_service import NutritionCalculationService, get_nutrition_calculation_service
from ....services.logging_service import get_meal_analysis_logger, ProcessingPhase, LogLevel
from ....core.config import Settings, get_settings

logger = logging.getLogger(__name__)

router = APIRouter()

# Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
_gemini_analyzer = None

async def get_gemini_analyzer(settings: Annotated[Settings, Depends(get_settings)]) -> GeminiMealAnalyzer:
    """
    Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ï¼‰
    """
    global _gemini_analyzer
    if _gemini_analyzer is None:
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer


@router.post(
    "/refine",
    response_model=MealAnalysisRefinementResponse,
    summary="Refine Meal Analysis with USDA Data & Enhanced Gemini Strategy (v2.1)",
    description="v2.1: Phase 1ã‹ã‚‰USDAã‚¯ã‚¨ãƒªå€™è£œã‚’å—ä¿¡ã—ã€å…¨å€™è£œã§æ¤œç´¢ã‚’å®Ÿè¡Œã€‚Phase 2 GeminiãŒcalculation_strategyã‚’æ±ºå®šã—ã€FDC IDã‚’é¸æŠã€‚æ±ºå®šè«–çš„ã§ç²¾åº¦ã®é«˜ã„æ „é¤Šè¨ˆç®—ã‚’æä¾›ã€‚"
)
async def refine_meal_analysis(
    settings: Annotated[Settings, Depends(get_settings)],
    image: Annotated[UploadFile, File(description="Meal image file.")],
    # NEW: Phase 1 å‡ºåŠ›ã¯ JSON æ–‡å­—åˆ—ã¨ã—ã¦å—ã‘å–ã‚‹
    phase1_analysis_json: Annotated[str, Form(description="JSON response string from Phase 1 API.")],
    usda_service: Annotated[USDAService, Depends(get_usda_service)],
    gemini_service: Annotated[GeminiMealAnalyzer, Depends(get_gemini_analyzer)]
):
    """
    v2.1ä»•æ§˜ï¼šé£Ÿäº‹åˆ†æç²¾ç·»åŒ–ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    
    å‡¦ç†ãƒ•ãƒ­ãƒ¼:
    1. Phase 1åˆ†æçµæœã¨USDAã‚¯ã‚¨ãƒªå€™è£œã‚’å—ä¿¡
    2. å…¨USDAã‚¯ã‚¨ãƒªå€™è£œã§ä¸¦åˆ—æ¤œç´¢ã‚’å®Ÿè¡Œ
    3. Phase 2 Geminiã§ calculation_strategy æ±ºå®šã¨FDC IDé¸æŠ
    4. calculation_strategyã«åŸºã¥ãæ „é¤Šè¨ˆç®—
    5. ç²¾ç·»åŒ–ã•ã‚ŒãŸçµæœã‚’è¿”ã™
    """
    # ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
    meal_logger = get_meal_analysis_logger()
    session_id = meal_logger.start_session(
        endpoint="/api/v1/meal-analyses/refine",
        image_filename=getattr(image, 'filename', None),
        image_size_bytes=None  # å¾Œã§è¨­å®š
    )
    
    start_time = time.time()
    warnings = []
    errors = []

    try:
        # 1. Image validation (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.REQUEST_RECEIVED,
            message="Validating image file"
        )
        
        if not image.content_type or not image.content_type.startswith("image/"):
            raise HTTPException(status_code=400, detail="Invalid image file format.")
        
        try:
            image_bytes = await image.read()
            # Update image size in session
            if session_id in meal_logger.active_sessions:
                meal_logger.active_sessions[session_id].image_size_bytes = len(image_bytes)
            
            # File size check (e.g., 10MB)
            if len(image_bytes) > 10 * 1024 * 1024:
                raise HTTPException(status_code=400, detail="Image file size too large (max 10MB).")
        except Exception as e:
            logger.error(f"Error reading image file: {e}")
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.REQUEST_RECEIVED,
                error_message="Failed to read image file",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail="Failed to read image file.")

        # 2. Parse Phase 1 analysis_data
        try:
            phase1_dict = json.loads(phase1_analysis_json)
            phase1_analysis = Phase1AnalysisResponse(**phase1_dict)
            
            # ãƒ­ã‚°ã«Phase 1æƒ…å ±ã‚’è¨˜éŒ²
            dishes_count = len(phase1_analysis.dishes)
            usda_queries_count = sum(len(dish.usda_query_candidates) for dish in phase1_analysis.dishes)
            
            meal_logger.log_entry(
                session_id=session_id,
                level=LogLevel.INFO,
                phase=ProcessingPhase.PHASE1_COMPLETE,
                message=f"Phase 1 data received: {dishes_count} dishes, {usda_queries_count} USDA queries",
                data={
                    "dishes_count": dishes_count,
                    "usda_queries_count": usda_queries_count,
                    "phase1_output": phase1_dict
                }
            )
            
        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE1_COMPLETE,
                error_message="Failed to parse Phase 1 JSON",
                error_details=str(e)
            )
            raise HTTPException(status_code=400, detail=f"Invalid Phase 1 JSON: {e}")

        # 3. Execute ALL USDA searches based on Phase 1 candidates
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.USDA_SEARCH_START,
            message="Starting USDA searches for all query candidates"
        )
        
        usda_search_start_time = time.time()
        usda_search_tasks = []
        query_map = {}  # ã‚¯ã‚¨ãƒªã¨å…ƒã®æ–™ç†/é£Ÿæåã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
        unique_queries = set()

        for dish in phase1_analysis.dishes:
            for candidate in dish.usda_query_candidates:
                if candidate.query_term not in unique_queries:
                    # NEW: search_foods_rich ã‚’ä½¿ç”¨
                    usda_search_tasks.append(usda_service.search_foods_rich(candidate.query_term))
                    query_map[candidate.query_term] = candidate.original_term or dish.dish_name
                    unique_queries.add(candidate.query_term)

        # éåŒæœŸã§USDAæ¤œç´¢ã‚’å®Ÿè¡Œ
        logger.info(f"Starting {len(usda_search_tasks)} USDA searches")
        usda_search_results_list = await asyncio.gather(*usda_search_tasks, return_exceptions=True)
        usda_search_duration = (time.time() - usda_search_start_time) * 1000

        # 4. Format USDA results for Gemini prompt
        usda_candidates_prompt_segments = []
        all_usda_search_results_map: Dict[int, USDASearchResultItem] = {}  # FDC ID ã§å¼•ã‘ã‚‹ã‚ˆã†ã«
        search_term_to_results: Dict[str, List[USDASearchResultItem]] = {}  # ã‚¯ã‚¨ãƒª -> çµæœ
        total_results_found = 0
        search_details = []

        for query, results_or_exc in zip(unique_queries, usda_search_results_list):
            original_term = query_map.get(query, query)
            if isinstance(results_or_exc, Exception):
                segment = f"Error searching USDA for '{query}' (related to '{original_term}'): {results_or_exc}\n"
                errors.append(f"USDA Search failed for {query}: {results_or_exc}")
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "error",
                    "error": str(results_or_exc)
                })
            elif not results_or_exc:
                segment = f"No USDA candidates found for '{query}' (related to '{original_term}').\n"
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "no_results"
                })
            else:
                search_term_to_results[query] = results_or_exc
                total_results_found += len(results_or_exc)
                segment = f"USDA candidates for '{query}' (related to '{original_term}'):\n"
                
                result_summaries = []
                for i, item in enumerate(results_or_exc):
                    all_usda_search_results_map[item.fdc_id] = item
                    # NEW: ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã¨ãƒ–ãƒ©ãƒ³ãƒ‰æƒ…å ±ã‚’ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å«ã‚ã‚‹
                    segment += (
                        f"  {i+1}. FDC ID: {item.fdc_id}, Name: {item.description} "
                        f"(Type: {item.data_type or 'N/A'}"
                        f"{f', Brand: {item.brand_owner}' if item.brand_owner else ''}), "
                        f"Score: {item.score:.2f}\n"
                        # å¿…è¦ã§ã‚ã‚Œã° ingredientsText ã‚„ nutrients ã‚‚ä¸€éƒ¨å«ã‚ã‚‹
                    )
                    if item.ingredients_text:
                        segment += f"    Ingredients: {item.ingredients_text[:150]}...\n"
                    
                    result_summaries.append({
                        "fdc_id": item.fdc_id,
                        "description": item.description,
                        "data_type": item.data_type,
                        "score": item.score
                    })
                
                search_details.append({
                    "query": query,
                    "original_term": original_term,
                    "status": "success",
                    "results_count": len(results_or_exc),
                    "results": result_summaries
                })
            
            usda_candidates_prompt_segments.append(segment)

        usda_candidates_prompt_text = "\n---\n".join(usda_candidates_prompt_segments)
        
        # USDAæ¤œç´¢çµæœã‚’ãƒ­ã‚°ã«è¨˜éŒ²
        meal_logger.update_usda_search_results(
            session_id=session_id,
            duration_ms=usda_search_duration,
            queries_executed=len(unique_queries),
            results_found=total_results_found,
            search_details=search_details
        )

        # 5. Call Gemini service (Phase 2) for strategy and FDC ID selection
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.PHASE2_START,
            message="Starting Phase 2 Gemini for strategy determination and FDC ID selection"
        )
        
        phase2_start_time = time.time()
        try:
            logger.info("Calling Gemini Phase 2 for strategy determination and FDC ID selection")
            # NEW: refine_analysis_phase2 ã‚’ä½¿ç”¨
            gemini_output_dict = await gemini_service.refine_analysis_phase2(
                image_bytes=image_bytes,
                image_mime_type=image.content_type,
                phase1_output_text=phase1_analysis_json,
                usda_results_text=usda_candidates_prompt_text
            )
            gemini_phase2_response = Phase2GeminiResponse(**gemini_output_dict)
            phase2_duration = (time.time() - phase2_start_time) * 1000
            
            # Phase 2çµæœã‚’è§£æã—ã¦ãƒ­ã‚°ã«è¨˜éŒ²
            strategy_decisions = {}
            fdc_selections = {}
            for dish in gemini_phase2_response.dishes:
                strategy_decisions[dish.dish_name] = {
                    "strategy": dish.calculation_strategy,
                    "reason": dish.reason_for_strategy
                }
                fdc_selections[dish.dish_name] = {
                    "dish_fdc_id": dish.fdc_id,
                    "dish_reason": dish.reason_for_choice,
                    "ingredients": [{
                        "name": ing.ingredient_name,
                        "fdc_id": ing.fdc_id,
                        "reason": ing.reason_for_choice
                    } for ing in dish.ingredients]
                }
            
            meal_logger.update_phase2_results(
                session_id=session_id,
                duration_ms=phase2_duration,
                strategy_decisions=strategy_decisions,
                fdc_selections=fdc_selections,
                phase2_output=gemini_output_dict
            )

        except Exception as e:
            meal_logger.log_error(
                session_id=session_id,
                phase=ProcessingPhase.PHASE2_START,
                error_message="Gemini Phase 2 failed",
                error_details=str(e)
            )
            raise HTTPException(status_code=503, detail=f"Gemini Phase 2 error: {e}")

        # 6. Process Gemini output and perform Nutrition Calculation
        meal_logger.log_entry(
            session_id=session_id,
            level=LogLevel.INFO,
            phase=ProcessingPhase.NUTRITION_CALC_START,
            message="Starting nutrition calculation based on Phase 2 strategy"
        )
        
        nutrition_calc_start_time = time.time()
        refined_dishes_response: List[RefinedDishResponse] = []
        nutrition_service = get_nutrition_calculation_service()  # æ „é¤Šè¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹

        # Phase 1 ã®é‡é‡æƒ…å ±ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã‚„ã™ãã™ã‚‹
        phase1_weights_map = {
            (d.dish_name, i.ingredient_name): i.weight_g
            for d in phase1_analysis.dishes
            for i in d.ingredients
        }

        for gemini_dish in gemini_phase2_response.dishes:
            # Phase 1 Dish ã‚’åå‰ã§æ¢ã™ (å³å¯†ã«ã¯IDãªã©ã§å¼•ãã¹ãã ãŒã€ä»Šå›ã¯åå‰ã§)
            p1_dish = next((d for d in phase1_analysis.dishes if d.dish_name == gemini_dish.dish_name), None)
            if not p1_dish:
                warnings.append(f"Could not match Phase 2 dish '{gemini_dish.dish_name}' to Phase 1.")
                continue

            dish_total_nutrients = None
            refined_ingredients_list: List[RefinedIngredientResponse] = []
            dish_key_nutrients_100g = None

            if gemini_dish.calculation_strategy == "dish_level":
                dish_fdc_id = gemini_dish.fdc_id
                if dish_fdc_id:
                    dish_weight_g = sum(ing.weight_g for ing in p1_dish.ingredients)
                    dish_key_nutrients_100g = await usda_service.get_food_details_for_nutrition(dish_fdc_id)
                    if dish_key_nutrients_100g and dish_weight_g > 0:
                        dish_total_nutrients = nutrition_service.calculate_actual_nutrients(dish_key_nutrients_100g, dish_weight_g)
                    else:
                        warnings.append(f"Could not calculate dish-level nutrition for '{gemini_dish.dish_name}'")
                else:
                    warnings.append(f"Dish-level strategy selected for '{gemini_dish.dish_name}' but no FDC ID provided.")

                # ææ–™æƒ…å ±ã¯èª¬æ˜çš„ã«æ®‹ã™ãŒã€æ „é¤Šè¨ˆç®—ã¯ã—ãªã„ (Fallback FDC ID ã¯å–å¾—ãƒ»è¡¨ç¤º)
                for gemini_ing in gemini_dish.ingredients:
                    weight = phase1_weights_map.get((gemini_dish.dish_name, gemini_ing.ingredient_name), 0.0)
                    ing_nutrients_100g = await usda_service.get_food_details_for_nutrition(gemini_ing.fdc_id) if gemini_ing.fdc_id else None
                    refined_ingredients_list.append(RefinedIngredientResponse(
                        ingredient_name=gemini_ing.ingredient_name,
                        weight_g=weight,
                        fdc_id=gemini_ing.fdc_id,  # Fallback ID
                        usda_source_description=gemini_ing.usda_source_description,
                        reason_for_choice=gemini_ing.reason_for_choice,
                        key_nutrients_per_100g=ing_nutrients_100g,
                        actual_nutrients=None  # Not calculated here
                    ))

            elif gemini_dish.calculation_strategy == "ingredient_level":
                ingredient_nutrients_list = []
                for gemini_ing in gemini_dish.ingredients:
                    weight = phase1_weights_map.get((gemini_dish.dish_name, gemini_ing.ingredient_name), 0.0)
                    ing_fdc_id = gemini_ing.fdc_id
                    ing_nutrients_100g = None
                    ing_actual_nutrients = None

                    if ing_fdc_id and weight > 0:
                        ing_nutrients_100g = await usda_service.get_food_details_for_nutrition(ing_fdc_id)
                        if ing_nutrients_100g:
                            ing_actual_nutrients = nutrition_service.calculate_actual_nutrients(ing_nutrients_100g, weight)
                            ingredient_nutrients_list.append(ing_actual_nutrients)
                        else:
                            warnings.append(f"Could not get nutrition for ingredient '{gemini_ing.ingredient_name}' (FDC ID: {ing_fdc_id})")
                    else:
                        warnings.append(f"Missing FDC ID or weight for ingredient '{gemini_ing.ingredient_name}'")

                    refined_ingredients_list.append(RefinedIngredientResponse(
                        ingredient_name=gemini_ing.ingredient_name,
                        weight_g=weight,
                        fdc_id=ing_fdc_id,
                        usda_source_description=gemini_ing.usda_source_description,
                        reason_for_choice=gemini_ing.reason_for_choice,
                        key_nutrients_per_100g=ing_nutrients_100g,
                        actual_nutrients=ing_actual_nutrients
                    ))
                # ææ–™ã‹ã‚‰æ–™ç†å…¨ä½“ã®æ „é¤Šã‚’åˆè¨ˆ
                dish_total_nutrients = nutrition_service.aggregate_nutrients_for_dish_from_ingredients(
                    [ing for ing in refined_ingredients_list if ing.actual_nutrients]  # None ã‚’é™¤å¤–
                )

            # RefinedDishResponse ã‚’ä½œæˆ
            refined_dishes_response.append(RefinedDishResponse(
                dish_name=gemini_dish.dish_name,
                type=p1_dish.type,
                quantity_on_plate=p1_dish.quantity_on_plate,
                calculation_strategy=gemini_dish.calculation_strategy,
                reason_for_strategy=gemini_dish.reason_for_strategy,
                fdc_id=gemini_dish.fdc_id,
                usda_source_description=gemini_dish.usda_source_description,
                reason_for_choice=gemini_dish.reason_for_choice,
                key_nutrients_per_100g=dish_key_nutrients_100g,
                ingredients=refined_ingredients_list,
                dish_total_actual_nutrients=dish_total_nutrients
            ))

        # 7. Calculate total meal nutrients
        total_meal_nutrients = nutrition_service.aggregate_nutrients_for_meal(
            [dish.dish_total_actual_nutrients for dish in refined_dishes_response if dish.dish_total_actual_nutrients]
        )
        
        nutrition_calc_duration = (time.time() - nutrition_calc_start_time) * 1000
        total_calories = total_meal_nutrients.calories_kcal if total_meal_nutrients else 0.0
        
        # æ „é¤Šè¨ˆç®—çµæœã‚’ãƒ­ã‚°ã«è¨˜éŒ²
        meal_logger.update_nutrition_results(
            session_id=session_id,
            duration_ms=nutrition_calc_duration,
            total_calories=total_calories,
            final_nutrition={
                "total_meal_nutrients": total_meal_nutrients.dict() if total_meal_nutrients else None,
                "dishes_count": len(refined_dishes_response),
                "warnings_count": len(warnings),
                "errors_count": len(errors)
            }
        )

        # 8. Create final response
        response = MealAnalysisRefinementResponse(
            dishes=refined_dishes_response,
            total_meal_nutrients=total_meal_nutrients,
            warnings=warnings if warnings else None,
            errors=errors if errors else None
        )
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†
        meal_logger.end_session(
            session_id=session_id,
            warnings=warnings,
            errors=errors
        )
        
        return response

    except Exception as e:
        # äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ã®ãƒ­ã‚°è¨˜éŒ²
        meal_logger.log_error(
            session_id=session_id,
            phase=ProcessingPhase.ERROR_OCCURRED,
            error_message="Unexpected error during request processing",
            error_details=str(e)
        )
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰
        meal_logger.end_session(
            session_id=session_id,
            warnings=warnings,
            errors=errors + [str(e)]
        )
        
        raise 
```

============================================================

ğŸ“ ã‚µãƒ¼ãƒ“ã‚¹å±¤
============================================================

ğŸ“„ FILE: app/services/gemini_service.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 12578 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:41:52
å­˜åœ¨: âœ…

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

# æ–°ã—ã„ã‚¹ã‚­ãƒ¼ãƒã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from ..api.v1.schemas.meal import PHASE_1_GEMINI_SCHEMA, PHASE_2_GEMINI_SCHEMA, MEAL_ANALYSIS_GEMINI_SCHEMA, REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Geminiã®æ§‹é€ åŒ–å‡ºåŠ›ã®ãŸã‚ã®JSONã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆã€‚",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§°ã€‚"},
                    "type": {"type": "string", "description": "æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: ä¸»èœ, å‰¯èœ, ã‚¹ãƒ¼ãƒ—, ãƒ‡ã‚¶ãƒ¼ãƒˆï¼‰ã€‚"},
                    "quantity_on_plate": {"type": "string", "description": "çš¿ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹æ–™ç†ã®ãŠãŠã‚ˆãã®é‡ã‚„å€‹æ•°ï¼ˆä¾‹: '1æ¯', '2åˆ‡ã‚Œ', 'ç´„200g'ï¼‰ã€‚"},
                    "ingredients": {
                        "type": "array",
                        "description": "ã“ã®æ–™ç†ã«å«ã¾ã‚Œã‚‹ã¨æ¨å®šã•ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆã€‚",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ææ–™ã®åç§°ã€‚"},
                                "weight_g": {"type": "number", "description": "ãã®ææ–™ã®æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰ã€‚"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AIçµŒç”±ã§Geminiã‚’ä½¿ç”¨ã—ã¦é£Ÿäº‹ç”»åƒã‚’åˆ†æã™ã‚‹ã‚¯ãƒ©ã‚¹ (v2.1å¯¾å¿œ)"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-2.5-flash-preview-05-20"):
        """
        åˆæœŸåŒ–
        
        Args:
            project_id: GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆID
            location: Vertex AIã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¾‹: us-central1ï¼‰
            model_name: ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«å
        """
        # Vertex AIã®åˆæœŸåŒ–
        vertexai.init(project=project_id, location=location)
        
        # ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
        self.model = GenerativeModel(model_name=model_name)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã®åˆæœŸåŒ–ï¼ˆå¿…é ˆï¼‰
        self.prompt_loader = PromptLoader()
        
        # ã‚»ãƒ¼ãƒ•ãƒ†ã‚£è¨­å®š
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }

    async def analyze_image_phase1(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        Phase 1: ç”»åƒã‚’åˆ†æã—ã€æ–™ç†ãƒ»é£Ÿæã¨USDAã‚¯ã‚¨ãƒªå€™è£œã‚’æŠ½å‡º (v2.1ä»•æ§˜)
        """
        try:
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            contents = [Part.from_text(full_prompt), Part.from_data(data=image_bytes, mime_type=image_mime_type)]

            generation_config = GenerationConfig(
                temperature=0.3, # å€™è£œã‚’åºƒã’ã‚‹ãŸã‚ã«å°‘ã—ä¸Šã’ã‚‹ã“ã¨ã‚‚æ¤œè¨
                top_p=0.9,
                top_k=20,
                max_output_tokens=16384, # ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã‚’å¢—ã‚„ã™
                response_mime_type="application/json",
                # NEW: Phase 1 ç”¨ã®ã‚¹ã‚­ãƒ¼ãƒã‚’ä½¿ç”¨
                response_schema=PHASE_1_GEMINI_SCHEMA
            )

            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )

            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 1).")

            result = json.loads(response.text)
            logger.info(f"Gemini Phase 1 analysis completed. Found {len(result.get('dishes', []))} dishes.")
            return result

        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error (Phase 1): {e}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 1) API request failed: {e}") from e

    async def refine_analysis_phase2(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        phase1_output_text: str, # Phase 1 ã®ç”Ÿ JSON å‡ºåŠ›
        usda_results_text: str # æ•´å½¢ã•ã‚ŒãŸå…¨ USDA æ¤œç´¢çµæœ
    ) -> Dict:
        """
        Phase 2: USDAå€™è£œã«åŸºã¥ãã€calculation_strategy ã‚’æ±ºå®šã—ã€FDC ID ã‚’é¸æŠ (v2.1ä»•æ§˜)
        """
        try:
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                initial_ai_output=phase1_output_text,
                usda_candidates=usda_results_text
            )
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            contents = [Part.from_text(full_prompt), Part.from_data(data=image_bytes, mime_type=image_mime_type)]

            generation_config = GenerationConfig(
                temperature=0.1, # æ±ºå®šè«–çš„ãªå‡ºåŠ›ã‚’ç›®æŒ‡ã™ãŸã‚ä½ã‚ã«è¨­å®š
                top_p=0.8,
                top_k=10,
                max_output_tokens=16384, # ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã‚’å¢—ã‚„ã™
                response_mime_type="application/json",
                # NEW: Phase 2 ç”¨ã®ã‚¹ã‚­ãƒ¼ãƒã‚’ä½¿ç”¨
                response_schema=PHASE_2_GEMINI_SCHEMA
            )

            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )

            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")

            result = json.loads(response.text)
            logger.info(f"Gemini Phase 2 analysis completed. Processed {len(result.get('dishes', []))} dishes.")
            return result

        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error (Phase 2): {e}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e

    # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ä¿æŒ
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜ã®Phase 1ã¨ã—ã¦å‹•ä½œï¼‰
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒªã‚¹ãƒˆã‚’ä½œæˆ
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ—¢å­˜ã‚¹ã‚­ãƒ¼ãƒã‚’ä½¿ç”¨
            generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIã‚’å‘¼ã³å‡ºã—ï¼ˆéåŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ï¼‰
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=generation_config,
                safety_settings=self.safety_settings
            )
            
            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜ã®Phase 2ã¨ã—ã¦å‹•ä½œï¼‰
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                initial_ai_output=initial_ai_output_text or "{}",
                usda_candidates=usda_candidates_text
            )
            
            # å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒªã‚¹ãƒˆã‚’ä½œæˆ
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # ãƒ•ã‚§ãƒ¼ã‚º2ç”¨ã®Generation Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIã‚’å‘¼ã³å‡ºã—
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            if not response.text:
                raise ValueError("No response returned from Gemini Phase 2.")
            
            # JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
            result = json.loads(response.text)
            
            logger.info(f"Gemini Phase 2 refinement completed successfully. Processed {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in Phase 2: {e}")
            raise RuntimeError(f"Error processing Phase 2 response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error in Phase 2: {e}")
            raise RuntimeError(f"Vertex AI/Gemini Phase 2 API request failed: {e}") from e


def get_gemini_analyzer(project_id: str, location: str, model_name: str) -> GeminiMealAnalyzer:
    """GeminiMealAnalyzerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¦è¿”ã™"""
    return GeminiMealAnalyzer(project_id=project_id, location=location, model_name=model_name) 
```

============================================================

ğŸ“„ FILE: app/services/usda_service.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 13467 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:39:14
å­˜åœ¨: âœ…

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings
from ..api.v1.schemas.meal import USDANutrient, USDASearchResultItem

logger = logging.getLogger(__name__)


class USDAService:
    """USDA FoodData Central APIã¨ã®é€šä¿¡ã‚’ç®¡ç†ã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClientã®è¨­å®š
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods_rich(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 10, # å€™è£œæ•°ã‚’å¢—ã‚„ã™ (è¨­å®šå¯èƒ½ã«)
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central APIã§é£Ÿå“ã‚’æ¤œç´¢ã—ã€è©³ç´°ãªæƒ…å ±ã‚’è¿”ã™ (v2.1ä»•æ§˜)
        
        Args:
            query: æ¤œç´¢ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—
            data_types: ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆï¼ˆä¾‹: ["Foundation", "SR Legacy", "Branded"]ï¼‰
            page_size: 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®çµæœæ•°
            page_number: å–å¾—ã™ã‚‹ãƒšãƒ¼ã‚¸ç•ªå·
            sort_by: ã‚½ãƒ¼ãƒˆã‚­ãƒ¼
            sort_order: ã‚½ãƒ¼ãƒˆé †ï¼ˆ"asc" ã¾ãŸã¯ "desc"ï¼‰
            
        Returns:
            USDASearchResultItemã®ãƒªã‚¹ãƒˆï¼ˆæ–°ã—ã„Pydanticãƒ¢ãƒ‡ãƒ«ï¼‰
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã¨ã—ã¦æ¸¡ã™
            params["dataType"] = ",".join(data_types)
        
        # NEW: requireAllWords ã‚’ True ã«è¨­å®šã—ã¦ç²¾åº¦ã‚’ä¸Šã’ã‚‹ã“ã¨ã‚‚æ¤œè¨ (ãŸã ã—ãƒ’ãƒƒãƒˆæ•°ãŒæ¸›ã‚‹)
        # params["requireAllWords"] = "true"
        
        try:
            logger.info(f"USDA API rich search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆæƒ…å ±ã®ãƒ­ã‚°
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                # NEW: foodNutrients ã‚’è©³ç´°ã«å–å¾—ãƒ»ãƒ‘ãƒ¼ã‚¹
                # NOTE: æ¤œç´¢çµæœã® foodNutrients ã¯é™å®šçš„ãªã“ã¨ãŒå¤šã„ã€‚
                # è©³ç´°ãªæ „é¤Šç´ ã¯ get_food_details_for_nutrition ã§å–å¾—ã™ã‚‹ã€‚
                # ã“ã“ã§ã¯ä¸»ã« FDC ID, description, dataType, brandOwner, ingredients ã‚’é‡è¦–ã€‚
                nutrients_extracted = self._extract_key_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    # NEW: ingredientsText ã‚’å–å¾—
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API rich search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods_rich: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_key_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrientsãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ä¸»è¦æ „é¤Šç´ ã‚’æŠ½å‡º (æ–°ã—ã„Pydanticãƒ¢ãƒ‡ãƒ«ä½¿ç”¨)
        """
        # ä¸»è¦æ „é¤Šç´  (configã‹ã‚‰å–å¾—) ã®ã¿ã‚’æŠ½å‡ºã™ã‚‹
        nutrients_extracted = []
        key_numbers = self.key_nutrient_numbers # Settings ã‹ã‚‰å–å¾—

        for nutrient_entry in food_nutrients:
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")

            if not nutrient_detail and "nutrientId" in nutrient_entry: # Branded abridged
                number = nutrient_entry.get("nutrientNumber")
                name = nutrient_entry.get("nutrientName")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")
                nutrient_id = nutrient_entry.get("nutrientId")
            else: # Standard
                number = nutrient_detail.get("number")
                name = nutrient_detail.get("name")
                unit_name = nutrient_detail.get("unitName")
                nutrient_id = nutrient_detail.get("id")

            if number and str(number) in key_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        return nutrients_extracted

    async def get_food_details(self, fdc_id: int) -> Optional[USDASearchResultItem]:
        """
        ç‰¹å®šã®FDC IDã®é£Ÿå“è©³ç´°æƒ…å ±ã‚’å–å¾— (æ–°ã—ã„Pydanticãƒ¢ãƒ‡ãƒ«ä½¿ç”¨)
        """
        params = {
            "api_key": self.api_key,
            "format": "full"  # ingredients ã‚‚ç¢ºå®Ÿã«å–å¾—ã™ã‚‹ãŸã‚ã« format="full" ã‚’ä½¿ç”¨
        }
        
        try:
            logger.info(f"Getting USDA food details for FDC ID: {fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            if "X-RateLimit-Remaining" in response.headers:
                logger.debug(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data = response.json()
            
            # _extract_key_nutrients ã‚’ä½¿ç”¨ã—ã¦æ „é¤Šç´ ã‚’ãƒ‘ãƒ¼ã‚¹
            nutrients_extracted = self._extract_key_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted,
                score=None  # è©³ç´°å–å¾—æ™‚ã¯ã‚¹ã‚³ã‚¢ãªã—
            )
            
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found")
                return None
            logger.error(f"USDA API error getting food details: {e.response.status_code} - {e.response.text}")
            raise RuntimeError(f"USDA API error: {e.response.status_code}") from e
        except Exception as e:
            logger.error(f"Error getting food details for FDC ID {fdc_id}: {str(e)}")
            raise RuntimeError(f"Error getting food details: {str(e)}") from e

    async def get_food_details_for_nutrition(self, fdc_id: int) -> Optional[Dict[str, float]]:
        """
        æ „é¤Šè¨ˆç®—ç”¨ã®é£Ÿå“è©³ç´°æƒ…å ±ã‚’å–å¾— (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒãƒ»ç¢ºèª)
        """
        params = {
            "api_key": self.api_key,
            "format": "full",
            # ä¸»è¦æ „é¤Šç´ ã®ã¿å–å¾—
            "nutrients": ",".join(self.key_nutrient_numbers)
        }
        
        try:
            logger.debug(f"Getting nutrition data for FDC ID: {fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            if "X-RateLimit-Remaining" in response.headers:
                logger.debug(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data = response.json()
            
            return self._parse_nutrients_for_calculation(food_data)
            
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found for nutrition calculation")
                return None
            logger.error(f"USDA API error getting nutrition data: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"Error getting nutrition data for FDC ID {fdc_id}: {str(e)}")
            return None

    def _parse_nutrients_for_calculation(self, food_data_raw: dict) -> Dict[str, float]:
        """
        USDA APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ „é¤Šè¨ˆç®—ç”¨ã®æ „é¤Šç´ è¾æ›¸ã‚’ä½œæˆ
        """
        nutrients_dict = {}
        food_nutrients = food_data_raw.get("foodNutrients", [])
        
        # æ „é¤Šç´ ç•ªå·ã¨æ¨™æº–åã®å¯¾å¿œè¡¨
        nutrient_map = {
            "208": "calories_kcal",      # Energy
            "203": "protein_g",          # Protein  
            "205": "carbohydrates_g",    # Carbohydrate
            "204": "fat_g",              # Total lipid (fat)
            "291": "fiber_g",            # Fiber, total dietary
            "269": "sugars_g",           # Sugars, total
            "307": "sodium_mg"           # Sodium
        }
        
        for nutrient_entry in food_nutrients:
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®é•ã„ã«å¯¾å¿œ
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                # Branded Foods abridged format
                number = nutrient_entry.get("nutrientNumber")
                amount = nutrient_entry.get("value")
            else:
                # Standard format
                number = nutrient_detail.get("number")
            
            if number and str(number) in nutrient_map and amount is not None:
                standard_name = nutrient_map[str(number)]
                nutrients_dict[standard_name] = float(amount)
        
        logger.debug(f"Parsed nutrients for calculation: {nutrients_dict}")
        return nutrients_dict

    # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ä¿æŒ
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List:
        """
        å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®æ—¢å­˜search_foodsãƒ¡ã‚½ãƒƒãƒ‰
        """
        # æ–°ã—ã„search_foods_richã‚’å‘¼ã³å‡ºã—ã¦ã€å¤ã„å½¢å¼ã«å¤‰æ›
        rich_results = await self.search_foods_rich(
            query=query,
            data_types=data_types,
            page_size=page_size,
            page_number=page_number,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«å¤ã„USDASearchResultItemã‚¯ãƒ©ã‚¹å½¢å¼ã«å¤‰æ›
        # ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€å¿…è¦ã«å¿œã˜ã¦ãƒ¬ã‚¬ã‚·ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’ä¿æŒã™ã‚‹ï¼‰
        return rich_results
    
    async def close_client(self):
        """HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.client:
            await self.client.aclose()


@lru_cache()
def get_usda_service():
    """USDAServiceã®ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—"""
    return USDAService() 
```

============================================================

ğŸ“ ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å±¤
============================================================

ğŸ“„ FILE: app/api/v1/schemas/meal.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 17460 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:37:41
å­˜åœ¨: âœ…

CONTENT:
```
from typing import List, Optional, Dict, Literal
from pydantic import BaseModel, Field, field_validator

# --- å…±é€šãƒ¢ãƒ‡ãƒ« ---

class CalculatedNutrients(BaseModel):
    """è¨ˆç®—æ¸ˆã¿æ „é¤Šç´ ãƒ¢ãƒ‡ãƒ«"""
    calories_kcal: float = Field(0.0, description="è¨ˆç®—ã•ã‚ŒãŸç·ã‚«ãƒ­ãƒªãƒ¼ (kcal)")
    protein_g: float = Field(0.0, description="è¨ˆç®—ã•ã‚ŒãŸç·ã‚¿ãƒ³ãƒ‘ã‚¯è³ª (g)")
    carbohydrates_g: float = Field(0.0, description="è¨ˆç®—ã•ã‚ŒãŸç·ç‚­æ°´åŒ–ç‰© (g)")
    fat_g: float = Field(0.0, description="è¨ˆç®—ã•ã‚ŒãŸç·è„‚è³ª (g)")
    fiber_g: Optional[float] = Field(None, description="è¨ˆç®—ã•ã‚ŒãŸç·é£Ÿç‰©ç¹Šç¶­ (g)")
    sugars_g: Optional[float] = Field(None, description="è¨ˆç®—ã•ã‚ŒãŸç·ç³–è³ª (g)")
    sodium_mg: Optional[float] = Field(None, description="è¨ˆç®—ã•ã‚ŒãŸç·ãƒŠãƒˆãƒªã‚¦ãƒ  (mg)")

class USDANutrient(BaseModel):
    """USDAæ „é¤Šç´ æƒ…å ±ãƒ¢ãƒ‡ãƒ« (USDA ServiceãŒè¿”ã™)"""
    name: str = Field(..., description="æ „é¤Šç´ å")
    amount: float = Field(..., description="100gã¾ãŸã¯100mlã‚ãŸã‚Šã®é‡")
    unit_name: str = Field(..., description="å˜ä½å (ä¾‹: g, mg, kcal)")
    nutrient_id: Optional[int] = Field(None, description="USDAæ „é¤Šç´ ID")
    nutrient_number: Optional[str] = Field(None, description="USDAæ „é¤Šç´ ç•ªå·")

class USDASearchResultItem(BaseModel):
    """USDAæ¤œç´¢çµæœã‚¢ã‚¤ãƒ†ãƒ ãƒ¢ãƒ‡ãƒ« (USDA ServiceãŒè¿”ã™)"""
    fdc_id: int = Field(..., description="USDA FoodData Central ID")
    description: str = Field(..., description="é£Ÿå“ã®å…¬å¼åç§°")
    data_type: Optional[str] = Field(None, description="USDAãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ— (ä¾‹: SR Legacy, Branded)")
    brand_owner: Optional[str] = Field(None, description="ãƒ–ãƒ©ãƒ³ãƒ‰æ‰€æœ‰è€… (Branded Foodsã®å ´åˆ)")
    ingredients_text: Optional[str] = Field(None, description="åŸææ–™ãƒªã‚¹ãƒˆæ–‡å­—åˆ— (Branded/FNDDSã®å ´åˆ, **Assumption: String**)")
    food_nutrients: List[USDANutrient] = Field(default_factory=list, description="ä¸»è¦ãªæ „é¤Šç´ æƒ…å ±ã®ãƒªã‚¹ãƒˆ")
    score: Optional[float] = Field(None, description="æ¤œç´¢çµæœã®é–¢é€£åº¦ã‚¹ã‚³ã‚¢")

# --- Phase 1 Gemini å‡ºåŠ›ãƒ¢ãƒ‡ãƒ« ---

class USDACandidateQuery(BaseModel):
    """Phase 1ã§GeminiãŒå‡ºåŠ›ã™ã‚‹USDAã‚¯ã‚¨ãƒªå€™è£œ"""
    query_term: str = Field(..., description="USDAæ¤œç´¢ã«ä½¿ç”¨ã™ã‚‹å…·ä½“çš„ãªã‚¯ã‚¨ãƒªæ–‡å­—åˆ— (è‹±èª)")
    granularity_level: Literal["dish", "ingredient", "branded_product"] = Field(..., description="ã“ã®ã‚¯ã‚¨ãƒªãŒå¯¾è±¡ã¨ã™ã‚‹ç²’åº¦ãƒ¬ãƒ™ãƒ«")
    original_term: str = Field("", description="ã“ã®ã‚¯ã‚¨ãƒªãŒç”±æ¥ã™ã‚‹å…ƒã®æ–™ç†åã¾ãŸã¯é£Ÿæå")
    reason_for_query: str = Field("", description="ã“ã®ã‚¯ã‚¨ãƒªå€™è£œã‚’ç”Ÿæˆã—ãŸç°¡å˜ãªç†ç”±")

class Phase1Ingredient(BaseModel):
    """Phase 1 ææ–™ãƒ¢ãƒ‡ãƒ«"""
    ingredient_name: str = Field(..., description="ææ–™ã®åç§° (è‹±èª)")
    weight_g: float = Field(..., description="æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰", ge=0.1)

class Phase1Dish(BaseModel):
    """Phase 1 æ–™ç†ãƒ¢ãƒ‡ãƒ«"""
    dish_name: str = Field(..., description="ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§° (è‹±èª)")
    type: str = Field(..., description="æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: Main course, Side dishï¼‰")
    quantity_on_plate: str = Field(..., description="çš¿ã®ä¸Šã®é‡ã‚„å€‹æ•°")
    ingredients: List[Phase1Ingredient] = Field(..., description="å«ã¾ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆ")
    # NEW: Phase 1ã§ã‚¯ã‚¨ãƒªå€™è£œã‚’å‡ºåŠ›
    usda_query_candidates: List[USDACandidateQuery] = Field(..., description="ã“ã®æ–™ç†/é£Ÿæã«é–¢é€£ã™ã‚‹USDAã‚¯ã‚¨ãƒªå€™è£œãƒªã‚¹ãƒˆ")

class Phase1AnalysisResponse(BaseModel):
    """Phase 1 é£Ÿäº‹åˆ†æãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«"""
    dishes: List[Phase1Dish] = Field(..., description="ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆ")

# --- Phase 2 Gemini å‡ºåŠ›ãƒ¢ãƒ‡ãƒ« (Geminiå‘ã‘ã‚¹ã‚­ãƒ¼ãƒ) ---

class RefinedIngredientGeminiOutput(BaseModel):
    """Phase 2 Geminiå‡ºåŠ›ç”¨ - ææ–™ãƒ¢ãƒ‡ãƒ«"""
    ingredient_name: str = Field(..., description="ææ–™ã®åç§° (è‹±èª)ã€‚Phase 1ã‹ã‚‰å¼•ãç¶™ãã€å¿…è¦ãªã‚‰ä¿®æ­£ã€‚")
    fdc_id: Optional[int] = Field(None, description="é¸æŠã•ã‚ŒãŸFDC IDã€‚ingredient_levelã®å ´åˆã€ã¾ãŸã¯dish_levelã®Fallbackæ™‚ã«è¨­å®šã€‚")
    usda_source_description: Optional[str] = Field(None, description="é¸æŠã•ã‚ŒãŸFDC IDã®å…¬å¼åç§°ã€‚")
    reason_for_choice: Optional[str] = Field(None, description="ã“ã®FDC IDã‚’é¸æŠã—ãŸç†ç”±ã€ã¾ãŸã¯é¸æŠã—ãªã‹ã£ãŸç†ç”±ã€‚")

class RefinedDishGeminiOutput(BaseModel):
    """Phase 2 Geminiå‡ºåŠ›ç”¨ - æ–™ç†ãƒ¢ãƒ‡ãƒ«"""
    dish_name: str = Field(..., description="æ–™ç†ã®åç§° (è‹±èª)ã€‚Phase 1ã‹ã‚‰å¼•ãç¶™ãã€å¿…è¦ãªã‚‰ä¿®æ­£ã€‚")
    calculation_strategy: Literal["dish_level", "ingredient_level"] = Field(..., description="ã“ã®æ–™ç†ã®æ „é¤Šè¨ˆç®—æ–¹é‡ã€‚")
    reason_for_strategy: str = Field(..., description="ã“ã®è¨ˆç®—æˆ¦ç•¥ã‚’é¸æŠã—ãŸç†ç”±ã€‚")
    fdc_id: Optional[int] = Field(None, description="dish_levelã®å ´åˆã«é¸æŠã•ã‚ŒãŸFDC IDã€‚")
    usda_source_description: Optional[str] = Field(None, description="dish_levelã®å ´åˆã«é¸æŠã•ã‚ŒãŸFDC IDã®å…¬å¼åç§°ã€‚")
    reason_for_choice: Optional[str] = Field(None, description="dish_levelã®å ´åˆã€ã“ã®FDC IDã‚’é¸æŠã—ãŸç†ç”±ã€‚")
    ingredients: List[RefinedIngredientGeminiOutput] = Field(..., description="ææ–™ãƒªã‚¹ãƒˆã€‚å„ææ–™ã«ã¤ã„ã¦FDC IDã¨é¸æŠç†ç”±ã‚’è¨˜è¿°ã€‚")

class Phase2GeminiResponse(BaseModel):
    """Phase 2 Geminiå‡ºåŠ›ç”¨ - å…¨ä½“ãƒ¢ãƒ‡ãƒ«"""
    dishes: List[RefinedDishGeminiOutput] = Field(..., description="ç²¾ç·»åŒ–ã•ã‚ŒãŸæ–™ç†ãƒªã‚¹ãƒˆã€‚")

# --- Phase 2 API å‡ºåŠ›ãƒ¢ãƒ‡ãƒ« (æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹) ---

class RefinedIngredientResponse(BaseModel):
    """Phase 2 APIå‡ºåŠ›ç”¨ - ææ–™ãƒ¢ãƒ‡ãƒ«"""
    ingredient_name: str
    weight_g: float
    fdc_id: Optional[int]
    usda_source_description: Optional[str]
    reason_for_choice: Optional[str] # From Gemini
    key_nutrients_per_100g: Optional[Dict[str, float]] # From USDA Service
    actual_nutrients: Optional[CalculatedNutrients] # From Nutrition Calculation

class RefinedDishResponse(BaseModel):
    """Phase 2 APIå‡ºåŠ›ç”¨ - æ–™ç†ãƒ¢ãƒ‡ãƒ«"""
    dish_name: str
    type: str # From Phase 1
    quantity_on_plate: str # From Phase 1
    calculation_strategy: Literal["dish_level", "ingredient_level"] # From Gemini
    reason_for_strategy: Optional[str] # From Gemini
    fdc_id: Optional[int] # From Gemini (dish_level)
    usda_source_description: Optional[str] # From Gemini (dish_level)
    reason_for_choice: Optional[str] # From Gemini (dish_level)
    key_nutrients_per_100g: Optional[Dict[str, float]] # From USDA Service (dish_level)
    ingredients: List[RefinedIngredientResponse]
    dish_total_actual_nutrients: Optional[CalculatedNutrients] # From Nutrition Calculation

class MealAnalysisRefinementResponse(BaseModel):
    """Phase 2 é£Ÿäº‹åˆ†æç²¾ç·»åŒ–ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«"""
    dishes: List[RefinedDishResponse]
    total_meal_nutrients: Optional[CalculatedNutrients]
    warnings: Optional[List[str]] = Field(None, description="å‡¦ç†ä¸­ã«ç™ºç”Ÿã—ãŸè­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€‚")
    errors: Optional[List[str]] = Field(None, description="å‡¦ç†ä¸­ã«ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€‚")

# --- å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«æ—¢å­˜ãƒ¢ãƒ‡ãƒ«ã‚‚ä¿æŒ ---

class Ingredient(BaseModel):
    """ææ–™æƒ…å ±ãƒ¢ãƒ‡ãƒ« (æ—¢å­˜APIç”¨)"""
    ingredient_name: str = Field(..., description="ææ–™ã®åç§°")
    weight_g: float = Field(..., description="æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰", ge=0.1)

class Dish(BaseModel):
    """æ–™ç†æƒ…å ±ãƒ¢ãƒ‡ãƒ« (æ—¢å­˜APIç”¨)"""
    dish_name: str = Field(..., description="ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§°")
    type: str = Field(..., description="æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: ä¸»èœ, å‰¯èœ, ã‚¹ãƒ¼ãƒ—ï¼‰")
    quantity_on_plate: str = Field(..., description="çš¿ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹æ–™ç†ã®ãŠãŠã‚ˆãã®é‡ã‚„å€‹æ•°")
    ingredients: List[Ingredient] = Field(..., description="ãã®æ–™ç†ã«å«ã¾ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆ")

class MealAnalysisResponse(BaseModel):
    """é£Ÿäº‹åˆ†æãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ« (æ—¢å­˜APIç”¨)"""
    dishes: List[Dish] = Field(..., description="ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆ")

class ErrorResponse(BaseModel):
    """ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«"""
    error: dict = Field(..., description="ã‚¨ãƒ©ãƒ¼æƒ…å ±")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": {
                    "code": "INVALID_INPUT", 
                    "message": "æä¾›ã•ã‚ŒãŸç”»åƒãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
                }
            }
        }

# --- å¾Œæ–¹äº’æ›æ€§ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ ---
InitialAnalysisIngredient = Ingredient  
InitialAnalysisDish = Dish  
InitialAnalysisData = MealAnalysisResponse  

# --- RefinedIngredient/RefinedDish ã¯ RefinedIngredientResponse/RefinedDishResponse ã¸ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ ---
RefinedIngredient = RefinedIngredientResponse
RefinedDish = RefinedDishResponse

# --- Geminiå‘ã‘JSONã‚¹ã‚­ãƒ¼ãƒå®šç¾© (æ‰‹å‹•ã§ä¿®æ­£) ---

# Phase 1 Schema - æ‰‹å‹•ã§å®šç¾©ã—ã¦Gemini APIäº’æ›ã«ã™ã‚‹
PHASE_1_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§° (è‹±èª)"},
                    "type": {"type": "string", "description": "æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: Main course, Side dishï¼‰"},
                    "quantity_on_plate": {"type": "string", "description": "çš¿ã®ä¸Šã®é‡ã‚„å€‹æ•°"},
                    "ingredients": {
                        "type": "array",
                        "description": "å«ã¾ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ææ–™ã®åç§° (è‹±èª)"},
                                "weight_g": {"type": "number", "description": "æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰", "minimum": 0.1}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    },
                    "usda_query_candidates": {
                        "type": "array",
                        "description": "ã“ã®æ–™ç†/é£Ÿæã«é–¢é€£ã™ã‚‹USDAã‚¯ã‚¨ãƒªå€™è£œãƒªã‚¹ãƒˆ",
                        "items": {
                            "type": "object",
                            "properties": {
                                "query_term": {"type": "string", "description": "USDAæ¤œç´¢ã«ä½¿ç”¨ã™ã‚‹å…·ä½“çš„ãªã‚¯ã‚¨ãƒªæ–‡å­—åˆ— (è‹±èª)"},
                                "granularity_level": {
                                    "type": "string",
                                    "enum": ["dish", "ingredient", "branded_product"],
                                    "description": "ã“ã®ã‚¯ã‚¨ãƒªãŒå¯¾è±¡ã¨ã™ã‚‹ç²’åº¦ãƒ¬ãƒ™ãƒ«"
                                },
                                "original_term": {"type": "string", "description": "ã“ã®ã‚¯ã‚¨ãƒªãŒç”±æ¥ã™ã‚‹å…ƒã®æ–™ç†åã¾ãŸã¯é£Ÿæå"},
                                "reason_for_query": {"type": "string", "description": "ã“ã®ã‚¯ã‚¨ãƒªå€™è£œã‚’ç”Ÿæˆã—ãŸç°¡å˜ãªç†ç”±"}
                            },
                            "required": ["query_term", "granularity_level", "original_term", "reason_for_query"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients", "usda_query_candidates"]
            }
        }
    },
    "required": ["dishes"]
}

# Phase 2 Schema - æ‰‹å‹•ã§å®šç¾©ã—ã¦Gemini APIäº’æ›ã«ã™ã‚‹
PHASE_2_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ç²¾ç·»åŒ–ã•ã‚ŒãŸæ–™ç†ãƒªã‚¹ãƒˆ",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "æ–™ç†ã®åç§° (è‹±èª)ã€‚Phase 1ã‹ã‚‰å¼•ãç¶™ãã€å¿…è¦ãªã‚‰ä¿®æ­£ã€‚"},
                    "calculation_strategy": {
                        "type": "string",
                        "enum": ["dish_level", "ingredient_level"],
                        "description": "ã“ã®æ–™ç†ã®æ „é¤Šè¨ˆç®—æ–¹é‡"
                    },
                    "reason_for_strategy": {"type": "string", "description": "ã“ã®è¨ˆç®—æˆ¦ç•¥ã‚’é¸æŠã—ãŸç†ç”±"},
                    "fdc_id": {"type": "integer", "description": "dish_levelã®å ´åˆã«é¸æŠã•ã‚ŒãŸFDC ID"},
                    "usda_source_description": {"type": "string", "description": "dish_levelã®å ´åˆã«é¸æŠã•ã‚ŒãŸFDC IDã®å…¬å¼åç§°"},
                    "reason_for_choice": {"type": "string", "description": "dish_levelã®å ´åˆã€ã“ã®FDC IDã‚’é¸æŠã—ãŸç†ç”±"},
                    "ingredients": {
                        "type": "array",
                        "description": "ææ–™ãƒªã‚¹ãƒˆã€‚å„ææ–™ã«ã¤ã„ã¦FDC IDã¨é¸æŠç†ç”±ã‚’è¨˜è¿°",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ææ–™ã®åç§° (è‹±èª)ã€‚Phase 1ã‹ã‚‰å¼•ãç¶™ãã€å¿…è¦ãªã‚‰ä¿®æ­£"},
                                "fdc_id": {"type": "integer", "description": "é¸æŠã•ã‚ŒãŸFDC IDã€‚ingredient_levelã®å ´åˆã€ã¾ãŸã¯dish_levelã®Fallbackæ™‚ã«è¨­å®š"},
                                "usda_source_description": {"type": "string", "description": "é¸æŠã•ã‚ŒãŸFDC IDã®å…¬å¼åç§°"},
                                "reason_for_choice": {"type": "string", "description": "ã“ã®FDC IDã‚’é¸æŠã—ãŸç†ç”±ã€ã¾ãŸã¯é¸æŠã—ãªã‹ã£ãŸç†ç”±"}
                            },
                            "required": ["ingredient_name"]
                        }
                    }
                },
                "required": ["dish_name", "calculation_strategy", "reason_for_strategy", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}

# å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã«æ—¢å­˜ã‚¹ã‚­ãƒ¼ãƒã‚‚ä¿æŒ
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "ç”»åƒã‹ã‚‰ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®ãƒªã‚¹ãƒˆã€‚",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "ç‰¹å®šã•ã‚ŒãŸæ–™ç†ã®åç§°ã€‚"},
                    "type": {"type": "string", "description": "æ–™ç†ã®ç¨®é¡ï¼ˆä¾‹: ä¸»èœ, å‰¯èœ, ã‚¹ãƒ¼ãƒ—, ãƒ‡ã‚¶ãƒ¼ãƒˆï¼‰ã€‚"},
                    "quantity_on_plate": {"type": "string", "description": "çš¿ã®ä¸Šã«è¼‰ã£ã¦ã„ã‚‹æ–™ç†ã®ãŠãŠã‚ˆãã®é‡ã‚„å€‹æ•°ï¼ˆä¾‹: '1æ¯', '2åˆ‡ã‚Œ', 'ç´„200g'ï¼‰ã€‚"},
                    "ingredients": {
                        "type": "array",
                        "description": "ã“ã®æ–™ç†ã«å«ã¾ã‚Œã‚‹ã¨æ¨å®šã•ã‚Œã‚‹ææ–™ã®ãƒªã‚¹ãƒˆã€‚",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "ææ–™ã®åç§°ã€‚"},
                                "weight_g": {"type": "number", "description": "ãã®ææ–™ã®æ¨å®šé‡é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰ã€‚"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    },
                    "usda_query_candidates": {
                        "type": "array",
                        "description": "ã“ã®æ–™ç†/é£Ÿæã«é–¢é€£ã™ã‚‹USDAã‚¯ã‚¨ãƒªå€™è£œãƒªã‚¹ãƒˆã€‚",
                        "items": {
                            "type": "object",
                            "properties": {
                                "query_term": {"type": "string", "description": "USDAæ¤œç´¢ã«ä½¿ç”¨ã™ã‚‹å…·ä½“çš„ãªã‚¯ã‚¨ãƒªæ–‡å­—åˆ— (è‹±èª)"},
                                "granularity_level": {
                                    "type": "string", 
                                    "enum": ["dish", "ingredient", "branded_product"],
                                    "description": "ã“ã®ã‚¯ã‚¨ãƒªãŒå¯¾è±¡ã¨ã™ã‚‹ç²’åº¦ãƒ¬ãƒ™ãƒ«"
                                },
                                "original_term": {"type": "string", "description": "ã“ã®ã‚¯ã‚¨ãƒªãŒç”±æ¥ã™ã‚‹å…ƒã®æ–™ç†åã¾ãŸã¯é£Ÿæå"},
                                "reason_for_query": {"type": "string", "description": "ã“ã®ã‚¯ã‚¨ãƒªå€™è£œã‚’ç”Ÿæˆã—ãŸç°¡å˜ãªç†ç”±"}
                            },
                            "required": ["query_term", "granularity_level"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients", "usda_query_candidates"]
            }
        }
    },
    "required": ["dishes"]
}

REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA = PHASE_2_GEMINI_SCHEMA 
```

============================================================

ğŸ“ è¨­å®šç®¡ç†
============================================================

ğŸ“„ FILE: app/core/config.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 2180 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:07:57
å­˜åœ¨: âœ…

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    APIè¨­å®šã‚¯ãƒ©ã‚¹
    ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šå€¤ã‚’èª­ã¿è¾¼ã‚€
    """
    # Vertex AIè¨­å®š
    GEMINI_PROJECT_ID: str  # GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDï¼ˆå¿…é ˆï¼‰
    GEMINI_LOCATION: str = "us-central1"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA APIè¨­å®š
    USDA_API_KEY: str  # USDA FoodData Central APIã‚­ãƒ¼ï¼ˆå¿…é ˆï¼‰
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # APIã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç§’æ•°
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1å›ã®æ¤œç´¢ã§å–å¾—ã™ã‚‹æœ€å¤§å€™è£œæ•°
    # ä¸»è¦æ „é¤Šç´ ç•ªå·ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã¨ã—ã¦ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã‚€ï¼‰
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """ä¸»è¦æ „é¤Šç´ ç•ªå·ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®š
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redisã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã®URL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDAãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹æœŸé–“ï¼ˆ1æ™‚é–“ï¼‰
    
    # APIè¨­å®š
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # ã‚µãƒ¼ãƒãƒ¼è¨­å®š
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # APIãƒãƒ¼ã‚¸ãƒ§ãƒ³
    API_VERSION: str = "v1"
    
    # Google Cloudèªè¨¼è¨­å®š
    # GOOGLE_APPLICATION_CREDENTIALSã¯é€šå¸¸ç’°å¢ƒå¤‰æ•°ã§è¨­å®šã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä¸è¦
    # gcloud auth application-default login ã§ã‚‚å¯
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    è¨­å®šã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ï¼‰
    """
    return Settings() 
```

============================================================

ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†
============================================================

ğŸ“„ FILE: app/prompts/__init__.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 114 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:07:57
å­˜åœ¨: âœ…

CONTENT:
```
"""
ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

ğŸ“„ FILE: app/prompts/prompt_loader.py
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 4029 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:41:19
å­˜åœ¨: âœ…

CONTENT:
```
"""
ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ç®¡ç†ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        åˆæœŸåŒ–
        
        Args:
            prompts_dir: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
                        Noneã®å ´åˆã¯ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ç”¨
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        
        Args:
            filename: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å
            
        Returns:
            ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å†…å®¹
            
        Raises:
            FileNotFoundError: ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
            IOError: ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """ãƒ•ã‚§ãƒ¼ã‚º1ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        ãƒ•ã‚§ãƒ¼ã‚º1ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
        
        Args:
            optional_text: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """ãƒ•ã‚§ãƒ¼ã‚º2ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        initial_ai_output: str,
        usda_candidates: str
    ) -> str:
        """
        ãƒ•ã‚§ãƒ¼ã‚º2ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å–å¾—
        
        Args:
            initial_ai_output: ãƒ•ã‚§ãƒ¼ã‚º1ã®AIå‡ºåŠ›ï¼ˆJSONæ–‡å­—åˆ—ï¼‰
            usda_candidates: USDAå€™è£œæƒ…å ±
            
        Returns:
            ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        return template.format(
            initial_ai_output=initial_ai_output,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†èª­ã¿è¾¼ã¿ã‚’ä¿ƒã™"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
============================================================

ğŸ“„ FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 2004 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:15:57
å­˜åœ¨: âœ…

CONTENT:
```
You are an expert culinary analyst and food database specialist. Your primary task is to analyze meal images and identify potential dishes and ingredients, focusing on generating *effective query terms for the USDA FoodData Central database*.

**Your Goals:**

1.  **Identify Dishes & Ingredients:** Recognize distinct dishes and their likely core ingredients from the image.
2.  **Estimate Weights:** Provide a reasonable weight estimate (in grams) for each ingredient.
3.  **Generate USDA Query Candidates:** This is CRITICAL. For each identified dish AND its key ingredients, suggest *multiple, plausible query terms* in English that are likely to yield good results in the USDA FoodData Central database.
    * **Think like a database search:** Consider common names, specific names, and *especially Branded Food names* if recognizable packaging or product types are visible.
    * **Consider Granularity:** Provide queries at different levels:
        * `dish`: For the whole dish (e.g., "Lasagna", "Tuna Salad Sandwich").
        * `ingredient`: For core components (e.g., "Ground Beef", "Cheddar Cheese", "Tuna, canned in oil", "Whole wheat bread").
        * `branded_product`: If a specific brand or product is likely (e.g., "Kraft Macaroni & Cheese", "Hellmann's Real Mayonnaise", "StarKist Chunk Light Tuna in Oil").
    * **Prioritize USDA Likelihood:** Avoid overly generic terms ("Sauce", "Seasoning") or terms unlikely to be in USDA (e.g., "Homemade Dashi Broth"). Focus on searchable food items.
    * **Provide Reasons:** Briefly explain why each query term is suggested.
4.  **Output Format:** Strictly adhere to the provided JSON schema (`Phase1AnalysisResponse`).
5.  **Language:** ALL text outputs MUST be in English.

**Instructions:**

* Analyze the provided image carefully.
* For each dish, list its name, type, quantity, and ingredients (with weights).
* For each dish, provide a list of `USDACandidateQuery` objects.
* Ensure your JSON output is valid according to the schema. 
```

============================================================

ğŸ“„ FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 86 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 16:53:14
å­˜åœ¨: âœ…

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

ğŸ“„ FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 3717 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:18:17
å­˜åœ¨: âœ…

CONTENT:
```
You are an advanced Nutritional Analysis Strategist and USDA Data Matcher. Your mission is to analyze an initial meal assessment and a comprehensive list of USDA FoodData Central (FDC) search results to determine the *optimal strategy for nutritional calculation* for each dish and select the *most accurate FDC IDs*. Your decisions must be **deterministic** and aimed at maximizing **accuracy and stability**.

**Your Core Tasks for EACH Dish:**

1.  **Determine `calculation_strategy`:** Choose either `"dish_level"` or `"ingredient_level"`.
    * **`dish_level`:** Use when a *single, representative FDC ID* accurately describes the *entire dish* and its likely nutritional profile. This is often suitable for:
        * **Specific Branded Products:** If a high-confidence match exists (e.g., "McDonald's Big Mac", "Stouffer's Lasagna"). **Prioritize Branded Foods if a strong match exists.**
        * **Simple, Standardized Items:** If a good Foundation or SR Legacy match exists (e.g., "Apple", "Chicken Breast, grilled", "Milk, 2%").
        * **Standardized Recipes in FNDDS/SR Legacy:** If a *good* FNDDS or SR Legacy entry exists for a common prepared dish (e.g., "Macaroni and Cheese, prepared").
    * **`ingredient_level`:** Use when the dish is complex, highly variable, homemade, or lacks a suitable single FDC ID. This is often suitable for:
        * **Salads, Stir-fries, Stews, Casseroles:** Dishes with many variable components.
        * **Standardized dishes *without* a good FDC match:** If the available dish-level FDC IDs seem inaccurate.
        * When *breaking down* provides higher accuracy (e.g., a specific sandwich where you can identify bread, meat, cheese, and sauce FDC IDs).
    * **Provide `reason_for_strategy`:** Clearly explain *why* you chose this strategy based on the dish and the available USDA data.

2.  **Select FDC IDs:**
    * **If `dish_level`:**
        * Select the *single best FDC ID* for the *entire dish* from the provided USDA candidates.
        * Provide this as the dish `fdc_id` and `usda_source_description`.
        * Provide `reason_for_choice` for this FDC ID.
        * For *each ingredient* listed in the initial analysis, *still attempt to find a plausible FDC ID* and list it. This serves as a **fallback/verification** mechanism, but these FDC IDs *won't* be used for the primary calculation in this strategy. Provide a reason for each ingredient FDC ID selection.
    * **If `ingredient_level`:**
        * Set the dish `fdc_id` and `usda_source_description` to `null`.
        * For *each ingredient*, select the *single best FDC ID* from the provided USDA candidates for that ingredient.
        * Provide these as the `fdc_id` and `usda_source_description` for each ingredient.
        * Provide `reason_for_choice` for each FDC ID selection. If no good match exists, set FDC ID to `null` and explain why.

**FDC ID Selection Guidelines:**

* **Prioritize:** 1. Branded (if strong match) -> 2. Foundation -> 3. SR Legacy -> 4. FNDDS.
* **Relevance:** Choose the ID that best matches the *context* (image, initial name) and has a high score/good description.
* **Data Type:** Consider the nature of the USDA type. Foundation is analytical, SR/FNDDS can be averaged/calculated, Branded is label-based.
* **Ingredients Text (Branded/FNDDS):** Use this to verify if a Branded/FNDDS entry is a reasonable match.

**Output Requirements:**

* Strictly adhere to the provided JSON schema (`Phase2GeminiResponse`).
* Include all required fields, especially `calculation_strategy`, `reason_for_strategy`, `fdc_id`, `usda_source_description`, and `reason_for_choice`.
* ALL text outputs MUST be in English.
* DO NOT perform any nutritional calculations. 
```

============================================================

ğŸ“„ FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 820 bytes
æœ€çµ‚æ›´æ–°: 2025-05-29 17:18:37
å­˜åœ¨: âœ…

CONTENT:
```
Here is the initial meal analysis (Phase 1 Output):
```json
{initial_ai_output}
```

Here are the potential USDA FDC ID candidates based on queries from Phase 1. Review these carefully, noting the FDC ID, Name, Data Type, Brand, and Score:

{usda_candidates}

Based on the initial analysis, the image context (implicitly known from Phase 1), and ALL the provided USDA candidates, please perform the Phase 2 refinement as per the system instructions. For each dish:

1. Decide the calculation_strategy.
2. Provide the reason_for_strategy.
3. Select the best FDC ID(s) according to the chosen strategy.
4. Provide the usda_source_description for each selected FDC ID.
5. Provide the reason_for_choice for each selected FDC ID.

Ensure your response is in English and strictly follows the Phase2GeminiResponse JSON schema. 
```

============================================================

ğŸ¯ SUMMARY
----------------------------------------
ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: 14
å­˜åœ¨ãƒ•ã‚¡ã‚¤ãƒ«æ•°: 14
åˆ†æå®Œäº†æ™‚åˆ»: 2025-05-29 18:32:59

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€test_english_phase2.pyå®Ÿè¡Œæ™‚ã«é–¢ã‚ã‚‹å…¨ã¦ã®
ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Œå…¨ãªå†…å®¹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
