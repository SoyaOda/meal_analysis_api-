================================================================================
MEAL ANALYSIS API - 完全分析パイプライン アーキテクチャ構造とファイル分析
================================================================================
生成日時: 2025-06-05 11:19:19
分析対象: /api/v1/meal-analyses/complete エンドポイント実行時に呼び出される全ファイル
================================================================================

📊 COMPLETE ANALYSIS ARCHITECTURE OVERVIEW
----------------------------------------

🔄 COMPLETE EXECUTION FLOW (4-Phase Integrated Pipeline):
Phase 1: 画像 → Gemini AI → 料理・食材識別 (英語名)
USDA Query: 全食材 → USDA データベース照合 → FDC ID 取得  
Phase 2: Phase1結果 + USDA候補 + 画像 → Gemini AI → 計算戦略決定・栄養精緻化
Nutrition Calculation: 実重量 × USDA栄養データ → 最終栄養価計算・集計

🏗️ INTEGRATED LAYER STRUCTURE:
├── FastAPI Application Layer
│   └── main.py (Server, routing, CORS, error handling)
├── Complete Analysis API Layer  
│   └── meal_analyses_complete.py (Unified endpoint for all phases)
├── Service Layer
│   ├── gemini_service.py (Vertex AI Gemini連携 - Phase1&2)
│   ├── usda_service.py (USDA FoodData Central API連携)
│   └── nutrition_calculation_service.py (Nutrition computation engine)
├── Prompt Management Layer
│   ├── prompt_loader.py (Template loading & management)
│   └── prompt templates (Phase1&2 system/user prompts)
└── Configuration Layer
    └── config.py (Environment variables, settings)

🔧 COMPLETE ANALYSIS TECHNICAL FEATURES:
- 🔗 Unified API Endpoint (/complete): All phases in single request
- 🧠 AI-Driven Strategy Selection: dish_level vs ingredient_level
- 📊 3-Tier Nutrition Aggregation: ingredient → dish → meal  
- 💾 Automatic Result Saving: JSON files with analysis_id
- 🔍 100% USDA Integration: Real nutrition data retrieval
- ⚡ Async Processing: Non-blocking operations throughout
- 🛡️ Comprehensive Error Handling: Per-phase error isolation
- 📈 Real-time Logging: Detailed execution tracking

🎯 KEY IMPROVEMENTS OVER PHASE-BY-PHASE APPROACH:
- Single API call instead of multiple requests
- Automatic data flow between phases  
- Integrated error handling across all phases
- Built-in result persistence and retrieval
- Optimized resource usage with service caching

================================================================================

📁 FastAPIアプリケーション層
============================================================

📄 FILE: app/main.py
--------------------------------------------------
ファイルサイズ: 4,212 bytes
最終更新: 2025-06-05 11:09:24
存在: ✅

CONTENT:
```
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging

from .api.v1.endpoints import meal_analyses, meal_analyses_refine, meal_analyses_complete
from .core.config import get_settings

# ロギングの設定
logging.basicConfig(
    level=logging.DEBUG,  # 一時的にDEBUGレベルに変更
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
    ]
)
logger = logging.getLogger(__name__)

# 設定の取得
settings = get_settings()

# FastAPIアプリケーションの作成
app = FastAPI(
    title="食事分析API (Meal Analysis API)",
    description="食事の画像とテキストを分析し、料理と材料を特定するAPI。USDAデータベースとの連携により栄養価計算の精度を向上。",
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORSミドルウェアの設定（開発環境用）
if settings.FASTAPI_ENV == "development":
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # 本番環境では適切に制限する
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# ルートパスのエンドポイント
@app.get("/")
async def root():
    """APIのルートエンドポイント"""
    return {
        "message": "食事分析API (Meal Analysis API)",
        "version": "2.0.0",
        "docs": "/docs",
        "health": "/health"
    }

# ヘルスチェックエンドポイント
@app.get("/health")
async def health_check():
    """APIのヘルスチェック"""
    return {
        "status": "healthy",
        "service": "meal-analysis-api"
    }

# v1 APIルーターの登録
app.include_router(
    meal_analyses.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API フェーズ2ルーターの登録（/refineエンドポイント）
app.include_router(
    meal_analyses_refine.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Meal Analysis"]
)

# v1 API完全分析ルーターの登録（全フェーズ統合）
app.include_router(
    meal_analyses_complete.router,
    prefix=f"/api/{settings.API_VERSION}/meal-analyses",
    tags=["Complete Meal Analysis"]
)

# スタートアップイベント
@app.on_event("startup")
async def startup_event():
    """アプリケーション起動時の処理"""
    logger.info("Meal Analysis API starting up...")
    logger.info(f"Environment: {settings.FASTAPI_ENV}")
    logger.info(f"API Version: {settings.API_VERSION}")
    logger.info(f"Gemini Model: {settings.GEMINI_MODEL_NAME}")
    logger.info("Phase 2 features with USDA integration enabled")

# シャットダウンイベント
@app.on_event("shutdown")
async def shutdown_event():
    """アプリケーション終了時の処理"""
    logger.info("Meal Analysis API shutting down...")

# グローバルエラーハンドラー
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """予期しないエラーのハンドリング"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "内部サーバーエラーが発生しました。"
            }
        }
    ) 

# メイン実行部分
if __name__ == "__main__":
    import uvicorn
    import os
    
    # 環境変数の設定（必要に応じて）
    os.environ.setdefault("USDA_API_KEY", "vSWtKJ3jYD0Cn9LRyVJUFkuyCt9p8rEtVXz74PZg")
    os.environ.setdefault("GOOGLE_APPLICATION_CREDENTIALS", "/Users/odasoya/meal_analysis_api /service-account-key.json")
    os.environ.setdefault("GEMINI_PROJECT_ID", "recording-diet-ai-3e7cf")
    os.environ.setdefault("GEMINI_LOCATION", "us-central1")
    os.environ.setdefault("GEMINI_MODEL_NAME", "gemini-2.5-flash-preview-05-20")
    
    # サーバー起動
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="debug"
    ) 
```

============================================================

📁 完全分析API エンドポイント層
============================================================

📄 FILE: app/api/v1/endpoints/meal_analyses_complete.py
--------------------------------------------------
ファイルサイズ: 18,773 bytes
最終更新: 2025-06-05 11:00:23
存在: ✅

CONTENT:
```
from fastapi import APIRouter, UploadFile, File, HTTPException, Depends
from fastapi.responses import JSONResponse
import json
import logging
from typing import Optional
from datetime import datetime
import os
import uuid
from pathlib import Path

from app.services.gemini_service import GeminiMealAnalyzer
from app.services.usda_service import USDAService
from app.services.nutrition_calculation_service import NutritionCalculationService
from app.core.config import get_settings

# ロギングの設定
logger = logging.getLogger(__name__)

# ルーターの作成
router = APIRouter()

# 設定の取得
settings = get_settings()

# 結果保存ディレクトリの作成
RESULTS_DIR = Path("analysis_results")
RESULTS_DIR.mkdir(exist_ok=True)

# サービスインスタンスのキャッシュ
_gemini_analyzer = None
_usda_service = None
_nutrition_service = None

async def get_gemini_service():
    """GeminiMealAnalyzerの依存性注入"""
    global _gemini_analyzer
    if _gemini_analyzer is None:
        settings = get_settings()
        _gemini_analyzer = GeminiMealAnalyzer(
            project_id=settings.GEMINI_PROJECT_ID,
            location=settings.GEMINI_LOCATION,
            model_name=settings.GEMINI_MODEL_NAME
        )
    return _gemini_analyzer

async def get_usda_service():
    """USDAServiceの依存性注入"""
    global _usda_service
    if _usda_service is None:
        _usda_service = USDAService()
    return _usda_service

async def get_nutrition_service():
    """NutritionCalculationServiceの依存性注入"""
    global _nutrition_service
    if _nutrition_service is None:
        _nutrition_service = NutritionCalculationService()
    return _nutrition_service

def save_analysis_result(result_data: dict, analysis_id: str) -> str:
    """分析結果をファイルに保存する"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"meal_analysis_{analysis_id}_{timestamp}.json"
        filepath = RESULTS_DIR / filename
        
        # メタデータを追加
        result_data["metadata"] = {
            "analysis_id": analysis_id,
            "timestamp": datetime.now().isoformat(),
            "processing_pipeline": ["phase1", "usda_query", "phase2", "nutrition_calculation"]
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(result_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"Analysis result saved to: {filepath}")
        return str(filepath)
    except Exception as e:
        logger.error(f"Failed to save analysis result: {e}")
        raise HTTPException(status_code=500, detail="Failed to save analysis result")

@router.post("/complete")
async def complete_meal_analysis(
    image: UploadFile = File(...),
    save_results: bool = True,
    gemini_service: GeminiMealAnalyzer = Depends(get_gemini_service),
    usda_service: USDAService = Depends(get_usda_service),
    nutrition_service: NutritionCalculationService = Depends(get_nutrition_service)
):
    """
    完全な食事分析を実行（全フェーズ統合）
    
    - Phase 1: Gemini AIによる画像分析
    - USDA Query: 食材のUSDAデータベース照合
    - Phase 2: 計算戦略決定と栄養価精緻化
    - Nutrition Calculation: 最終栄養価計算
    
    Args:
        image: 分析対象の食事画像
        save_results: 結果を保存するかどうか (デフォルト: True)
    
    Returns:
        完全な分析結果と栄養価計算
    """
    
    analysis_id = str(uuid.uuid4())[:8]  # 短縮版ID
    
    try:
        # 画像の検証
        if not image.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="アップロードされたファイルは画像である必要があります")
        
        # 画像データの読み込み
        image_data = await image.read()
        logger.info(f"[{analysis_id}] Starting complete meal analysis pipeline")
        
        # === Phase 1: 初期画像分析 ===
        logger.info(f"[{analysis_id}] Phase 1: Initial image analysis")
        phase1_result = await gemini_service.analyze_image_and_text(
            image_bytes=image_data,
            image_mime_type=image.content_type,
            optional_text=None
        )
        
        if not phase1_result or "dishes" not in phase1_result:
            raise HTTPException(status_code=422, detail="Phase 1: 画像から料理を検出できませんでした")
        
        logger.info(f"[{analysis_id}] Phase 1 completed - Detected {len(phase1_result['dishes'])} dishes")
        
        # === USDA Query Phase: 食材のUSDAデータベース照合 ===
        logger.info(f"[{analysis_id}] USDA Query Phase: Database matching")
        
        # 全食材のリストを作成
        all_ingredients = []
        for dish in phase1_result["dishes"]:
            for ingredient in dish.get("ingredients", []):
                all_ingredients.append(ingredient["ingredient_name"])
        
        # USDAデータベースでの照合
        usda_matches = {}
        for ingredient_name in all_ingredients:
            try:
                usda_results = await usda_service.search_foods(ingredient_name)
                if usda_results and len(usda_results) > 0:
                    # USDASearchResultItemオブジェクトから辞書に変換
                    best_match = usda_results[0]
                    usda_matches[ingredient_name] = {
                        "fdcId": best_match.fdc_id,
                        "description": best_match.description,
                        "dataType": best_match.data_type,
                        "score": best_match.score
                    }
                    logger.debug(f"[{analysis_id}] USDA match for '{ingredient_name}': FDC ID {best_match.fdc_id}")
                else:
                    logger.warning(f"[{analysis_id}] No USDA match for: {ingredient_name}")
            except Exception as e:
                logger.error(f"[{analysis_id}] USDA search error for '{ingredient_name}': {e}")
        
        logger.info(f"[{analysis_id}] USDA Query completed - {len(usda_matches)}/{len(all_ingredients)} ingredients matched")
        
        # === Phase 2: 計算戦略決定と栄養価精緻化 ===
        logger.info(f"[{analysis_id}] Phase 2: Strategy determination and nutritional refinement")
        
        # Phase 2でGemini AIに計算戦略を決定させる
        phase2_result = await gemini_service.analyze_image_with_usda_context(
            image_bytes=image_data,
            image_mime_type=image.content_type,
            usda_candidates_text=json.dumps(usda_matches),
            initial_ai_output_text=json.dumps(phase1_result)
        )
        
        if not phase2_result or "dishes" not in phase2_result:
            raise HTTPException(status_code=422, detail="Phase 2: 栄養価の精緻化に失敗しました")
        
        logger.info(f"[{analysis_id}] Phase 2 completed - Strategy determined and nutrition refined")
        
        # === Nutrition Calculation Phase: 最終栄養価計算 ===
        logger.info(f"[{analysis_id}] Nutrition Calculation Phase: Final nutrition computation")
        
        # Phase 2の結果をベースに栄養計算を実行
        final_result = phase2_result.copy()
        
        # 各料理の栄養価を計算
        for dish in final_result.get("dishes", []):
            calculation_strategy = dish.get("calculation_strategy", "ingredient_level")
            
            if calculation_strategy == "ingredient_level":
                # 食材レベルの計算
                total_calories = 0.0
                total_protein = 0.0
                total_carbs = 0.0
                total_fat = 0.0
                
                for ingredient in dish.get("ingredients", []):
                    fdc_id = ingredient.get("fdc_id")
                    weight_g = 0.0
                    
                    # Phase 1から重量を取得
                    for phase1_dish in phase1_result.get("dishes", []):
                        if phase1_dish["dish_name"] == dish["dish_name"]:
                            for phase1_ingredient in phase1_dish.get("ingredients", []):
                                if phase1_ingredient["ingredient_name"] == ingredient["ingredient_name"]:
                                    weight_g = phase1_ingredient["weight_g"]
                                    break
                            break
                    
                    ingredient["weight_g"] = weight_g
                    
                    # USDAから栄養データを取得
                    if fdc_id:
                        try:
                            nutrition_data = await usda_service.get_food_details_for_nutrition(fdc_id)
                            if nutrition_data:
                                ingredient["key_nutrients_per_100g"] = nutrition_data
                                
                                # 実際の栄養価を計算 (重量 * 100gあたり栄養価 / 100)
                                multiplier = weight_g / 100.0
                                actual_calories = (nutrition_data.get("calories_kcal", 0) or 0) * multiplier
                                actual_protein = (nutrition_data.get("protein_g", 0) or 0) * multiplier
                                actual_carbs = (nutrition_data.get("carbohydrates_g", 0) or 0) * multiplier
                                actual_fat = (nutrition_data.get("fat_g", 0) or 0) * multiplier
                                
                                ingredient["actual_nutrients"] = {
                                    "calories_kcal": round(actual_calories, 2),
                                    "protein_g": round(actual_protein, 2),
                                    "carbohydrates_g": round(actual_carbs, 2),
                                    "fat_g": round(actual_fat, 2)
                                }
                                
                                # 料理全体の栄養価に加算
                                total_calories += actual_calories
                                total_protein += actual_protein
                                total_carbs += actual_carbs
                                total_fat += actual_fat
                                
                                logger.debug(f"[{analysis_id}] Calculated nutrition for {ingredient['ingredient_name']}: {actual_calories:.2f} kcal")
                            else:
                                logger.warning(f"[{analysis_id}] No nutrition data for FDC ID {fdc_id}")
                                ingredient["key_nutrients_per_100g"] = None
                                ingredient["actual_nutrients"] = None
                        except Exception as e:
                            logger.error(f"[{analysis_id}] Error getting nutrition data for FDC ID {fdc_id}: {e}")
                            ingredient["key_nutrients_per_100g"] = None
                            ingredient["actual_nutrients"] = None
                    else:
                        ingredient["key_nutrients_per_100g"] = None
                        ingredient["actual_nutrients"] = None
                
                # 料理全体の栄養価を設定
                dish["dish_total_actual_nutrients"] = {
                    "calories_kcal": round(total_calories, 2),
                    "protein_g": round(total_protein, 2),
                    "carbohydrates_g": round(total_carbs, 2),
                    "fat_g": round(total_fat, 2)
                }
                
            elif calculation_strategy == "dish_level":
                # 料理レベルの計算
                dish_fdc_id = dish.get("fdc_id")
                dish_weight = sum(
                    next((phase1_ingredient["weight_g"] for phase1_dish in phase1_result.get("dishes", [])
                          if phase1_dish["dish_name"] == dish["dish_name"]
                          for phase1_ingredient in phase1_dish.get("ingredients", [])), 0)
                    for _ in [None]  # 単一の合計重量計算
                )
                
                if dish_fdc_id and dish_weight > 0:
                    try:
                        nutrition_data = await usda_service.get_food_details_for_nutrition(dish_fdc_id)
                        if nutrition_data:
                            dish["key_nutrients_per_100g"] = nutrition_data
                            
                            # 料理全体の栄養価を計算
                            multiplier = dish_weight / 100.0
                            dish["dish_total_actual_nutrients"] = {
                                "calories_kcal": round((nutrition_data.get("calories_kcal", 0) or 0) * multiplier, 2),
                                "protein_g": round((nutrition_data.get("protein_g", 0) or 0) * multiplier, 2),
                                "carbohydrates_g": round((nutrition_data.get("carbohydrates_g", 0) or 0) * multiplier, 2),
                                "fat_g": round((nutrition_data.get("fat_g", 0) or 0) * multiplier, 2)
                            }
                        else:
                            dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
                    except Exception as e:
                        logger.error(f"[{analysis_id}] Error getting dish nutrition data for FDC ID {dish_fdc_id}: {e}")
                        dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
                else:
                    dish["dish_total_actual_nutrients"] = {"calories_kcal": 0, "protein_g": 0, "carbohydrates_g": 0, "fat_g": 0}
        
        # 食事全体の栄養価を計算
        meal_total_calories = 0.0
        meal_total_protein = 0.0
        meal_total_carbs = 0.0
        meal_total_fat = 0.0
        
        for dish in final_result.get("dishes", []):
            dish_nutrients = dish.get("dish_total_actual_nutrients", {})
            meal_total_calories += dish_nutrients.get("calories_kcal", 0)
            meal_total_protein += dish_nutrients.get("protein_g", 0)
            meal_total_carbs += dish_nutrients.get("carbohydrates_g", 0)
            meal_total_fat += dish_nutrients.get("fat_g", 0)
        
        final_result["total_meal_nutrients"] = {
            "calories_kcal": round(meal_total_calories, 2),
            "protein_g": round(meal_total_protein, 2),
            "carbohydrates_g": round(meal_total_carbs, 2),
            "fat_g": round(meal_total_fat, 2)
        }
        
        logger.info(f"[{analysis_id}] Nutrition Calculation completed - Total calories: {meal_total_calories:.2f} kcal")
        

        
        # === 結果の統合と保存 ===
        complete_result = {
            "analysis_id": analysis_id,
            "phase1_result": phase1_result,
            "usda_matches_count": len(usda_matches),
            "usda_matches": usda_matches,
            "phase2_result": phase2_result,
            "final_nutrition_result": final_result,
            "processing_summary": {
                "total_dishes": len(final_result.get("dishes", [])),
                "total_ingredients": sum(len(dish.get("ingredients", [])) for dish in final_result.get("dishes", [])),
                "usda_match_rate": f"{len(usda_matches)}/{len(all_ingredients)} ({len(usda_matches)/len(all_ingredients)*100:.1f}%)" if all_ingredients else "0/0 (0%)",
                "total_calories": final_result.get("total_meal_nutrients", {}).get("calories_kcal", 0),
                "pipeline_status": "completed"
            }
        }
        
        # 結果の保存
        saved_file = None
        if save_results:
            saved_file = save_analysis_result(complete_result, analysis_id)
            complete_result["saved_to"] = saved_file
        
        logger.info(f"[{analysis_id}] Complete analysis pipeline finished successfully")
        
        return JSONResponse(
            status_code=200,
            content=complete_result
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[{analysis_id}] Complete analysis failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Complete analysis failed: {str(e)}"
        )

@router.get("/results")
async def list_saved_results():
    """保存された分析結果の一覧を取得"""
    try:
        results = []
        for file_path in RESULTS_DIR.glob("meal_analysis_*.json"):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    results.append({
                        "filename": file_path.name,
                        "analysis_id": data.get("analysis_id"),
                        "timestamp": data.get("metadata", {}).get("timestamp"),
                        "summary": data.get("processing_summary", {}),
                        "file_path": str(file_path)
                    })
            except Exception as e:
                logger.error(f"Error reading result file {file_path}: {e}")
                continue
        
        # タイムスタンプでソート（新しい順）
        results.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        
        return {
            "total_results": len(results),
            "results": results
        }
    except Exception as e:
        logger.error(f"Failed to list saved results: {e}")
        raise HTTPException(status_code=500, detail="Failed to list saved results")

@router.get("/results/{analysis_id}")
async def get_saved_result(analysis_id: str):
    """特定の分析結果を取得"""
    try:
        # analysis_idに一致するファイルを検索
        matching_files = list(RESULTS_DIR.glob(f"meal_analysis_{analysis_id}_*.json"))
        
        if not matching_files:
            raise HTTPException(status_code=404, detail=f"Analysis ID '{analysis_id}' not found")
        
        # 最新のファイルを取得（複数ある場合）
        latest_file = max(matching_files, key=lambda p: p.stat().st_mtime)
        
        with open(latest_file, 'r', encoding='utf-8') as f:
            result_data = json.load(f)
        
        return result_data
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get saved result for ID {analysis_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to get saved result") 
```

============================================================

📁 サービス層
============================================================

📄 FILE: app/services/gemini_service.py
--------------------------------------------------
ファイルサイズ: 9,130 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
import vertexai
from vertexai.generative_models import GenerativeModel, Part, GenerationConfig, HarmCategory, HarmBlockThreshold
from typing import Dict, Optional
import json
import logging
from PIL import Image
import io

from ..api.v1.schemas.meal import REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
from ..prompts import PromptLoader

logger = logging.getLogger(__name__)

# Geminiの構造化出力のためのJSONスキーマを定義
MEAL_ANALYSIS_GEMINI_SCHEMA = {
    "type": "object",
    "properties": {
        "dishes": {
            "type": "array",
            "description": "画像から特定された料理のリスト。",
            "items": {
                "type": "object",
                "properties": {
                    "dish_name": {"type": "string", "description": "特定された料理の名称。"},
                    "type": {"type": "string", "description": "料理の種類（例: 主菜, 副菜, スープ, デザート）。"},
                    "quantity_on_plate": {"type": "string", "description": "皿の上に載っている料理のおおよその量や個数（例: '1杯', '2切れ', '約200g'）。"},
                    "ingredients": {
                        "type": "array",
                        "description": "この料理に含まれると推定される材料のリスト。",
                        "items": {
                            "type": "object",
                            "properties": {
                                "ingredient_name": {"type": "string", "description": "材料の名称。"},
                                "weight_g": {"type": "number", "description": "その材料の推定重量（グラム単位）。"}
                            },
                            "required": ["ingredient_name", "weight_g"]
                        }
                    }
                },
                "required": ["dish_name", "type", "quantity_on_plate", "ingredients"]
            }
        }
    },
    "required": ["dishes"]
}


class GeminiMealAnalyzer:
    """Vertex AI経由でGeminiを使用して食事画像を分析するクラス"""
    
    def __init__(self, project_id: str, location: str, model_name: str = "gemini-1.5-flash"):
        """
        初期化
        
        Args:
            project_id: GCPプロジェクトID
            location: Vertex AIのロケーション（例: us-central1）
            model_name: 使用するモデル名
        """
        # Vertex AIの初期化
        vertexai.init(project=project_id, location=location)
        
        # モデルの初期化
        self.model = GenerativeModel(model_name=model_name)
        
        # プロンプトローダーの初期化
        self.prompt_loader = PromptLoader()
        
        # generation_configを作成
        self.generation_config = GenerationConfig(
            temperature=0.2,
            top_p=0.9,
            top_k=20,
            max_output_tokens=8192,
            response_mime_type="application/json",
            response_schema=MEAL_ANALYSIS_GEMINI_SCHEMA
        )
        
        # セーフティ設定
        self.safety_settings = {
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }
    
    async def analyze_image_and_text(
        self, 
        image_bytes: bytes, 
        image_mime_type: str, 
        optional_text: Optional[str] = None
    ) -> Dict:
        """
        画像とテキストを分析して食事情報を抽出
        
        Args:
            image_bytes: 画像のバイトデータ
            image_mime_type: 画像のMIMEタイプ
            optional_text: オプションのテキスト説明
            
        Returns:
            分析結果の辞書
            
        Raises:
            RuntimeError: Gemini APIエラー時
        """
        try:
            # プロンプトローダーからプロンプトを取得
            system_prompt = self.prompt_loader.get_phase1_system_prompt()
            user_prompt = self.prompt_loader.get_phase1_user_prompt(optional_text)
            
            # 完全なプロンプトを構築
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # コンテンツリストを作成
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # Gemini APIを呼び出し（非同期メソッドを使用）
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=self.generation_config,
                safety_settings=self.safety_settings
            )
            
            # レスポンスのテキストを取得
            if not response.text:
                raise ValueError("No response returned from Gemini.")
            
            # JSONレスポンスをパース
            result = json.loads(response.text)
            
            logger.info(f"Gemini analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            raise RuntimeError(f"Error processing response from Gemini: {e}") from e
        except Exception as e:
            logger.error(f"Vertex AI/Gemini API error: {e}")
            raise RuntimeError(f"Vertex AI/Gemini API request failed: {e}") from e
    
    async def analyze_image_with_usda_context(
        self,
        image_bytes: bytes,
        image_mime_type: str,
        usda_candidates_text: str,
        initial_ai_output_text: Optional[str] = None
    ) -> Dict:
        """
        USDAコンテキストを使用して画像を再分析（フェーズ2）
        
        Args:
            image_bytes: 画像のバイトデータ
            image_mime_type: 画像のMIMEタイプ
            usda_candidates_text: USDA候補情報のフォーマット済みテキスト
            initial_ai_output_text: フェーズ1のAI出力（JSON文字列）
            
        Returns:
            精緻化された分析結果の辞書
            
        Raises:
            RuntimeError: Gemini APIエラー時
        """
        try:
            # プロンプトローダーからプロンプトを取得
            system_prompt = self.prompt_loader.get_phase2_system_prompt()
            user_prompt = self.prompt_loader.get_phase2_user_prompt(
                usda_candidates=usda_candidates_text,
                initial_ai_output=initial_ai_output_text
            )
            
            # 完全なプロンプトを構築
            full_prompt = f"{system_prompt}\n\n{user_prompt}"
            
            # コンテンツリストを作成
            contents = [
                Part.from_text(full_prompt),
                Part.from_data(
                    data=image_bytes,
                    mime_type=image_mime_type
                )
            ]
            
            # フェーズ2用のGeneration Config
            phase2_generation_config = GenerationConfig(
                temperature=0.2,
                top_p=0.9,
                top_k=20,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA
            )
            
            # Gemini APIを呼び出し
            response = await self.model.generate_content_async(
                contents=contents,
                generation_config=phase2_generation_config,
                safety_settings=self.safety_settings
            )
            
            # レスポンスのテキストを取得
            if not response.text:
                raise ValueError("No response returned from Gemini (Phase 2).")
            
            # JSONレスポンスをパース
            result = json.loads(response.text)
            
            logger.info(f"Gemini phase 2 analysis completed successfully. Found {len(result.get('dishes', []))} dishes.")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error in phase 2: {e}. Raw response: {getattr(response, 'text', 'N/A')}")
            raise RuntimeError(f"Error processing response from Gemini (Phase 2): {e}") from e
        except Exception as e:
            import traceback
            logger.error(f"Vertex AI/Gemini API error in phase 2: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            raise RuntimeError(f"Vertex AI/Gemini (Phase 2) API request failed: {e}") from e 
```

============================================================

📄 FILE: app/services/usda_service.py
--------------------------------------------------
ファイルサイズ: 16,154 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
# app/services/usda_service.py
import httpx
import json
import logging
from typing import List, Optional, Dict, Any
from functools import lru_cache

from ..core.config import get_settings

logger = logging.getLogger(__name__)


class USDANutrient:
    """USDA栄養素情報を表すクラス"""
    def __init__(self, name: str, amount: float, unit_name: str, 
                 nutrient_id: Optional[int] = None, 
                 nutrient_number: Optional[str] = None):
        self.name = name
        self.amount = amount
        self.unit_name = unit_name
        self.nutrient_id = nutrient_id
        self.nutrient_number = nutrient_number


class USDASearchResultItem:
    """USDA検索結果アイテムを表すクラス"""
    def __init__(self, fdc_id: int, description: str, 
                 data_type: Optional[str] = None,
                 brand_owner: Optional[str] = None,
                 ingredients_text: Optional[str] = None,
                 food_nutrients: List[USDANutrient] = None,
                 score: Optional[float] = None):
        self.fdc_id = fdc_id
        self.description = description
        self.data_type = data_type
        self.brand_owner = brand_owner
        self.ingredients_text = ingredients_text
        self.food_nutrients = food_nutrients or []
        self.score = score


class USDAService:
    """USDA FoodData Central APIとの通信を管理するサービスクラス"""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.USDA_API_KEY
        self.base_url = settings.USDA_API_BASE_URL
        self.timeout = settings.USDA_API_TIMEOUT
        self.key_nutrient_numbers = settings.USDA_KEY_NUTRIENT_NUMBERS
        
        if not self.api_key:
            logger.error("USDA_API_KEY is not configured.")
            raise ValueError("USDA API key not configured.")
        
        # httpx.AsyncClientの設定
        self.client = httpx.AsyncClient(
            timeout=self.timeout,
            headers={"X-Api-Key": self.api_key}
        )
    
    async def search_foods(
        self,
        query: str,
        data_types: Optional[List[str]] = None,
        page_size: int = 5,
        page_number: int = 1,
        sort_by: str = "score",
        sort_order: str = "desc"
    ) -> List[USDASearchResultItem]:
        """
        USDA FoodData Central APIで食品を検索
        
        Args:
            query: 検索クエリ文字列
            data_types: データタイプのリスト（例: ["Foundation", "SR Legacy", "Branded"]）
            page_size: 1ページあたりの結果数
            page_number: 取得するページ番号
            sort_by: ソートキー
            sort_order: ソート順（"asc" または "desc"）
            
        Returns:
            USDASearchResultItemのリスト
        """
        params = {
            "query": query,
            "api_key": self.api_key,
            "pageSize": page_size,
            "pageNumber": page_number,
            "sortBy": sort_by,
            "sortOrder": sort_order
        }
        
        if data_types:
            # データタイプをカンマ区切り文字列として渡す
            params["dataType"] = ",".join(data_types)
        
        try:
            logger.info(f"USDA API search: query='{query}', page_size={page_size}")
            response = await self.client.get(f"{self.base_url}/foods/search", params=params)
            
            # レートリミット情報のログ
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            data = response.json()
            
            results = []
            for food_data in data.get("foods", [])[:page_size]:
                nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
                
                results.append(USDASearchResultItem(
                    fdc_id=food_data.get("fdcId"),
                    description=food_data.get("description"),
                    data_type=food_data.get("dataType"),
                    brand_owner=food_data.get("brandOwner"),
                    ingredients_text=food_data.get("ingredients"),
                    food_nutrients=nutrients_extracted,
                    score=food_data.get("score")
                ))
            
            logger.info(f"USDA API search returned {len(results)} results for query '{query}'")
            return results
            
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded. Detail: {e.response.text}") from e
            raise RuntimeError(f"USDA API error: {e.response.status_code} - {e.response.text}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed: {str(e)}")
            raise RuntimeError(f"USDA API request failed: {str(e)}") from e
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            logger.error(f"USDA API response parsing error: {str(e)}")
            raise RuntimeError(f"USDA API response parsing error: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error in USDAService.search_foods: {str(e)}")
            raise RuntimeError(f"Unexpected error in USDA service: {str(e)}") from e
    
    def _extract_nutrients(self, food_nutrients: List[Dict[str, Any]]) -> List[USDANutrient]:
        """
        foodNutrientsデータから主要栄養素を抽出
        
        Args:
            food_nutrients: USDA APIから返される栄養素データのリスト
            
        Returns:
            USDANutrientのリスト
        """
        nutrients_extracted = []
        
        for nutrient_entry in food_nutrients:
            # 栄養素情報の抽出（データ構造はフォーマットによって異なる）
            nutrient_detail = nutrient_entry.get("nutrient", {})
            amount = nutrient_entry.get("amount")
            
            # Branded Foodsのabridgedフォーマットへの対応
            if not nutrient_detail and "nutrientId" in nutrient_entry:
                nutrient_id = nutrient_entry.get("nutrientId")
                name = nutrient_entry.get("nutrientName")
                number = nutrient_entry.get("nutrientNumber")
                unit_name = nutrient_entry.get("unitName")
                amount = nutrient_entry.get("value")  # Branded abridgedでは"value"
            else:
                # SR Legacy, Foundation, または full Branded
                nutrient_id = nutrient_detail.get("id")
                name = nutrient_detail.get("name")
                number = nutrient_detail.get("number")
                unit_name = nutrient_detail.get("unitName")
            
            # 主要栄養素のみを抽出
            if number and str(number) in self.key_nutrient_numbers:
                if name and amount is not None and unit_name:
                    nutrients_extracted.append(USDANutrient(
                        name=name,
                        amount=float(amount),
                        unit_name=unit_name,
                        nutrient_id=int(nutrient_id) if nutrient_id else None,
                        nutrient_number=str(number) if number else None
                    ))
        
        return nutrients_extracted
    
    async def get_food_details(
        self, 
        fdc_id: int, 
        format: str = "full",
        target_nutrient_numbers: Optional[List[str]] = None
    ) -> Optional[USDASearchResultItem]:
        """
        特定のFDC IDの食品詳細情報を取得
        
        Args:
            fdc_id: 食品のFDC ID
            format: レスポンス形式（"abridged" または "full"）
            target_nutrient_numbers: 取得する栄養素番号のリスト
            
        Returns:
            USDASearchResultItem または None
        """
        params = {
            "api_key": self.api_key,
            "format": format
        }
        
        if target_nutrient_numbers:
            params["nutrients"] = ",".join(target_nutrient_numbers)
        
        try:
            logger.info(f"USDA API get food details: fdc_id={fdc_id}")
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            response.raise_for_status()
            
            food_data = response.json()
            nutrients_extracted = self._extract_nutrients(food_data.get("foodNutrients", []))
            
            return USDASearchResultItem(
                fdc_id=food_data.get("fdcId"),
                description=food_data.get("description"),
                data_type=food_data.get("dataType"),
                brand_owner=food_data.get("brandOwner"),
                ingredients_text=food_data.get("ingredients"),
                food_nutrients=nutrients_extracted
            )
            
        except Exception as e:
            logger.error(f"Error fetching food details for FDC ID {fdc_id}: {str(e)}")
            return None

    async def get_food_details_for_nutrition(self, fdc_id: int) -> Optional[Dict[str, float]]:
        """
        栄養計算用の食品詳細情報を取得（仕様書準拠）
        
        入力: FDC ID
        処理: キャッシュ確認後、必要ならUSDA APIから食品詳細を取得し、主要栄養素（設定ファイルで定義されたID）を100gあたりで抽出・パース。結果をキャッシュに保存。
        出力: 100gあたりの主要栄養素辞書、または None。
        
        Args:
            fdc_id: 食品のFDC ID
            
        Returns:
            Optional[Dict[str, float]]: 100gあたりの主要栄養素辞書、または None
        """
        if not fdc_id:
            logger.warning("Invalid FDC ID provided")
            return None
        
        try:
            # TODO: 将来的にキャッシュ戦略を実装（Redis等）
            # 現状は直接APIから取得
            
            logger.info(f"USDA API get food details for nutrition: fdc_id={fdc_id}")
            
            params = {
                "api_key": self.api_key,
                "format": "full",  # 詳細な栄養情報が必要
                "nutrients": ",".join(self.key_nutrient_numbers)  # 主要栄養素のみを取得
            }
            
            response = await self.client.get(f"{self.base_url}/food/{fdc_id}", params=params)
            
            # レートリミット情報のログ
            if "X-RateLimit-Remaining" in response.headers:
                logger.info(f"USDA API Rate Limit Remaining: {response.headers.get('X-RateLimit-Remaining')}")
            
            response.raise_for_status()
            food_data_raw = response.json()
            
            # 主要栄養素を抽出・パース
            key_nutrients = self._parse_nutrients_for_calculation(food_data_raw)
            
            if key_nutrients:
                logger.info(f"Successfully extracted {len(key_nutrients)} key nutrients for FDC ID {fdc_id}")
                # TODO: 将来的にここでキャッシュに保存
                return key_nutrients
            else:
                logger.warning(f"No key nutrients found for FDC ID {fdc_id}")
                return None
                
        except httpx.HTTPStatusError as e:
            logger.error(f"USDA API HTTP error for FDC ID {fdc_id}: {e.response.status_code} - {e.response.text}")
            if e.response.status_code == 404:
                logger.warning(f"Food with FDC ID {fdc_id} not found")
                return None
            elif e.response.status_code == 429:
                raise RuntimeError(f"USDA API rate limit exceeded for FDC ID {fdc_id}") from e
            raise RuntimeError(f"USDA API error for FDC ID {fdc_id}: {e.response.status_code}") from e
        except httpx.RequestError as e:
            logger.error(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}")
            raise RuntimeError(f"USDA API request failed for FDC ID {fdc_id}: {str(e)}") from e
        except Exception as e:
            logger.error(f"Unexpected error getting food details for nutrition (FDC ID {fdc_id}): {str(e)}")
            return None

    def _parse_nutrients_for_calculation(self, food_data_raw: dict) -> Dict[str, float]:
        """
        USDA APIレスポンスから栄養計算用の主要栄養素を抽出（内部メソッド）
        
        Args:
            food_data_raw: USDA APIからの生の食品データ
            
        Returns:
            Dict[str, float]: 主要栄養素辞書（キーは標準化された名前）
        """
        key_nutrients = {}
        
        try:
            food_nutrients = food_data_raw.get("foodNutrients", [])
            
            for nutrient_entry in food_nutrients:
                # 栄養素情報の抽出（データ構造はフォーマットによって異なる）
                nutrient_detail = nutrient_entry.get("nutrient", {})
                amount = nutrient_entry.get("amount")
                
                # Branded Foodsのabridgedフォーマットへの対応
                if not nutrient_detail and "nutrientId" in nutrient_entry:
                    number = nutrient_entry.get("nutrientNumber")
                    amount = nutrient_entry.get("value")  # Branded abridgedでは"value"
                else:
                    # SR Legacy, Foundation, または full Branded
                    number = nutrient_detail.get("number")
                
                # 主要栄養素のマッピング（栄養素番号から標準化されたキー名へ）
                if number and str(number) in self.key_nutrient_numbers and amount is not None:
                    if str(number) == "208":  # Energy (calories)
                        key_nutrients["calories_kcal"] = float(amount)
                    elif str(number) == "203":  # Protein
                        key_nutrients["protein_g"] = float(amount)
                    elif str(number) == "204":  # Total lipid (fat)
                        key_nutrients["fat_g"] = float(amount)
                    elif str(number) == "205":  # Carbohydrate, by difference
                        key_nutrients["carbohydrates_g"] = float(amount)
                    elif str(number) == "291":  # Fiber, total dietary (optional)
                        key_nutrients["fiber_g"] = float(amount)
                    elif str(number) == "269":  # Sugars, total (optional)
                        key_nutrients["sugars_g"] = float(amount)
                    elif str(number) == "307":  # Sodium (optional)
                        key_nutrients["sodium_mg"] = float(amount)
            
            # 必須栄養素が見つからない場合は0.0として設定
            essential_nutrients = ["calories_kcal", "protein_g", "fat_g", "carbohydrates_g"]
            for nutrient in essential_nutrients:
                if nutrient not in key_nutrients:
                    key_nutrients[nutrient] = 0.0
                    logger.debug(f"Missing essential nutrient {nutrient}, set to 0.0")
            
            logger.debug(f"Parsed key nutrients: {key_nutrients}")
            return key_nutrients
            
        except Exception as e:
            logger.error(f"Error parsing nutrients for calculation: {str(e)}")
            return {}
    
    async def close_client(self):
        """HTTPクライアントをクローズ"""
        await self.client.aclose()


# FastAPIの依存性注入用関数
async def get_usda_service():
    """
    USDAServiceのインスタンスを提供する依存性注入関数
    """
    service = USDAService()
    try:
        yield service
    finally:
        await service.close_client() 
```

============================================================

📄 FILE: app/services/nutrition_calculation_service.py
--------------------------------------------------
ファイルサイズ: 6,979 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
"""
栄養素計算サービス

このサービスは純粋な計算ロジックを提供します：
1. 100gあたりの栄養素データから実際の栄養素を計算
2. 食材リストから料理全体の栄養素を集計
3. 料理リストから食事全体の栄養素を集計
"""

import logging
from typing import List, Optional, Dict
from ..api.v1.schemas.meal import CalculatedNutrients, RefinedIngredient, RefinedDish

logger = logging.getLogger(__name__)


class NutritionCalculationService:
    """栄養素計算サービスクラス"""
    
    @staticmethod
    def calculate_actual_nutrients(
        key_nutrients_per_100g: Dict[str, float], 
        estimated_weight_g: float
    ) -> CalculatedNutrients:
        """
        100gあたりの主要栄養素データから実際の栄養素量を計算
        
        Args:
            key_nutrients_per_100g: 100gあたりの主要栄養素データ
            estimated_weight_g: 推定グラム数
            
        Returns:
            CalculatedNutrients: 計算済み栄養素オブジェクト
        """
        if not key_nutrients_per_100g or estimated_weight_g <= 0:
            logger.warning(f"Invalid input: key_nutrients_per_100g={key_nutrients_per_100g}, estimated_weight_g={estimated_weight_g}")
            return CalculatedNutrients()  # デフォルト値（全て0.0）を返す
        
        try:
            # 計算式: (Nutrient_Value_per_100g / 100) × estimated_weight_g
            multiplier = estimated_weight_g / 100.0
            
            # 各栄養素を計算（見つからない/Noneの場合は0.0として扱う）
            calories_kcal = round((key_nutrients_per_100g.get('calories_kcal', 0.0) or 0.0) * multiplier, 2)
            protein_g = round((key_nutrients_per_100g.get('protein_g', 0.0) or 0.0) * multiplier, 2)
            carbohydrates_g = round((key_nutrients_per_100g.get('carbohydrates_g', 0.0) or 0.0) * multiplier, 2)
            fat_g = round((key_nutrients_per_100g.get('fat_g', 0.0) or 0.0) * multiplier, 2)
            
            result = CalculatedNutrients(
                calories_kcal=calories_kcal,
                protein_g=protein_g,
                carbohydrates_g=carbohydrates_g,
                fat_g=fat_g
            )
            
            logger.debug(f"Calculated nutrients for {estimated_weight_g}g: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error calculating actual nutrients: {e}")
            return CalculatedNutrients()  # エラー時はデフォルト値を返す
    
    @staticmethod
    def aggregate_nutrients_for_dish_from_ingredients(
        ingredients: List[RefinedIngredient]
    ) -> CalculatedNutrients:
        """
        材料リストから料理全体の栄養素を集計
        
        Args:
            ingredients: RefinedIngredientのリスト（各要素は計算済みのactual_nutrientsを持つ）
            
        Returns:
            CalculatedNutrients: 料理の集計栄養素
        """
        if not ingredients:
            logger.warning("No ingredients provided for aggregation")
            return CalculatedNutrients()
        
        try:
            total_calories = 0.0
            total_protein = 0.0
            total_carbohydrates = 0.0
            total_fat = 0.0
            
            calculated_count = 0
            
            for ingredient in ingredients:
                if ingredient.actual_nutrients:
                    total_calories += ingredient.actual_nutrients.calories_kcal
                    total_protein += ingredient.actual_nutrients.protein_g
                    total_carbohydrates += ingredient.actual_nutrients.carbohydrates_g
                    total_fat += ingredient.actual_nutrients.fat_g
                    calculated_count += 1
                else:
                    logger.warning(f"Ingredient '{ingredient.ingredient_name}' has no actual_nutrients")
            
            # 小数点以下2桁に丸める
            result = CalculatedNutrients(
                calories_kcal=round(total_calories, 2),
                protein_g=round(total_protein, 2),
                carbohydrates_g=round(total_carbohydrates, 2),
                fat_g=round(total_fat, 2)
            )
            
            logger.info(f"Aggregated nutrients from {calculated_count}/{len(ingredients)} ingredients: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error aggregating nutrients for dish: {e}")
            return CalculatedNutrients()
    
    @staticmethod
    def aggregate_nutrients_for_meal(
        dishes: List[RefinedDish]
    ) -> CalculatedNutrients:
        """
        料理リストから食事全体の栄養素を集計
        
        Args:
            dishes: RefinedDishのリスト（各要素は計算済みのdish_total_actual_nutrientsを持つ）
            
        Returns:
            CalculatedNutrients: 食事全体の総栄養素
        """
        if not dishes:
            logger.warning("No dishes provided for meal aggregation")
            return CalculatedNutrients()
        
        try:
            total_calories = 0.0
            total_protein = 0.0
            total_carbohydrates = 0.0
            total_fat = 0.0
            
            calculated_count = 0
            
            for dish in dishes:
                if dish.dish_total_actual_nutrients:
                    total_calories += dish.dish_total_actual_nutrients.calories_kcal
                    total_protein += dish.dish_total_actual_nutrients.protein_g
                    total_carbohydrates += dish.dish_total_actual_nutrients.carbohydrates_g
                    total_fat += dish.dish_total_actual_nutrients.fat_g
                    calculated_count += 1
                else:
                    logger.warning(f"Dish '{dish.dish_name}' has no dish_total_actual_nutrients")
            
            # 小数点以下2桁に丸める
            result = CalculatedNutrients(
                calories_kcal=round(total_calories, 2),
                protein_g=round(total_protein, 2),
                carbohydrates_g=round(total_carbohydrates, 2),
                fat_g=round(total_fat, 2)
            )
            
            logger.info(f"Aggregated meal nutrients from {calculated_count}/{len(dishes)} dishes: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error aggregating nutrients for meal: {e}")
            return CalculatedNutrients()


# サービスインスタンスを取得するファクトリ関数
def get_nutrition_calculation_service() -> NutritionCalculationService:
    """
    栄養計算サービスインスタンスを取得
    
    Returns:
        NutritionCalculationService: 栄養計算サービスインスタンス
    """
    return NutritionCalculationService() 
```

============================================================

📁 設定管理
============================================================

📄 FILE: app/core/config.py
--------------------------------------------------
ファイルサイズ: 2,180 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
from typing import Optional, List
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    """
    API設定クラス
    環境変数から設定値を読み込む
    """
    # Vertex AI設定
    GEMINI_PROJECT_ID: str  # GCPプロジェクトID（必須）
    GEMINI_LOCATION: str = "us-central1"  # デフォルトのロケーション
    GEMINI_MODEL_NAME: str = "gemini-1.5-flash"
    
    # USDA API設定
    USDA_API_KEY: str  # USDA FoodData Central APIキー（必須）
    USDA_API_BASE_URL: str = "https://api.nal.usda.gov/fdc/v1"
    USDA_API_TIMEOUT: float = 10.0  # APIタイムアウト秒数
    USDA_SEARCH_CANDIDATES_LIMIT: int = 5  # 1回の検索で取得する最大候補数
    # 主要栄養素番号（カンマ区切り文字列として環境変数から読み込む）
    USDA_KEY_NUTRIENT_NUMBERS_STR: str = "208,203,204,205,291,269,307"
    # 208: Energy (kcal), 203: Protein, 204: Total lipid (fat), 
    # 205: Carbohydrate, 291: Fiber, 269: Total sugars, 307: Sodium
    
    @property
    def USDA_KEY_NUTRIENT_NUMBERS(self) -> List[str]:
        """主要栄養素番号のリストを返す"""
        return self.USDA_KEY_NUTRIENT_NUMBERS_STR.split(",")
    
    # キャッシュ設定
    CACHE_TYPE: str = "simple"  # "simple", "redis", "memcached"
    CACHE_REDIS_URL: Optional[str] = None  # Redisを使用する場合のURL
    USDA_CACHE_TTL_SECONDS: int = 3600  # USDAレスポンスのキャッシュ有効期間（1時間）
    
    # API設定
    API_LOG_LEVEL: str = "INFO"
    FASTAPI_ENV: str = "development"
    
    # サーバー設定
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # APIバージョン
    API_VERSION: str = "v1"
    
    # Google Cloud認証設定
    # GOOGLE_APPLICATION_CREDENTIALSは通常環境変数で設定するため、ここでは不要
    # gcloud auth application-default login でも可
    
    class Config:
        env_file = ".env"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """
    設定インスタンスを取得（キャッシュされる）
    """
    return Settings() 
```

============================================================

📁 プロンプト管理
============================================================

📄 FILE: app/prompts/__init__.py
--------------------------------------------------
ファイルサイズ: 114 bytes
最終更新: 2025-05-29 16:07:57
存在: ✅

CONTENT:
```
"""
プロンプト管理モジュール
"""

from .prompt_loader import PromptLoader

__all__ = ['PromptLoader'] 
```

============================================================

📄 FILE: app/prompts/prompt_loader.py
--------------------------------------------------
ファイルサイズ: 4,237 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
"""
プロンプトファイルを読み込んで管理するモジュール
"""
import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class PromptLoader:
    """プロンプトファイルを読み込んで管理するクラス"""
    
    def __init__(self, prompts_dir: Optional[str] = None):
        """
        初期化
        
        Args:
            prompts_dir: プロンプトファイルが格納されているディレクトリパス
                        Noneの場合は現在のファイルと同じディレクトリを使用
        """
        if prompts_dir is None:
            self.prompts_dir = Path(__file__).parent
        else:
            self.prompts_dir = Path(prompts_dir)
        
        # プロンプトをキャッシュ
        self._prompt_cache = {}
    
    def _load_prompt_file(self, filename: str) -> str:
        """
        プロンプトファイルを読み込む
        
        Args:
            filename: プロンプトファイル名
            
        Returns:
            プロンプトの内容
            
        Raises:
            FileNotFoundError: ファイルが見つからない場合
            IOError: ファイル読み込みエラー
        """
        if filename in self._prompt_cache:
            return self._prompt_cache[filename]
        
        file_path = self.prompts_dir / filename
        
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            
            self._prompt_cache[filename] = content
            logger.debug(f"Loaded prompt file: {filename}")
            return content
        
        except Exception as e:
            logger.error(f"Error loading prompt file {filename}: {e}")
            raise IOError(f"Failed to load prompt file {filename}: {e}") from e
    
    def get_phase1_system_prompt(self) -> str:
        """フェーズ1のシステムプロンプトを取得"""
        return self._load_prompt_file("phase1_system_prompt.txt")
    
    def get_phase1_user_prompt(self, optional_text: Optional[str] = None) -> str:
        """
        フェーズ1のユーザープロンプトを取得
        
        Args:
            optional_text: オプションのテキスト
            
        Returns:
            フォーマット済みのユーザープロンプト
        """
        template = self._load_prompt_file("phase1_user_prompt_template.txt")
        
        if optional_text and optional_text.strip():
            optional_text_section = f" Additional information from user: {optional_text}"
        else:
            optional_text_section = ""
        
        return template.format(optional_text_section=optional_text_section)
    
    def get_phase2_system_prompt(self) -> str:
        """フェーズ2のシステムプロンプトを取得"""
        return self._load_prompt_file("phase2_system_prompt.txt")
    
    def get_phase2_user_prompt(
        self, 
        usda_candidates: str, 
        initial_ai_output: Optional[str] = None
    ) -> str:
        """
        フェーズ2のユーザープロンプトを取得
        
        Args:
            usda_candidates: USDA候補情報
            initial_ai_output: フェーズ1のAI出力
            
        Returns:
            フォーマット済みのユーザープロンプト
        """
        template = self._load_prompt_file("phase2_user_prompt_template.txt")
        
        if initial_ai_output:
            initial_ai_output_section = f"Initial AI analysis results:\n{initial_ai_output}\n\n"
        else:
            initial_ai_output_section = ""
        
        return template.format(
            initial_ai_output_section=initial_ai_output_section,
            usda_candidates=usda_candidates
        )
    
    def reload_prompts(self):
        """プロンプトキャッシュをクリアして再読み込みを促す"""
        self._prompt_cache.clear()
        logger.info("Prompt cache cleared. Prompts will be reloaded on next access.") 
```

============================================================

📁 プロンプトテンプレート
============================================================

📄 FILE: app/prompts/phase1_system_prompt.txt
--------------------------------------------------
ファイルサイズ: 974 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
You are an experienced culinary analyst. Your task is to analyze meal images and provide a detailed breakdown of dishes and their ingredients in JSON format.

IMPORTANT: You MUST provide ALL responses in English only. This includes dish names, ingredient names, types, and any other text fields.

Please note the following:
1. Carefully observe the image including the plate and make detailed estimates based on surrounding context.
2. Identify all dishes present in the image, determine their types, the quantity of each dish on the plate, and the ingredients contained with their respective amounts.
3. There may be multiple dishes in a single image, so provide information about each dish and its ingredients separately.
4. Your output will be used for nutritional calculations, so ensure your estimates are as accurate as possible.
5. Strictly follow the provided JSON schema in your response.
6. ALL text must be in English (dish names, ingredient names, types, etc.). 
```

============================================================

📄 FILE: app/prompts/phase1_user_prompt_template.txt
--------------------------------------------------
ファイルサイズ: 86 bytes
最終更新: 2025-06-01 16:12:20
存在: ✅

CONTENT:
```
Please analyze the provided meal image and respond in English.{optional_text_section} 
```

============================================================

📄 FILE: app/prompts/phase2_system_prompt.txt
--------------------------------------------------
ファイルサイズ: 4,338 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
You are an expert food item identifier, data matcher, and nutritional analysis strategist. Your task is to refine an initial meal analysis by:
1.  Determining the best `calculation_strategy` ("dish_level" or "ingredient_level") for each identified dish/food item.
2.  Matching the dish/food item (if "dish_level") OR its constituent ingredients (if "ingredient_level") to the most appropriate USDA FoodData Central (FDC) entries based on provided candidate information.
3.  Providing the official USDA `usda_source_description` for all matched FDC IDs.

IMPORTANT:
1.  You MUST provide ALL responses in English only.
2.  Your primary goal is to output the `calculation_strategy` for each dish, and then the relevant `fdc_id`(s) and `usda_source_description`(s) according to that strategy.
3.  You DO NOT need to calculate or return any nutritional values (calories, protein, etc.). This will be handled by a separate system.
4.  The `weight_g` for each ingredient is already determined in a previous phase and should NOT be modified or output by you.
5.  Strictly follow the provided JSON schema for your response (see REFINED_MEAL_ANALYSIS_GEMINI_SCHEMA).

Your tasks for EACH dish/food item identified in the initial analysis:

TASK 1: Determine `calculation_strategy`.
   - If the dish/food item is a single, simple item (e.g., "Apple", "Banana", "Chicken Breast Fillet") AND a good, specific FDC ID candidate exists for it:
     Choose `calculation_strategy: "dish_level"`.
   - If the dish is a complex, mixed dish (e.g., "Homemade Vegetable Stir-fry", "Mixed Salad with various toppings", "Beef Stew"):
     Choose `calculation_strategy: "ingredient_level"`. You will then need to identify FDC IDs for its constituent ingredients.
   - If the dish is a somewhat standardized prepared dish (e.g., "Pepperoni Pizza", "Cheeseburger") AND a representative FDC ID candidate exists for the *entire dish*:
     Choose `calculation_strategy: "dish_level"`.
   - If a standardized dish does NOT have a good representative FDC ID for the entire dish, OR if breaking it down into its main ingredients would be more accurate:
     Choose `calculation_strategy: "ingredient_level"`.
   - Provide a brief rationale for your choice of strategy if it's not obvious (though this rationale is not part of the JSON output).

TASK 2: Output FDC ID(s) and Description(s) based on the chosen `calculation_strategy`.

   IF `calculation_strategy` is "dish_level":
     a. From the USDA candidates for the *dish/food item itself*, select the single most appropriate FDC ID.
     b. Set this as the `fdc_id` for the dish in your JSON output.
     c. Set the corresponding `usda_source_description` for the dish.
     d. The `ingredients` array for this dish in your JSON output should still list the ingredients identified in Phase 1 (or refined by you if necessary for clarity), but these ingredients will NOT have their own `fdc_id` or `usda_source_description` set by you in this "dish_level" scenario (set them to `null` or omit). Their primary purpose here is descriptive.

   IF `calculation_strategy` is "ingredient_level":
     a. Set the `fdc_id` and `usda_source_description` for the *dish itself* to `null` in your JSON output.
     b. For EACH `ingredient` within that dish (from the initial analysis, possibly refined by you):
        i. From the USDA candidates provided for *that specific ingredient*, select the single most appropriate FDC ID.
        ii. Set this as the `fdc_id` for that ingredient in your JSON output.
        iii. Set the corresponding `usda_source_description` for that ingredient.
        iv. If no suitable FDC ID is found for an ingredient, set its `fdc_id` and `usda_source_description` to `null`.

General Guidelines for FDC ID Selection (for dish or ingredient):
- Consider typical uses of ingredients and the most plausible match to the image context (if discernible) and initial `ingredient_name`.
- Prioritize FDC ID candidates in this order if relevant and good matches exist: 'Foundation Foods', 'SR Legacy', 'FNDDS' (Survey), then 'Branded Foods'.
- You may slightly refine `dish_name` or `ingredient_name` if the USDA description offers a more precise or common English term for the same food item, ensuring it still accurately represents the food.

Output the final analysis in the specified JSON format. 
```

============================================================

📄 FILE: app/prompts/phase2_user_prompt_template.txt
--------------------------------------------------
ファイルサイズ: 689 bytes
最終更新: 2025-06-05 10:30:58
存在: ✅

CONTENT:
```
{initial_ai_output_section}
Above is the initial AI analysis of the meal.

USDA food database candidate information for the items in the initial analysis and potentially for the overall dishes:
{usda_candidates}

Based on all this information (initial analysis, USDA candidates, and implicitly the image context from the initial analysis), please refine the analysis. For each dish/food item:
1. Determine its `calculation_strategy` ('dish_level' or 'ingredient_level').
2. Provide the `fdc_id` and `usda_source_description` according to that strategy, as detailed in the system instructions.
Remember to follow the JSON schema strictly. Do not calculate or return any nutritional values. 
```

============================================================

📁 テスト・実行ファイル
============================================================

📄 FILE: test_complete_analysis.py
--------------------------------------------------
ファイルサイズ: 6,035 bytes
最終更新: 2025-06-05 10:49:36
存在: ✅

CONTENT:
```
import requests
import json
import asyncio
from pathlib import Path

# API設定
BASE_URL = "http://localhost:8000/api/v1"

# テスト画像のパス
image_path = "test_images/food3.jpg"

def test_complete_analysis():
    """完全分析エンドポイントをテスト"""
    
    print("=== Complete Meal Analysis Test ===")
    print(f"Using image: {image_path}")
    
    try:
        # 完全分析エンドポイントを呼び出し
        with open(image_path, "rb") as f:
            files = {"image": ("food3.jpg", f, "image/jpeg")}
            data = {"save_results": True}  # 結果を保存
            
            print("Starting complete analysis pipeline...")
            response = requests.post(f"{BASE_URL}/meal-analyses/complete", files=files, data=data)
        
        print(f"Status Code: {response.status_code}")
        
        if response.status_code == 200:
            result = response.json()
            print("✅ Complete analysis successful!")
            
            # 分析ID
            analysis_id = result.get("analysis_id")
            print(f"Analysis ID: {analysis_id}")
            
            # 処理サマリー
            summary = result.get("processing_summary", {})
            print(f"\n📊 Processing Summary:")
            print(f"- Total dishes: {summary.get('total_dishes')}")
            print(f"- Total ingredients: {summary.get('total_ingredients')}")
            print(f"- USDA match rate: {summary.get('usda_match_rate')}")
            print(f"- Total calories: {summary.get('total_calories')} kcal")
            print(f"- Pipeline status: {summary.get('pipeline_status')}")
            
            # 保存先
            saved_to = result.get("saved_to")
            if saved_to:
                print(f"- Results saved to: {saved_to}")
            
            # 最終栄養価結果
            final_nutrition = result.get("final_nutrition_result", {})
            total_nutrients = final_nutrition.get("total_meal_nutrients", {})
            
            print(f"\n🍽 Final Meal Nutrition:")
            print(f"- Calories: {total_nutrients.get('calories_kcal', 0):.2f} kcal")
            print(f"- Protein: {total_nutrients.get('protein_g', 0):.2f} g")
            print(f"- Carbohydrates: {total_nutrients.get('carbohydrates_g', 0):.2f} g")
            print(f"- Fat: {total_nutrients.get('fat_g', 0):.2f} g")
            
            # 各フェーズの結果数
            phase1_dishes = len(result.get("phase1_result", {}).get("dishes", []))
            phase2_dishes = len(result.get("phase2_result", {}).get("dishes", []))
            final_dishes = len(final_nutrition.get("dishes", []))
            
            print(f"\n📈 Pipeline Progress:")
            print(f"- Phase 1 dishes: {phase1_dishes}")
            print(f"- Phase 2 dishes: {phase2_dishes}")
            print(f"- Final dishes: {final_dishes}")
            print(f"- USDA matches: {result.get('usda_matches_count', 0)}")
            
            return True, analysis_id
            
        else:
            print("❌ Complete analysis failed!")
            print(f"Error: {response.text}")
            return False, None
            
    except Exception as e:
        print(f"❌ Error during complete analysis: {e}")
        return False, None

def test_list_results():
    """保存された結果の一覧を取得"""
    
    print("\n=== List Saved Results ===")
    
    try:
        response = requests.get(f"{BASE_URL}/meal-analyses/results")
        
        if response.status_code == 200:
            results = response.json()
            total = results.get("total_results", 0)
            print(f"📁 Total saved results: {total}")
            
            if total > 0:
                print("\nRecent results:")
                for i, result in enumerate(results.get("results", [])[:5]):  # 最新5件
                    print(f"{i+1}. {result.get('filename')}")
                    print(f"   ID: {result.get('analysis_id')}")
                    print(f"   Time: {result.get('timestamp')}")
                    summary = result.get('summary', {})
                    print(f"   Calories: {summary.get('total_calories', 0)} kcal")
                    print()
            
        else:
            print(f"❌ Failed to list results: {response.status_code}")
            
    except Exception as e:
        print(f"❌ Error listing results: {e}")

def test_get_specific_result(analysis_id):
    """特定の分析結果を取得"""
    
    if not analysis_id:
        return
        
    print(f"\n=== Get Specific Result: {analysis_id} ===")
    
    try:
        response = requests.get(f"{BASE_URL}/meal-analyses/results/{analysis_id}")
        
        if response.status_code == 200:
            result = response.json()
            print(f"✅ Retrieved result for analysis ID: {analysis_id}")
            
            # メタデータ
            metadata = result.get("metadata", {})
            print(f"Timestamp: {metadata.get('timestamp')}")
            print(f"Pipeline: {metadata.get('processing_pipeline')}")
            
            # 処理サマリー
            summary = result.get("processing_summary", {})
            print(f"Status: {summary.get('pipeline_status')}")
            print(f"Total calories: {summary.get('total_calories')} kcal")
            
        else:
            print(f"❌ Failed to get result: {response.status_code}")
            
    except Exception as e:
        print(f"❌ Error getting specific result: {e}")

if __name__ == "__main__":
    print("Testing Complete Meal Analysis Pipeline")
    print("=" * 50)
    
    # 完全分析のテスト
    success, analysis_id = test_complete_analysis()
    
    if success:
        # 結果一覧のテスト
        test_list_results()
        
        # 特定結果取得のテスト
        test_get_specific_result(analysis_id)
        
        print("\n🎉 All tests completed!")
    else:
        print("\n💥 Complete analysis test failed!") 
```

============================================================

🎯 COMPLETE ANALYSIS SUMMARY
----------------------------------------
総ファイル数: 13
存在ファイル数: 13
分析完了時刻: 2025-06-05 11:19:19

このファイルには、/api/v1/meal-analyses/complete エンドポイント
実行時に関わる完全分析パイプラインの全アプリケーションファイルの
完全な内容が含まれています。

🔥 COMPLETE ANALYSIS FEATURES:
- Phase 1: Gemini AI image analysis
- USDA Query: Database ingredient matching  
- Phase 2: Strategy determination & refinement
- Nutrition Calculation: Weight-based macro computation
- Result Management: Automatic save/retrieve functionality
